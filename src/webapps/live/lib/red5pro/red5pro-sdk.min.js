/*!
 * 
 *   red5pro-sdk - Red5 Pro HTML Publisher and Subscriber SDK.
 *   Author: Infrared5 Inc.
 *   Version: 4.0.0-RC2
 *   Url: https://github.com/red5pro/red5pro-html-sdk#readme
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["red5prosdk"] = factory();
	else
		root["red5prosdk"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 344);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , core      = __webpack_require__(29)
  , hide      = __webpack_require__(15)
  , redefine  = __webpack_require__(16)
  , ctx       = __webpack_require__(30)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fatal = exports.error = exports.warn = exports.debug = exports.info = exports.trace = exports.getLogger = exports.establishLogger = exports.LEVELS = undefined;

var _browserBunyan = __webpack_require__(110);

var _bunyanWriter = __webpack_require__(148);

var logger = void 0;
var formatMessage = function formatMessage(dispatcher) {
  return function (message) {
    return '(' + dispatcher + ') ' + message;
  };
};
var decorate = function decorate(level) {
  return function (source, message) {
    logger[level](formatMessage(source)(message));
  };
};
var LEVELS = exports.LEVELS = {
  TRACE: 'trace',
  INFO: 'info',
  DEBUG: 'debug',
  WARN: 'warn',
  ERROR: 'error',
  FATAL: 'fatal'
};

var establishLogger = exports.establishLogger = function establishLogger(level) {
  var streamList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  var streams = [];
  streams.push({
    level: level,
    stream: new _bunyanWriter.RawStream(),
    type: 'raw'
  });
  if (streamList) {
    var list = streamList.map(function (item) {
      item.level = level;
    });
    streams = streams.concat(list);
  }
  logger = (0, _browserBunyan.createLogger)({
    level: level,
    name: 'red5pro-sdk',
    streams: streams
  });
};

var getLogger = exports.getLogger = function getLogger() {
  return logger;
};

var trace = exports.trace = decorate(LEVELS.TRACE);
var info = exports.info = decorate(LEVELS.INFO);
var debug = exports.debug = decorate(LEVELS.DEBUG);
var warn = exports.warn = decorate(LEVELS.WARN);
var error = exports.error = decorate(LEVELS.ERROR);
var fatal = exports.fatal = decorate(LEVELS.FATAL);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(66)('wks')
  , uid        = __webpack_require__(44)
  , Symbol     = __webpack_require__(2).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(1)
  , IE8_DOM_DEFINE = __webpack_require__(119)
  , toPrimitive    = __webpack_require__(28)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _promise = __webpack_require__(10);

var _errors = __webpack_require__(143);

var _metadataUtil = __webpack_require__(142);

var rtmpSubscriberAssignments = [];
var closeHandlers = [];
var fullscreenHandlers = [];
var screenfullHandlerAssigned = false;
function enableScreenfullHandler() {
  if (!screenfullHandlerAssigned && window.screenfull && window.screenfull.enabled) {
    screenfullHandlerAssigned = true;
    window.screenfull.onchange(function () {
      var i = void 0,
          length = fullscreenHandlers.length;
      for (i = 0; i < length; i++) {
        fullscreenHandlers[i](window.screenfull.isFullscreen);
      }
    });
  }
}

function onwindowclose(e) {
  // eslint-disable-line no-unused-vars
  //  closeHandlers.forEach(h => h())
  var i = void 0,
      length = closeHandlers.length;
  for (i = 0; i < length; i++) {
    closeHandlers[i]();
  }
  // Returning a string value forces a leaving confirmation popup on the browser.
  //  e.returnValue = 'goodbye'
  //  return 'goodbye'
}

// https://github.com/videojs/video.js/blob/master/src/js/tech/flash.js#L476
var flashVersion = function flashVersion() {
  var version = '0,0,0';
  // IE
  try {
    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];

    // other browsers
  } catch (e) {
    try {
      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
      }
    } catch (err) {
      // nada
    }
  }
  return version.split(',');
};

var requestFrame = function (time) {
  return window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (fn) {
    return window.setTimeout(fn, time);
  };
}(1000);

var trackResize = function trackResize(element, raf) {
  return function () {
    var parent = element.parentNode;
    parent.style.height = element.clientWidth + 'px';
    var pwidth = parent.clientWidth;
    var ewidth = element.clientHeight;
    var margin = (pwidth - ewidth) * 0.5;
    element.style.position = 'relative';
    element.style.left = margin + 'px';
    raf(trackResize(element, raf));
  };
};

var isMoz = !!navigator.mozGetUserMedia;
// If developer has not used adapter.js
if (!window.adapter) {
  navigator.getUserMedia = navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia;
}

var origin = ['webkitTransformOrigin', 'mozTransformOrigin', 'msTransformOrigin', 'oTransformOrigin', 'transformOrigin'];
var styles = ['webkitTransform', 'mozTransform', 'msTransform', 'oTransform', 'transform'];
var transition = ['webkitTransition', 'mozTransition', 'msTransition', 'oTransition', 'transition'];
var rotationTranslations = {
  '0': {
    origin: 'center center',
    transform: 'rotate(0deg)'
  },
  '90': {
    origin: 'left top',
    transform: 'rotate(90deg) translateY(-100%)'
  },
  '180': {
    origin: 'center center',
    transform: 'rotate(180deg)'
  },
  '270': {
    origin: 'top left',
    transform: 'rotate(270deg) translateX(-100%) translateY(0%)'
  },
  '-90': {
    origin: 'left top',
    transform: 'rotate(-90deg) translateX(-100%)'
  },
  '-180': {
    origin: 'center center',
    transform: 'rotate(-180deg)'
  },
  '-270': {
    origin: 'top left',
    transform: 'rotate(-270deg) translateY(-100%)'
  }
};

exports.default = {

  requestFrame: requestFrame,

  getIsMoz: function getIsMoz() {
    return isMoz;
  },

  supportsWebSocket: function supportsWebSocket() {
    return !!window.WebSocket;
  },

  supportsHLS: function supportsHLS() {
    var el = document.createElement('video');
    return el.canPlayType('application/vnd.apple.mpegURL').length > 0 || el.canPlayType('application/x-mpegURL').length > 0 || el.canPlayType('audio/mpegurl').length > 0 || el.canPlayType('audio/x-mpegurl').length > 0;
  },

  supportsFlashVersion: function supportsFlashVersion(version) {
    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';

    return flashVersion()[0] >= version.split(delimiter)[0];
  },

  resolveElement: function resolveElement(id) {
    try {
      var el = document.getElementById(id);
      if (!el) {
        throw new _errors.NoElementFoundError('Element with id(' + id + ') could not be found.');
      }
      return el;
    } catch (e) {
      throw new _errors.NoElementFoundError('Error in accessing element with id(' + id + '). ' + e.message);
    }
  },

  createWebSocket: function createWebSocket(url) {
    return new window.WebSocket(url);
  },

  setVideoSource: function setVideoSource(videoElement, mediaStream) {
    var autoplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if ('srcObject' in videoElement) {
      videoElement.srcObject = mediaStream;
    } else if (isMoz) {
      videoElement['mozSrcObject'] = mediaStream;
    } else {
      videoElement.src = window.URL.createObjectURL(mediaStream);
    }
    if (autoplay) {
      videoElement.play();
    } else {
      try {
        videoElement.setAttribute('autoplay', false);
        videoElement.pause();
      } catch (e) {
        // nada.
      }
    }
  },

  injectScript: function injectScript(url) {
    var dfd = new _promise.DeferredPromise();
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.onload = function () {
      dfd.resolve();
    };
    script.onreadystatechange = function () {
      if (script.readyState === 'loaded' || script.readyState === 'complete') {
        script.onreadystatechange = null;
        dfd.resolve();
      }
    };
    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
    return dfd.promise;
  },

  gUM: function gUM(constraints) {
    return (navigator.mediaDevices || navigator).getUserMedia(constraints);
  },

  setGlobal: function setGlobal(prop, value) {
    window[prop] = value;
  },

  getSwfObject: function getSwfObject() {
    return window.swfobject;
  },

  getEmbedObject: function getEmbedObject(id) {
    return document.getElementById(id);
  },

  getElementId: function getElementId(el) {
    return el.getAttribute('id');
  },

  addCloseHandler: function addCloseHandler(handler) {
    var insertValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

    closeHandlers.slice(insertValue === -1 ? closeHandlers.length : insertValue, 0, handler);
    if (window.onbeforeunload !== onwindowclose) {
      window.onbeforeunload = onwindowclose;
      window.addEventListener('unload', onwindowclose);
    }
  },

  removeCloseHandler: function removeCloseHandler(handler) {
    var i = closeHandlers.length;
    while (--i > -1) {
      if (closeHandlers[i] === handler) {
        closeHandlers.slice(i, 1);
        break;
      }
    }
  },

  invoke: function invoke(methodName, data) {
    if (window.hasOwnProperty(methodName)) {
      window[methodName].call(window, data);
    }
  },

  // requires <script src="lib/screenfull/screenfull.min.js"></script>
  toggleFullScreen: function toggleFullScreen(element) {
    if (window.screenfull && window.screenfull.enabled) {
      window.screenfull.toggle(element);
    }
  },

  onFullScreenStateChange: function onFullScreenStateChange(cb) {
    fullscreenHandlers.push(cb);
    enableScreenfullHandler(window.screenfull);
  },

  onOrientationMetadata: _metadataUtil.onOrientationMetadata,

  applyOrientation: function applyOrientation(element, value) {
    var i = void 0,
        length = styles.length;
    value = value % 360;
    var translations = rotationTranslations[value.toString()];
    for (i = 0; i < length; i++) {
      element.style[origin[i]] = translations.origin;
      element.style[styles[i]] = translations.transform;
      element.style[transition[i]] = 'transform 0.0s linear';
    }
    if (value % 180 !== 0) {
      element.style.width = 'inherit';
      var parent = element.parentNode;
      var pheight = parent.clientHeight;
      var scale = pheight / element.clientWidth;
      element.style.width = element.clientWidth * scale + 'px';
      if (document.attachEvent) {
        parent.attachEvent('resize', trackResize(element));
      } else {
        trackResize(element, requestFrame)();
      }
    }
  },

  hasAttributeDefined: function hasAttributeDefined(elem, attribute) {
    var att = elem.getAttribute(attribute);
    return att !== null && (typeof att === 'undefined' ? 'undefined' : _typeof(att)) !== undefined && typeof att === 'string' && (att === '' || att === 'true');
  },

  hasClassDefined: function hasClassDefined(elem, className) {
    return elem.classList.contains(className);
  },

  createElement: function createElement(tagName, opts) {
    if (tagName === 'text') {
      return document.createTextNode(opts.toString());
    }
    return document.createElement(tagName, opts);
  },

  addSubscriptionAssignmentHandler: function addSubscriptionAssignmentHandler(fn) {
    rtmpSubscriberAssignments.push(fn);
    if (window.setSubscriberId === undefined) {
      window.setSubscriberId = function (id) {
        rtmpSubscriberAssignments.shift()(id);
      };
    }
  },

  getMouseXFromEvent: function getMouseXFromEvent(event) {
    if (!event) {
      event = window.event;
    }

    if (event.pageX) {
      return event.pageX;
    } else if (event.clientX) {
      return event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    }

    return 0;
  },

  getScrollX: function getScrollX() {
    return window.pageXOffset !== undefined ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  },

  getGlobal: function getGlobal() {
    return window;
  }

};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _DeferredPromise = function _DeferredPromise() {
  var _this = this;

  _classCallCheck(this, _DeferredPromise);

  this.resolve = undefined;
  this.reject = undefined;
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
};

var _Future = {
  createIfNotExist: function createIfNotExist(deferredIfExist) {
    var f = deferredIfExist;
    if (!f) {
      f = new _DeferredPromise();
    }
    return f;
  }
};

var DeferredPromise = exports.DeferredPromise = _DeferredPromise;
var Future = exports.Future = _Future;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(35)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(23);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 13 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(8)
  , createDesc = __webpack_require__(34);
module.exports = __webpack_require__(7) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , hide      = __webpack_require__(15)
  , has       = __webpack_require__(13)
  , SRC       = __webpack_require__(44)('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

__webpack_require__(29).inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , fails   = __webpack_require__(3)
  , defined = __webpack_require__(23)
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(52)
  , defined = __webpack_require__(23);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WILDCARD = '*';
var WILDCARD_KEY = 'RED5PRO';

var EventEmitter = function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this._callbacks = {};
    this._callbacks[WILDCARD_KEY] = [];
  }

  _createClass(EventEmitter, [{
    key: '_notify',
    value: function _notify(callbacks, event) {
      var i = void 0,
          length = callbacks.length;
      for (i = 0; i < length; i++) {
        callbacks[i](event);
      }
    }
  }, {
    key: 'on',
    value: function on(type, fn) {
      if (typeof fn !== 'function') {
        return;
      }

      if (type === WILDCARD) {
        this._callbacks[WILDCARD_KEY].push(fn);
        return;
      }

      if (this._callbacks[type] === undefined) {
        this._callbacks[type] = [];
      }

      if (this._callbacks[type].indexOf(fn) === -1) {
        this._callbacks[type].push(fn);
      }
    }
  }, {
    key: 'off',
    value: function off(type, fn) {
      var map = this._callbacks[type];
      if (type === WILDCARD) {
        map = this._callbacks[WILDCARD_KEY];
      }
      if (map) {
        var index = map.indexOf(fn);
        if (index !== -1) {
          map.splice(index, 1);
        }
      }
    }
  }, {
    key: 'trigger',
    value: function trigger(event) {
      var type = event.type;
      if (this._callbacks[type]) {
        this._notify(this._callbacks[type], event);
      }
      this._notify(this._callbacks[WILDCARD_KEY], event);
    }
  }]);

  return EventEmitter;
}();

exports.default = EventEmitter;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(53)
  , createDesc     = __webpack_require__(34)
  , toIObject      = __webpack_require__(18)
  , toPrimitive    = __webpack_require__(28)
  , has            = __webpack_require__(13)
  , IE8_DOM_DEFINE = __webpack_require__(119)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(13)
  , toObject    = __webpack_require__(12)
  , IE_PROTO    = __webpack_require__(87)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 22 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 23 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(3);

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _publisherEvent = __webpack_require__(100);

Object.defineProperty(exports, 'PublisherEventTypes', {
  enumerable: true,
  get: function get() {
    return _publisherEvent.common;
  }
});
Object.defineProperty(exports, 'RTCPublisherEventTypes', {
  enumerable: true,
  get: function get() {
    return _publisherEvent.rtc;
  }
});
Object.defineProperty(exports, 'RTMPPublisherEventTypes', {
  enumerable: true,
  get: function get() {
    return _publisherEvent.rtmp;
  }
});
Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
  enumerable: true,
  get: function get() {
    return _publisherEvent.failover;
  }
});

var _subscriberEvent = __webpack_require__(101);

Object.defineProperty(exports, 'SubscriberEventTypes', {
  enumerable: true,
  get: function get() {
    return _subscriberEvent.common;
  }
});
Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
  enumerable: true,
  get: function get() {
    return _subscriberEvent.rtc;
  }
});
Object.defineProperty(exports, 'RTMPSubscriberEventTypes', {
  enumerable: true,
  get: function get() {
    return _subscriberEvent.rtmp;
  }
});
Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
  enumerable: true,
  get: function get() {
    return _subscriberEvent.failover;
  }
});

var _sharedobjectEvent = __webpack_require__(70);

Object.defineProperty(exports, 'SharedObjectEventTypes', {
  enumerable: true,
  get: function get() {
    return _sharedobjectEvent.common;
  }
});

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Event = function () {
  function Event(type) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    _classCallCheck(this, Event);

    this._type = type;
    this._data = data;
  }

  _createClass(Event, [{
    key: 'type',
    get: function get() {
      return this._type;
    }
  }, {
    key: 'data',
    get: function get() {
      return this._data;
    }
  }]);

  return Event;
}();

var PublisherEvent = function (_Event) {
  _inherits(PublisherEvent, _Event);

  function PublisherEvent(type, publisher, data) {
    _classCallCheck(this, PublisherEvent);

    var _this = _possibleConstructorReturn(this, (PublisherEvent.__proto__ || Object.getPrototypeOf(PublisherEvent)).call(this, type, data));

    _this._publisher = publisher;
    return _this;
  }

  _createClass(PublisherEvent, [{
    key: 'publisher',
    get: function get() {
      return this._publisher;
    }
  }]);

  return PublisherEvent;
}(Event);

var SubscriberEvent = function (_Event2) {
  _inherits(SubscriberEvent, _Event2);

  function SubscriberEvent(type, subscriber, data) {
    _classCallCheck(this, SubscriberEvent);

    var _this2 = _possibleConstructorReturn(this, (SubscriberEvent.__proto__ || Object.getPrototypeOf(SubscriberEvent)).call(this, type, data));

    _this2._subscriber = subscriber;
    return _this2;
  }

  _createClass(SubscriberEvent, [{
    key: 'subscriber',
    get: function get() {
      return this._subscriber;
    }
  }]);

  return SubscriberEvent;
}(Event);

var SharedObjectEvent = function (_Event3) {
  _inherits(SharedObjectEvent, _Event3);

  function SharedObjectEvent(type, sharedObjectName, data) {
    _classCallCheck(this, SharedObjectEvent);

    var _this3 = _possibleConstructorReturn(this, (SharedObjectEvent.__proto__ || Object.getPrototypeOf(SharedObjectEvent)).call(this, type, data));

    _this3._name = sharedObjectName;
    return _this3;
  }

  _createClass(SharedObjectEvent, [{
    key: 'name',
    get: function get() {
      return this._name;
    }
  }]);

  return SharedObjectEvent;
}(Event);

exports.Event = Event;
exports.PublisherEvent = PublisherEvent;
exports.SubscriberEvent = SubscriberEvent;
exports.SharedObjectEvent = SharedObjectEvent;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(30)
  , IObject  = __webpack_require__(52)
  , toObject = __webpack_require__(12)
  , toLength = __webpack_require__(11)
  , asc      = __webpack_require__(165);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0)
  , core    = __webpack_require__(29)
  , fails   = __webpack_require__(3);
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(4);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(14);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var Map     = __webpack_require__(135)
  , $export = __webpack_require__(0)
  , shared  = __webpack_require__(66)('metadata')
  , store   = shared.store || (shared.store = new (__webpack_require__(138)));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if(__webpack_require__(7)){
  var LIBRARY             = __webpack_require__(37)
    , global              = __webpack_require__(2)
    , fails               = __webpack_require__(3)
    , $export             = __webpack_require__(0)
    , $typed              = __webpack_require__(67)
    , $buffer             = __webpack_require__(94)
    , ctx                 = __webpack_require__(30)
    , anInstance          = __webpack_require__(36)
    , propertyDesc        = __webpack_require__(34)
    , hide                = __webpack_require__(15)
    , redefineAll         = __webpack_require__(41)
    , toInteger           = __webpack_require__(35)
    , toLength            = __webpack_require__(11)
    , toIndex             = __webpack_require__(43)
    , toPrimitive         = __webpack_require__(28)
    , has                 = __webpack_require__(13)
    , same                = __webpack_require__(132)
    , classof             = __webpack_require__(51)
    , isObject            = __webpack_require__(4)
    , toObject            = __webpack_require__(12)
    , isArrayIter         = __webpack_require__(79)
    , create              = __webpack_require__(38)
    , getPrototypeOf      = __webpack_require__(21)
    , gOPN                = __webpack_require__(39).f
    , getIterFn           = __webpack_require__(96)
    , uid                 = __webpack_require__(44)
    , wks                 = __webpack_require__(6)
    , createArrayMethod   = __webpack_require__(26)
    , createArrayIncludes = __webpack_require__(57)
    , speciesConstructor  = __webpack_require__(88)
    , ArrayIterators      = __webpack_require__(97)
    , Iterators           = __webpack_require__(47)
    , $iterDetect         = __webpack_require__(63)
    , setSpecies          = __webpack_require__(42)
    , arrayFill           = __webpack_require__(72)
    , arrayCopyWithin     = __webpack_require__(112)
    , $DP                 = __webpack_require__(8)
    , $GOPD               = __webpack_require__(20)
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(44)('meta')
  , isObject = __webpack_require__(4)
  , has      = __webpack_require__(13)
  , setDesc  = __webpack_require__(8).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(3)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 35 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(1)
  , dPs         = __webpack_require__(125)
  , enumBugKeys = __webpack_require__(75)
  , IE_PROTO    = __webpack_require__(87)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(74)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(77).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(127)
  , hiddenKeys = __webpack_require__(75).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(127)
  , enumBugKeys = __webpack_require__(75);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(16);
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global      = __webpack_require__(2)
  , dP          = __webpack_require__(8)
  , DESCRIPTORS = __webpack_require__(7)
  , SPECIES     = __webpack_require__(6)('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(35)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 44 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(6)('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(15)(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var ctx         = __webpack_require__(30)
  , call        = __webpack_require__(121)
  , isArrayIter = __webpack_require__(79)
  , anObject    = __webpack_require__(1)
  , toLength    = __webpack_require__(11)
  , getIterFn   = __webpack_require__(96)
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(8).f
  , has = __webpack_require__(13)
  , TAG = __webpack_require__(6)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , defined = __webpack_require__(23)
  , fails   = __webpack_require__(3)
  , spaces  = __webpack_require__(92)
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var PlaybackState = exports.PlaybackState = Object.freeze({
  UNAVAILABLE: 1000,
  AVAILABLE: 0,
  IDLE: 1,
  PLAYING: 2,
  PAUSED: 3
});

var PlaybackStateReadable = exports.PlaybackStateReadable = Object.freeze({
  1000: 'Playback.UNAVAILABLE',
  0: 'Playback.AVAILABLE',
  1: 'Playback.IDLE',
  2: 'Playback.PLAYING',
  3: 'Playback.PAUSED'
});

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(22)
  , TAG = __webpack_require__(6)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(22);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 53 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RTCSessionDescription = exports.RTCIceCandidate = exports.RTCPeerConnection = exports.updateBandwidth = exports.forceUserMedia = exports.getUserMedia = exports.isSupported = exports.determineSupportedResolution = exports.quickResolutionSupport = undefined;

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _promise = __webpack_require__(10);

var _util = __webpack_require__(107);

var _object = __webpack_require__(108);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import { NoSupportedCameraResolutionsError } from '../exception/errors'

// Resolutions borrowed from https://github.com/webrtcHacks/WebRTC-Camera-Resolution/blob/master/js/resolutionScan.js
var formats = [{
  "label": "4K(UHD)",
  "width": 3840,
  "height": 2160
}, {
  "label": "1080p(FHD)",
  "width": 1920,
  "height": 1080
}, {
  "label": "UXGA",
  "width": 1600,
  "height": 1200
}, {
  "label": "720p(HD)",
  "width": 1280,
  "height": 720
}, {
  "label": "SVGA",
  "width": 800,
  "height": 600
}, {
  "label": "VGA",
  "width": 640,
  "height": 480
}, {
  "label": "360p(nHD)",
  "width": 640,
  "height": 360
}, {
  "label": "CIF",
  "width": 352,
  "height": 288
}, {
  "label": "QVGA",
  "width": 320,
  "height": 240
}, {
  "label": "QCIF",
  "width": 176,
  "height": 144
}, {
  "label": "QQVGA",
  "width": 160,
  "height": 120
}];

var hasResolutionsDefined = function hasResolutionsDefined(constraints) {
  return constraints.hasOwnProperty('video') && (constraints.video.hasOwnProperty('width') || constraints.video.hasOwnProperty('height'));
};

var getValueFromConstraintAttribute = function getValueFromConstraintAttribute(attribute) {
  return attribute.exact || attribute.ideal || attribute.max || attribute.min || attribute;
};

var isExact = (0, _util.curry)(function (constraints, format) {
  if (typeof constraints.video === 'boolean') {
    return true;
  }
  var w = constraints.video.hasOwnProperty('width') ? getValueFromConstraintAttribute(constraints.video.width) : 0;
  var h = constraints.video.hasOwnProperty('height') ? getValueFromConstraintAttribute(constraints.video.height) : 0;
  return w === format.width && h === format.height;
});

var isLower = (0, _util.curry)(function (constraints, format) {
  var w = constraints.video.hasOwnProperty('width') ? getValueFromConstraintAttribute(constraints.video.width) : 0;
  var h = constraints.video.hasOwnProperty('height') ? getValueFromConstraintAttribute(constraints.video.height) : 0;
  var desired = w * h;
  var dimensions = format.width * format.height;
  return dimensions < desired;
});

var hasMatchingFormat = (0, _util.curry)(function (formatsList, constraints) {
  return (0, _util.filter)(isExact(constraints))(formatsList).length > 0;
});

var findLowerResolutions = (0, _util.curry)(function (formatsList, constraints) {
  var resIsLower = isLower(constraints);
  return (0, _util.filter)(resIsLower)(formatsList);
});

var findNextSelection = function findNextSelection(data, selections, p) {
  if (selections.length == 0) {
    // if we got here, there is no support.
    p.reject('Could not find proper camera for provided constraints.');
    return;
  }
  var selection = selections.shift();
  data.video.width = { exact: selection.width };
  data.video.height = { exact: selection.height };
  _browser2.default.gUM(data).then(function (media) {
    p.resolve({
      media: media,
      constraints: data
    });
  }).catch(function (err) {
    // eslint-disable-line no-unused-vars
    (0, _log.debug)('[gUM:findformat]', 'Constraints declined by browser: ' + JSON.stringify(data, null, 2));
    findNextSelection(data, selections, p);
  });
};

var quickResolutionSupport = exports.quickResolutionSupport = function quickResolutionSupport(constraints) {
  var data = (0, _object.deepCopy)(constraints
  // if video: `true`, returned unscathed.
  );if (typeof constraints.video === 'boolean') {
    return data;
  }
  // else, define exact.
  if (constraints.video.width) {
    data.video.width = { exact: getValueFromConstraintAttribute(constraints.video.width) };
  }
  if (constraints.video.height) {
    data.video.height = { exact: getValueFromConstraintAttribute(constraints.video.height) };
  }
  return data;
};

var determineSupportedResolution = exports.determineSupportedResolution = function determineSupportedResolution(constraints) {
  var deferred = new _promise.DeferredPromise();
  var selections = findLowerResolutions(formats)(constraints);
  var data = (0, _object.deepCopy)(constraints);
  findNextSelection(data, selections, deferred);
  return deferred.promise;
};

var isSupported = exports.isSupported = function isSupported() {
  return _RTCPeerConnection && _RTCIceCandidate && _RTCSessionDescription;
};

var getUserMedia = exports.getUserMedia = function getUserMedia(constraints) {
  // Wrapping `getUserMedia` requests in another deferred promise so we can return the selected resolutions if successful.
  var dfd = new _promise.DeferredPromise();
  var isAvailableInFormats = hasMatchingFormat(formats);
  var failover = function failover() {
    determineSupportedResolution(constraints).then(function (res) {
      dfd.resolve({
        media: res.media,
        constraints: res.constraints
      });
    }).catch(function (error) {
      dfd.reject({
        error: error,
        constraints: constraints
      });
    });
  };
  if (!hasResolutionsDefined(constraints)) {
    _browser2.default.gUM(constraints).then(function (media) {
      dfd.resolve({
        media: media,
        constraints: constraints
      });
    }).catch(failover);
  } else if (isAvailableInFormats(constraints)) {
    // Try quick setting of `exact` resolution...
    var available = quickResolutionSupport(constraints);
    _browser2.default.gUM(available).then(function (media) {
      dfd.resolve({
        media: media,
        constraints: available
      });
    }).catch(failover);
  } else {
    failover();
  }
  return dfd.promise;
};

var forceUserMedia = exports.forceUserMedia = function forceUserMedia(constraints) {
  return _browser2.default.gUM(constraints);
};

// https://github.com/muaz-khan/WebRTC-Experiment/blob/master/RTCPeerConnection/RTCPeerConnection-v1.6.js#L158
// Muaz Khan     - github.com/muaz-khan
// MIT License   - www.WebRTC-Experiment.com/licence
// Documentation - github.com/muaz-khan/WebRTC-Experiment/tree/master/RTCPeerConnection
var updateBandwidth = exports.updateBandwidth = function updateBandwidth(options, sdp) {
  if (_browser2.default.getIsMoz()) {
    return sdp;
  }
  sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
  if (options.audio) {
    sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + options.audio + '\r\n');
  }
  if (options.video) {
    sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + options.video + '\r\n');
  }
  return sdp;
};

/** -- handled by adapter.js -- */
var _RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var _RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;
var _RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;

var RTCPeerConnection = exports.RTCPeerConnection = _RTCPeerConnection;
var RTCIceCandidate = exports.RTCIceCandidate = _RTCIceCandidate;
var RTCSessionDescription = exports.RTCSessionDescription = _RTCSessionDescription;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlaybackControlsImpl = exports.PlaybackControls = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _slider = __webpack_require__(154);

var _slider2 = _interopRequireDefault(_slider);

var _event = __webpack_require__(105);

var _state = __webpack_require__(50);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'PlaybackControls';

// Just to show the API contract

var _PlaybackControls = function () {
  function _PlaybackControls() {
    _classCallCheck(this, _PlaybackControls);
  }

  _createClass(_PlaybackControls, [{
    key: 'getVolume',
    value: function getVolume() {}
  }, {
    key: 'setVolume',
    value: function setVolume(value) {} // eslint-disable-line no-unused-vars

  }, {
    key: 'setSeekTime',
    value: function setSeekTime(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    } // eslint-disable-line no-unused-vars

  }, {
    key: 'setPlaybackDuration',
    value: function setPlaybackDuration(value) {} // eslint-disable-line no-unused-vars

  }, {
    key: 'getState',
    value: function getState() {}
  }, {
    key: 'setState',
    value: function setState(state) {} // eslint-disable-line no-unused-vars

  }, {
    key: 'setAsVOD',
    value: function setAsVOD(value) {} // eslint-disable-line no-unused-vars

  }]);

  return _PlaybackControls;
}();

var _PlaybackControlsImpl = function (_PlaybackControls2) {
  _inherits(_PlaybackControlsImpl, _PlaybackControls2);

  function _PlaybackControlsImpl(player, container) {
    _classCallCheck(this, _PlaybackControlsImpl);

    var _this = _possibleConstructorReturn(this, (_PlaybackControlsImpl.__proto__ || Object.getPrototypeOf(_PlaybackControlsImpl)).call(this));

    _this.player = player;
    _this.container = container;
    _this._playPauseButton = undefined;
    _this._muteButton = undefined;
    _this._volumeField = undefined;
    _this._seekTimeField = undefined;
    _this._timeField = undefined;
    _this._fullScreenButton = undefined;
    _this._state = _state.PlaybackState.IDLE;
    _this._mutedState = false;
    _this._resumeAfterSeek = false;
    _this._playbackDuration = 0;
    _this._volumeValue = 1;
    _this._onPlayPauseClickBound = _this._onPlayPauseClick.bind(_this);
    _this.decorate(_this.container);
    return _this;
  }

  _createClass(_PlaybackControlsImpl, [{
    key: 'decorate',
    value: function decorate(container) {
      (0, _log.debug)(NAME, '[decorate]');
      var controlbar = _browser2.default.createElement('div');
      controlbar.classList.add('red5pro-media-control-bar');
      this._playPauseButton = this._createPlayPauseButton();
      this._muteButton = this._createMuteButton();
      this._volumeField = this._createVolumeControl();
      this._seekTimeField = this._createSeekControl();
      this._timeField = this._createPlaybackTime();
      this._fullScreenButton = this._createFullScreenToggle();
      controlbar.appendChild(this._playPauseButton);
      controlbar.appendChild(this._timeField);
      controlbar.appendChild(this._seekTimeField.view);
      controlbar.appendChild(this._muteButton);
      controlbar.appendChild(this._volumeField.view);
      controlbar.appendChild(this._fullScreenButton);
      container.appendChild(controlbar);

      this.container.addEventListener('mouseover', function () {
        controlbar.classList.add('red5pro-media-control-bar-show');
      });
      this.container.addEventListener('mouseout', function () {
        controlbar.classList.remove('red5pro-media-control-bar-show');
      });

      this.setState(_state.PlaybackState.IDLE).onFullScreenChange(false).setSeekTime(0).enablePlayPause(false);
    }
  }, {
    key: '_onPlayPauseClick',
    value: function _onPlayPauseClick() {
      if (this.getState() === _state.PlaybackState.PLAYING) {
        this.player.pause();
      } else if (this.getState() === _state.PlaybackState.PAUSED) {
        this.player.resume();
      } else {
        this.player.play();
      }
    }
  }, {
    key: '_createPlayPauseButton',
    value: function _createPlayPauseButton() {
      var button = _browser2.default.createElement('button');
      button.setAttribute('aria-label', 'Toggle Playback');
      button.classList.add('red5pro-media-control-element');
      button.classList.add('red5pro-media-element-button');
      button.classList.add('red5pro-media-playpause-button');
      return button;
    }
  }, {
    key: '_createMuteButton',
    value: function _createMuteButton() {
      var self = this;
      var button = _browser2.default.createElement('button');
      button.setAttribute('aria-label', 'Toggle Mute Audio');
      button.classList.add('red5pro-media-control-element');
      button.classList.add('red5pro-media-element-button');
      button.classList.add('red5pro-media-muteunmute-button');
      button.addEventListener('click', function () {
        if (self.getMutedState()) {
          self.player.unmute();
          self.setMutedState(false);
        } else {
          self.player.mute();
          self.setMutedState(true);
        }
      });
      return button;
    }
  }, {
    key: '_createVolumeControl',
    value: function _createVolumeControl() {
      var self = this;
      var slider = new _slider2.default('volume');
      slider.view.classList.add('red5pro-media-control-element');
      slider.view.classList.add('red5pro-media-volume-slider');
      slider.view.classList.add('red5pro-media-slider');
      slider.on(_event.SliderEventTypes.CHANGE, function (event) {
        var percentage = Number(event.data);
        self.player.setVolume(percentage);
      });
      return slider;
    }
  }, {
    key: '_createSeekControl',
    value: function _createSeekControl() {
      var self = this;
      var slider = new _slider2.default('seek');
      slider.view.classList.add('red5pro-media-control-element');
      slider.view.classList.add('red5pro-media-seektime-slider');
      slider.view.classList.add('red5pro-media-slider');
      slider.on(_event.SliderEventTypes.CHANGE_START, function () {
        if (self.getState() === _state.PlaybackState.PLAYING) {
          self._resumeAfterSeek = true;
          self.player.pause();
        }
      });
      slider.on(_event.SliderEventTypes.CHANGE, function (event) {
        var percentage = Number(event.data);
        self.player.seekTo(percentage, self._playbackDuration === 0 ? undefined : self._playbackDuration);
        self.setSeekTime(percentage * self._playbackDuration, self._playbackDuration);
      });
      slider.on(_event.SliderEventTypes.CHANGE_COMPLETE, function () {
        if (self._resumeAfterSeek && self.getState() === _state.PlaybackState.PAUSED) {
          self._resumeAfterSeek = false;
          self.player.resume();
        }
      });
      return slider;
    }
  }, {
    key: '_createPlaybackTime',
    value: function _createPlaybackTime() {
      var span = _browser2.default.createElement('span');
      var text = _browser2.default.createElement('text', 'hello!');
      span.classList.add('red5pro-media-control-element');
      span.classList.add('red5pro-media-time-field');
      span.appendChild(text);
      return span;
    }
  }, {
    key: '_createFullScreenToggle',
    value: function _createFullScreenToggle() {
      var self = this;
      var button = _browser2.default.createElement('button');
      button.setAttribute('aria-label', 'Toggle Fullscreen');
      button.classList.add('red5pro-media-control-element');
      button.classList.add('red5pro-media-element-button');
      button.classList.add('red5pro-media-fullscreen-button');
      button.addEventListener('click', function () {
        self.player.toggleFullScreen();
      });
      return button;
    }
  }, {
    key: 'formatTime',
    value: function formatTime(value) {
      var hrs = 0;
      var mins = value === 0 ? 0 : parseInt(value / 60);
      var secs = 0;
      if (mins >= 60) {
        hrs = parseInt(mins / 60);
        mins = mins % 60;
      }
      secs = value === 0 ? 0 : parseInt(value % 60);

      var formattedArr = hrs < 10 ? ['0' + hrs] : [hrs];
      formattedArr.push(mins < 10 ? ['0' + mins] : [mins]);
      formattedArr.push(secs < 10 ? ['0' + secs] : [secs]);
      return formattedArr.join(':');
    }
  }, {
    key: 'getVolume',
    value: function getVolume() {
      return this._volumeValue;
    }
  }, {
    key: 'setVolume',
    value: function setVolume(value) {
      this._volumeField.value = value;
      this._volumeValue = value;
      if (value === 0) {
        this.setMutedState(true);
      } else if (this.getMutedState()) {
        this.setMutedState(false);
      }
      return this;
    }
  }, {
    key: 'setSeekTime',
    value: function setSeekTime(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      this._seekTimeField.value = length === 0 ? 0 : value / length;
      if (this._playbackDuration !== 0 && parseInt(this._playbackDuration) <= parseInt(value)) {
        this._seekTimeField.value = 1;
      }
      this._timeField.innerText = this.formatTime(Math.floor(value));
      return this;
    }
  }, {
    key: 'setPlaybackDuration',
    value: function setPlaybackDuration(value) {
      (0, _log.debug)(NAME, '[setplaybackduration]: ' + value);
      this._playbackDuration = value;
    }
  }, {
    key: 'enablePlayPause',
    value: function enablePlayPause(value) {
      if (value) {
        this._playPauseButton.classList.remove('red5pro-media-element-button-disabled');
        this._playPauseButton.addEventListener('click', this._onPlayPauseClickBound);
      } else {
        this._playPauseButton.classList.add('red5pro-media-element-button-disabled');
        this._playPauseButton.removeEventListener('click', this._onPlayPauseClickBound);
      }
    }
  }, {
    key: 'getState',
    value: function getState() {
      return this._state;
    }
  }, {
    key: 'setState',
    value: function setState(state) {
      (0, _log.debug)(NAME, '[setState]: ' + _state.PlaybackStateReadable[state]);
      this._state = state;
      this.onStateChange(this._state);
      return this;
    }
  }, {
    key: 'getMutedState',
    value: function getMutedState() {
      return 'muted' in this.player ? this.player.muted : this._mutedState;
    }
  }, {
    key: 'setMutedState',
    value: function setMutedState(state) {
      this._mutedState = state;
      this.onMutedStateChange(this._mutedState);
      return this;
    }
  }, {
    key: 'onStateChange',
    value: function onStateChange(state) {
      if (state === _state.PlaybackState.PLAYING) {
        this._playPauseButton.classList.remove('red5pro-media-play-button');
        this._playPauseButton.classList.add('red5pro-media-pause-button');
      } else {
        this._playPauseButton.classList.add('red5pro-media-play-button');
        this._playPauseButton.classList.remove('red5pro-media-pause-button');
      }
      return this;
    }
  }, {
    key: 'onMutedStateChange',
    value: function onMutedStateChange(state) {
      if (state) {
        this._muteButton.classList.add('red5pro-media-mute-button');
        this._muteButton.classList.remove('red5pro-media-unmute-button');
        this._volumeField.value = 0;
      } else {
        this._muteButton.classList.remove('red5pro-media-mute-button');
        this._muteButton.classList.add('red5pro-media-unmute-button');
        this._volumeField.value = this._volumeValue;
      }
    }
  }, {
    key: 'onFullScreenChange',
    value: function onFullScreenChange(isFullScreen) {
      if (isFullScreen) {
        this._fullScreenButton.classList.add('red5pro-media-exit-fullscreen-button');
        this._fullScreenButton.classList.remove('red5pro-media-fullscreen-button');
      } else {
        this._fullScreenButton.classList.remove('red5pro-media-exit-fullscreen-button');
        this._fullScreenButton.classList.add('red5pro-media-fullscreen-button');
      }
      return this;
    }
  }, {
    key: 'setAsVOD',
    value: function setAsVOD(isVOD) {
      (0, _log.debug)(NAME, '[setAsVOD]: ' + isVOD);
      if (!isVOD) {
        this._seekTimeField.value = 0;
        this._seekTimeField.disabled = true;
      } else {
        this._seekTimeField.disabled = false;
      }
    }
  }]);

  return _PlaybackControlsImpl;
}(_PlaybackControls);

var PlaybackControls = exports.PlaybackControls = _PlaybackControls;
var PlaybackControlsImpl = exports.PlaybackControlsImpl = _PlaybackControlsImpl;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlaybackView = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'R5ProPlaybackView';
var playbackId = 'red5pro-subscriber';

var PlaybackView = exports.PlaybackView = function () {
  function PlaybackView() {
    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : playbackId;

    _classCallCheck(this, PlaybackView);

    try {
      // Target video element.
      this._targetElement = _browser2.default.resolveElement(elementId);
    } catch (e) {
      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProSubscriber. Reason: ' + e.message);
      throw e;
    }
  }

  _createClass(PlaybackView, [{
    key: 'attachSubscriber',
    value: function attachSubscriber(subscriber) {
      (0, _log.debug)(NAME, '[attachsubscriber]');
      subscriber.setView(this, _browser2.default.getElementId(this._targetElement));
    }
  }, {
    key: 'attachStream',
    value: function attachStream(mediaStream) {
      var autoplay = this.isAutoplay;
      (0, _log.debug)(NAME, '[attachstream]');
      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
    }
  }, {
    key: 'stop',
    value: function stop() {
      (0, _log.debug)(NAME, '[stop]');
      try {
        this._targetElement.pause();
      } catch (e) {
        (0, _log.warn)(NAME, 'Could not stop video element: ' + e.message);
      }
    }
  }, {
    key: 'isAutoplay',
    get: function get() {
      return _browser2.default.hasAttributeDefined(this._targetElement, 'autoplay');
    }
  }, {
    key: 'view',
    get: function get() {
      return this._targetElement;
    }
  }]);

  return PlaybackView;
}();

exports.default = PlaybackView;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(18)
  , toLength  = __webpack_require__(11)
  , toIndex   = __webpack_require__(43);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global            = __webpack_require__(2)
  , $export           = __webpack_require__(0)
  , redefine          = __webpack_require__(16)
  , redefineAll       = __webpack_require__(41)
  , meta              = __webpack_require__(33)
  , forOf             = __webpack_require__(46)
  , anInstance        = __webpack_require__(36)
  , isObject          = __webpack_require__(4)
  , fails             = __webpack_require__(3)
  , $iterDetect       = __webpack_require__(63)
  , setToStringTag    = __webpack_require__(48)
  , inheritIfRequired = __webpack_require__(78);

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide     = __webpack_require__(15)
  , redefine = __webpack_require__(16)
  , fails    = __webpack_require__(3)
  , defined  = __webpack_require__(23)
  , wks      = __webpack_require__(6);

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};

/***/ }),
/* 61 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(4)
  , cof      = __webpack_require__(22)
  , MATCH    = __webpack_require__(6)('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR     = __webpack_require__(6)('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(37)|| !__webpack_require__(3)(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete __webpack_require__(2)[K];
});

/***/ }),
/* 65 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2)
  , hide   = __webpack_require__(15)
  , uid    = __webpack_require__(44)
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = exports.isSupported = undefined;

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isSupported = exports.isSupported = function isSupported() {
  return _browser2.default.supportsWebSocket();
};

var create = exports.create = function create(url) {
  return _browser2.default.createWebSocket(url);
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var PublishTypes = exports.PublishTypes = Object.freeze({
  RTMP: 'rtmp',
  RTC: 'rtc'
});

var PublishModeTypes = exports.PublishModeTypes = Object.freeze({
  LIVE: 'live',
  RECORD: 'record',
  APPEND: 'append'
});

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var common = exports.common = Object.freeze({
  CONNECT_SUCCESS: 'Connect.Success',
  CONNECT_FAILURE: 'Connect.Failure',
  PROPERTY_UPDATE: 'SharedObject.PropertyUpdate',
  METHOD_UPDATE: 'SharedObject.MethodUpdate'
});

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'R5ProPublishView';

var publisherId = 'red5pro-publisher';

var PublishView = function () {
  function PublishView() {
    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publisherId;

    _classCallCheck(this, PublishView);

    try {
      this._targetElement = _browser2.default.resolveElement(elementId);
    } catch (e) {
      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProPublisher. Reason: ' + e.message);
      throw e;
    }
  }

  _createClass(PublishView, [{
    key: 'attachPublisher',
    value: function attachPublisher(publisher) {
      (0, _log.debug)(NAME, '[attachpublisher]');
      publisher.setView(this, _browser2.default.getElementId(this._targetElement));
    }
  }, {
    key: 'preview',
    value: function preview(mediaStream) {
      var autoplay = this.isAutoplay;
      (0, _log.debug)(NAME, '[preview]: autoplay(' + autoplay + ')');
      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
    }
  }, {
    key: 'isAutoplay',
    get: function get() {
      return _browser2.default.hasAttributeDefined(this._targetElement, 'autoplay');
    }
  }, {
    key: 'view',
    get: function get() {
      return this._targetElement;
    }
  }]);

  return PublishView;
}();

exports.default = PublishView;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(12)
  , toIndex  = __webpack_require__(43)
  , toLength = __webpack_require__(11);
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(8)
  , createDesc      = __webpack_require__(34);

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4)
  , document = __webpack_require__(2).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 75 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(6)('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2).document && document.documentElement;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var isObject       = __webpack_require__(4)
  , setPrototypeOf = __webpack_require__(86).set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators  = __webpack_require__(47)
  , ITERATOR   = __webpack_require__(6)('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(22);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(38)
  , descriptor     = __webpack_require__(34)
  , setToStringTag = __webpack_require__(48)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(15)(IteratorPrototype, __webpack_require__(6)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(37)
  , $export        = __webpack_require__(0)
  , redefine       = __webpack_require__(16)
  , hide           = __webpack_require__(15)
  , has            = __webpack_require__(13)
  , Iterators      = __webpack_require__(47)
  , $iterCreate    = __webpack_require__(81)
  , setToStringTag = __webpack_require__(48)
  , getPrototypeOf = __webpack_require__(21)
  , ITERATOR       = __webpack_require__(6)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 83 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),
/* 84 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(2)
  , macrotask = __webpack_require__(93).set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = __webpack_require__(22)(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(4)
  , anObject = __webpack_require__(1);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(30)(Function.call, __webpack_require__(20).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(66)('keys')
  , uid    = __webpack_require__(44);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = __webpack_require__(1)
  , aFunction = __webpack_require__(14)
  , SPECIES   = __webpack_require__(6)('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(35)
  , defined   = __webpack_require__(23);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(62)
  , defined  = __webpack_require__(23);

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(35)
  , defined   = __webpack_require__(23);

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var ctx                = __webpack_require__(30)
  , invoke             = __webpack_require__(61)
  , html               = __webpack_require__(77)
  , cel                = __webpack_require__(74)
  , global             = __webpack_require__(2)
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(__webpack_require__(22)(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global         = __webpack_require__(2)
  , DESCRIPTORS    = __webpack_require__(7)
  , LIBRARY        = __webpack_require__(37)
  , $typed         = __webpack_require__(67)
  , hide           = __webpack_require__(15)
  , redefineAll    = __webpack_require__(41)
  , fails          = __webpack_require__(3)
  , anInstance     = __webpack_require__(36)
  , toInteger      = __webpack_require__(35)
  , toLength       = __webpack_require__(11)
  , gOPN           = __webpack_require__(39).f
  , dP             = __webpack_require__(8).f
  , arrayFill      = __webpack_require__(72)
  , setToStringTag = __webpack_require__(48)
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(2)
  , core           = __webpack_require__(29)
  , LIBRARY        = __webpack_require__(37)
  , wksExt         = __webpack_require__(134)
  , defineProperty = __webpack_require__(8).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(51)
  , ITERATOR  = __webpack_require__(6)('iterator')
  , Iterators = __webpack_require__(47);
module.exports = __webpack_require__(29).getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(45)
  , step             = __webpack_require__(122)
  , Iterators        = __webpack_require__(47)
  , toIObject        = __webpack_require__(18);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(82)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var PlaybackTypes = exports.PlaybackTypes = Object.freeze({
  RTC: 'rtc',
  RTMP: 'rtmp',
  HLS: 'hls'
});

var PlaybackAudioEncoder = exports.PlaybackAudioEncoder = Object.freeze({
  OPUS: 'Opus',
  PCMU: 'PCMU',
  PCMA: 'PCMA',
  SPEEX: 'Speex',
  NONE: 'NONE'
});

var PlaybackVideoEncoder = exports.PlaybackVideoEncoder = Object.freeze({
  VP8: 'VP8',
  H264: 'H264',
  NONE: 'NONE'
});

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedSwfObject = exports.defineEmbedElement = undefined;

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _promise = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defineEmbedElement = exports.defineEmbedElement = function defineEmbedElement(targetElement, targetParent) {
  var dfd = new _promise.DeferredPromise();
  var elementId = targetElement.id;
  if (targetElement.nodeName.toLowerCase() === 'video') {
    var div = _browser2.default.createElement('div');
    div.id = elementId + '_rtmp';
    targetParent.appendChild(div);
    if (targetElement.parentElement) {
      targetElement.parentElement.removeChild(targetElement);
    }
    dfd.resolve(div.id);
  } else {
    dfd.resolve(elementId);
  }
  return dfd.promise;
};

var embedSwfObject = exports.embedSwfObject = function embedSwfObject(idName, options, flashvars, swfobject, elementId) {
  var dfd = new _promise.DeferredPromise();
  var params = {
    quality: 'high',
    wmode: 'opaque',
    bgcolor: options.backgroundColor || '#000',
    allowscriptaccess: 'always',
    allowfullscreen: 'true',
    allownetworking: 'all'
  };
  var attributes = {
    id: idName,
    name: idName,
    align: 'middle'
  };
  if (swfobject.hasFlashPlayerVersion(options.minFlashVersion)) {
    swfobject.embedSWF(options.swf, elementId, options.embedWidth || 640, options.embedHeight || 480, options.minFlashVersion, options.productInstallURL, flashvars, params, attributes, dfd.resolve);
  } else {
    dfd.reject('Flash Player Version is not supported.');
  }
  return dfd.promise;
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var common = exports.common = Object.freeze({
  CONNECT_SUCCESS: 'Connect.Success',
  CONNECT_FAILURE: 'Connect.Failure',
  PUBLISH_START: 'Publish.Start',
  PUBLISH_FAIL: 'Publish.Fail',
  PUBLISH_INVALID_NAME: 'Publish.InvalidName',
  UNPUBLISH_SUCCESS: 'Unpublish.Success',
  PUBLISH_METADATA: 'Publish.Metadata',
  CONNECTION_CLOSED: 'Publisher.Connection.Closed',
  DIMENSION_CHANGE: 'Publisher.Video.DimensionChange'
});

var failover = exports.failover = Object.freeze({
  PUBLISHER_REJECT: 'Publisher.Reject',
  PUBLISHER_ACCEPT: 'Publisher.Accept'
});

var rtc = exports.rtc = Object.freeze({
  MEDIA_STREAM_AVAILABLE: 'WebRTC.MediaStream.Available',
  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
  OFFER_START: 'WebRTC.Offer.Start',
  OFFER_END: 'WebRTC.Offer.End',
  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
});

var rtmp = exports.rtmp = Object.freeze({
  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
});

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var common = exports.common = Object.freeze({
  CONNECT_SUCCESS: 'Connect.Success',
  CONNECT_FAILURE: 'Connect.Failure',
  SUBSCRIBE_START: 'Subscribe.Start',
  SUBSCRIBE_STOP: 'Subscribe.Stop',
  SUBSCRIBE_FAIL: 'Subscribe.Fail',
  SUBSCRIBE_INVALID_NAME: 'Subscribe.InvalidName',
  SUBSCRIBE_METADATA: 'Subscribe.Metadata',
  SUBSCRIBE_SEND_INVOKE: 'Subscribe.Send.Invoke',
  PLAY_UNPUBLISH: 'Subscribe.Play.Unpublish',
  CONNECTION_CLOSED: 'Subscribe.Connection.Closed',
  ORIENTATION_CHANGE: 'Subscribe.Orientation.Change',
  VOLUME_CHANGE: 'Subscribe.Volume.Change',
  PLAYBACK_TIME_UPDATE: 'Subscribe.Time.Update',
  PLAYBACK_STATE_CHANGE: 'Subscribe.Playback.Change',
  FULL_SCREEN_STATE_CHANGE: 'Subscribe.FullScreen.Change'
});

var failover = exports.failover = Object.freeze({
  SUBSCRIBER_REJECT: 'Subscriber.Reject',
  SUBSCRIBER_ACCEPT: 'Subscriber.Accept'
});

var rtc = exports.rtc = Object.freeze({
  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
  OFFER_START: 'WebRTC.Offer.Start',
  OFFER_END: 'WebRTC.Offer.End',
  ANSWER_START: 'WebRTC.Answer.Start',
  ANSWER_END: 'WebRTC.Answer.End',
  CANDIDATE_START: 'WebRTC.Candidate.Start',
  CANDIDATE_END: 'WebRTC.Candidate.End',
  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
});

var rtmp = exports.rtmp = Object.freeze({
  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
});

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'R5ProRTMPSharedObjectHandler';

var RTMPSharedObjectHandler = function () {
  function RTMPSharedObjectHandler() {
    _classCallCheck(this, RTMPSharedObjectHandler);

    this._element = undefined;
    this._responseHandlers = [];
  }

  _createClass(RTMPSharedObjectHandler, [{
    key: 'addResponseHandler',
    value: function addResponseHandler(handler) {
      this._responseHandlers.push(handler);
    }
  }, {
    key: 'removeResponseHandler',
    value: function removeResponseHandler(handler) {
      var i = this._responseHandlers.length;
      var rHandler = void 0;
      while (--i > -1) {
        rHandler = this._responseHandlers[i];
        if (rHandler === handler) {
          this._responseHandlers.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: 'handleSharedObjectEvent',
    value: function handleSharedObjectEvent(event) {
      (0, _log.debug)(NAME, '[sharedobject:event]');
      var i = void 0;
      var length = this._responseHandlers.length;
      var handler = void 0;
      for (i = 0; i < length; i++) {
        handler = this._responseHandlers[i];
        if (handler.respond(JSON.parse(event))) {
          break;
        }
      }
    }
  }, {
    key: 'assignSharedObjectResponder',
    value: function assignSharedObjectResponder(name, el) {
      var _handleSharedObjectEvent = this.handleSharedObjectEvent.bind(this);
      var elId = el.id.split('-').join('_');
      var handlerName = ['handleSharedObjectEvent', elId].join('_');
      (0, _log.debug)(NAME, '[assign:sharedobject:responder] :: ' + elId);
      (0, _log.debug)(NAME, '[sharedoject:responder] :: ' + handlerName);
      el.setSharedObjectResponder(name, handlerName);
      _browser2.default.setGlobal(handlerName, _handleSharedObjectEvent);
    }
  }, {
    key: 'connect',
    value: function connect(swfId) {
      this._element = _browser2.default.getEmbedObject(swfId);
      if (!this._element) {
        (0, _log.warn)('Could not locate embedded Flash object for id: ' + swfId);
      }
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      while (this._responseHandlers.length > 0) {
        this._responseHandlers.shift();
      }
    }
  }, {
    key: 'sendToSharedObject',
    value: function sendToSharedObject(name, callName, message) {
      (0, _log.debug)(NAME, '[sendToSharedObject]');
      try {
        this._element.sharedObjectSend(name, callName, typeof message === 'string' ? message : JSON.stringify(message));
      } catch (e) {
        (0, _log.warn)('Could not send to shared object (' + name + '). Error: ' + e.message);
      }
    }
  }, {
    key: 'sendPropertyToSharedObject',
    value: function sendPropertyToSharedObject(name, key, value) {
      (0, _log.debug)(NAME, '[sendPropertyToSharedObject]');
      try {
        this._element.sharedObjectSendProperty(name, key, value);
      } catch (e) {
        (0, _log.warn)('Could not send to shared object (' + name + '). Error: ' + e.message);
      }
    }
  }, {
    key: 'getRemoteSharedObject',
    value: function getRemoteSharedObject(sharedObjectName) {
      (0, _log.debug)(NAME, '[getRemoteSharedObject]');
      try {
        this.assignSharedObjectResponder(sharedObjectName, this._element);
        this._element.getRemoteSharedObject(sharedObjectName);
      } catch (e) {
        (0, _log.warn)('Could not get remote shared object (' + name + '). Error: ' + e.message);
      }
    }
  }, {
    key: 'connectToSharedObject',
    value: function connectToSharedObject(sharedObjectName) {
      (0, _log.debug)(NAME, '[connectToSharedObject]');
      try {
        this._element.connectToSharedObject(sharedObjectName);
      } catch (e) {
        (0, _log.warn)('Could not connect to shared object (' + name + '). Error: ' + e.message);
      }
    }
  }, {
    key: 'closeSharedObject',
    value: function closeSharedObject(sharedObjectName) {
      (0, _log.debug)(NAME, '[disconnectToSharedObject]');
      try {
        this._element.disconnectFromSharedObject(sharedObjectName);
      } catch (e) {
        (0, _log.warn)('Could not disconnect to shared object (' + name + '). Error: ' + e.message);
      }
    }
  }]);

  return RTMPSharedObjectHandler;
}();

exports.default = RTMPSharedObjectHandler;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _websocket = __webpack_require__(68);

var websocket = _interopRequireWildcard(_websocket);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SocketHelper = function () {
  function SocketHelper(responder, name) {
    _classCallCheck(this, SocketHelper);

    this._responder = responder;
    this._pendingPostRequests = [];
    this._websocket = undefined;
    this._connectionPromise = undefined;
    this._name = name;
    this._responseHandlers = [];
    this._isTerminated = false;
    this._onclose = this.tearDown.bind(this);
  }

  _createClass(SocketHelper, [{
    key: '_removeSocketHandlers',
    value: function _removeSocketHandlers(ws) {
      ws.onopen = undefined;
      ws.onmessage = undefined;
      ws.onerror = undefined;
      ws.onclose = undefined;
    }
  }, {
    key: '_addSocketHandlers',
    value: function _addSocketHandlers(ws, promise) {
      var _this = this;

      ws.onopen = function () {
        (0, _log.info)(_this._name, '[websocketopen]');
        while (_this._pendingPostRequests.length > 0) {
          _this.post(_this._pendingPostRequests.shift());
        }
      };

      ws.onerror = function (error) {
        _this.tearDown();
        (0, _log.warn)(_this._name, '[websocketerror]: Error from WebSocket. ' + error.type);
        promise.reject(error);
      };

      ws.onmessage = function (message) {
        _this.respond(message);
      };

      ws.onclose = function (event) {
        (0, _log.warn)(_this._name, '[websocketclose]: ' + event.code);
        if (_this._responder) {
          _this._responder.onSocketClose(event);
        }
        _this.tearDown();
      };
    }
  }, {
    key: 'onUnexpectedSocketError',
    value: function onUnexpectedSocketError(error) {
      if (this._responder) {
        this._responder.onSocketClose(error);
      }
      (0, _log.warn)(this._name, '[websocketerror]: Unexpected Error from WebSocket. ' + error.type + ', ' + error.detail);
      this.tearDown();
    }
  }, {
    key: 'setUp',
    value: function setUp(url, setupPromise) {
      this.tearDown();
      this._isTerminated = false;
      this._connectionPromise = setupPromise;
      _browser2.default.addCloseHandler(this._onclose);
      this._websocket = websocket.create(url);
      this._addSocketHandlers(this._websocket, this._connectionPromise);
    }
  }, {
    key: 'tearDown',
    value: function tearDown() {
      this._pendingPostRequests.length = 0;
      if (typeof this._websocket !== 'undefined') {
        this._removeSocketHandlers(this._websocket);
        this._websocket.close();
      }
      this._websocket = undefined;
      this._isTerminated = true;
      while (this._responseHandlers.length > 0) {
        this._responseHandlers.shift();
      }
      _browser2.default.removeCloseHandler(this._onclose);
    }
  }, {
    key: 'getJsonFromSocketMessage',
    value: function getJsonFromSocketMessage(message) {
      try {
        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
      } catch (e) {
        (0, _log.warn)(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
      }
      return null;
    }
  }, {
    key: 'addSharedObjectResponseHandler',
    value: function addSharedObjectResponseHandler(handler) {
      this._responseHandlers.push(handler);
    }
  }, {
    key: 'removeSharedObjectResponseHandler',
    value: function removeSharedObjectResponseHandler(handler) {
      var i = this._responseHandlers.length;
      var rHandler = void 0;
      while (--i > -1) {
        rHandler = this._responseHandlers[i];
        if (rHandler === handler) {
          this._responseHandlers.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: 'handleMessageResponse',
    value: function handleMessageResponse(message) {
      var i = void 0,
          handler = void 0;
      var length = this._responseHandlers.length;
      for (i = 0; i < length; i++) {
        handler = this._responseHandlers[i];
        if (handler.respond(message)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'post',
    value: function post(sendRequest) {
      if (this._websocket !== undefined && this._websocket.readyState === 1 /* WebSocket.OPEN */) {
          try {
            (0, _log.debug)(this._name, '[websocket-post]: ' + JSON.stringify(sendRequest, null, 2));
            this._websocket.send(JSON.stringify(sendRequest));
            return true;
          } catch (e) {
            (0, _log.debug)(this._name, 'Could not send request: ' + sendRequest + '. ' + e);
            return false;
          }
        } else if (this._websocket !== undefined && (this._websocket.readyState === 2 || this._websocket.readyState === 3)) /* WebSocket.(CLOSING | CLOSED) */{
          return false;
        } else if (this._isTerminated) {
        return false;
      } else {
        this._pendingPostRequests.push(sendRequest);
        return true;
      }
    }
  }, {
    key: 'respond',
    value: function respond(message) {
      // eslint-disable-line no-unused-vars
      var handled = this.handleMessageResponse(message);
      if (!handled && message.data) {
        var json = this.getJsonFromSocketMessage(message);
        if (json === null) {
          (0, _log.warn)(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
          return true;
        }
        (0, _log.debug)(this._name, '[websocket-response]: ' + JSON.stringify(json, null, 2));
        if (json.isAvailable !== undefined) {
          if (typeof json.isAvailable === 'boolean' && json.isAvailable) {
            this._responder.onStreamAvailable(json);
            return true;
          } else {
            this._responder.onStreamUnavailable(json);
            return true;
          }
        } else if (json.data !== undefined) {
          if (json.data.message !== undefined) {
            if (json.data.type === 'error') {
              this._responder.onSocketMessageError(json.data.message, json.data.detail);
              return true;
            }
          } else if (json.data.type === 'status') {
            if (json.data.code === 'NetConnection.Connect.Success') {
              this._websocket.onerror = this.onUnexpectedSocketError.bind(this);
              this._connectionPromise.resolve();
              return true;
            } else if (json.data.code === 'NetConnection.Connect.Rejected') {
              this._connectionPromise.reject('NetConnection.Connect.Rejected');
              return true;
            }
          } else if (json.data.type === 'error') {
            if (json.data.code === 'NetConnection.Connect.Rejected') {
              this._connectionPromise.reject('NetConnection.Connect.Rejected');
              return true;
            }
          }
        }
      }
      return handled;
    }
  }, {
    key: 'getRemoteSharedObject',
    value: function getRemoteSharedObject(name) {
      this.post({
        sharedObjectGetRemote: {
          name: name
        }
      });
    }
  }, {
    key: 'connectToSharedObject',
    value: function connectToSharedObject(name) {
      this.post({
        sharedObjectConnect: {
          name: name
        }
      });
    }
  }, {
    key: 'sendToSharedObject',
    value: function sendToSharedObject(name, callName, data) {
      this.post({
        sharedObjectSend: {
          name: name,
          call: callName,
          params: [data]
        }
      });
    }
  }, {
    key: 'sendPropertyToSharedObject',
    value: function sendPropertyToSharedObject(name, key, value) {
      this.post({
        sharedObjectSetProperty: {
          name: name,
          key: key,
          value: value
        }
      });
    }
  }, {
    key: 'closeSharedObject',
    value: function closeSharedObject(name) {
      this.post({
        sharedObjectClose: {
          name: name
        }
      });
    }
  }]);

  return SocketHelper;
}();

exports.default = SocketHelper;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var inflate = function inflate(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value: value,
    writable: true,
    enumerable: true
  });
};

var RTCMediaVideoConstraint = function RTCMediaVideoConstraint() {
  _classCallCheck(this, RTCMediaVideoConstraint);

  inflate(this, 'width', {
    exact: 640
  });
  inflate(this, 'height', {
    exact: 480
  });
};

var RTMPMediaVideoConstraint = function RTMPMediaVideoConstraint() {
  _classCallCheck(this, RTMPMediaVideoConstraint);

  inflate(this, 'width', 640);
  inflate(this, 'height', 480);
  inflate(this, 'force', false);
  inflate(this, 'framerate', 15);
  inflate(this, 'bandwidth', 50000);
  inflate(this, 'quality', 80);
  inflate(this, 'profile', 'baseline');
  inflate(this, 'level', 3.1);
};

var RTCMediaConstraint = function RTCMediaConstraint() {
  var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  _classCallCheck(this, RTCMediaConstraint);

  inflate(this, 'audio', audio);
  inflate(this, 'video', video || new RTCMediaVideoConstraint());
};

var RTMPMediaConstraint = function RTMPMediaConstraint() {
  var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  _classCallCheck(this, RTMPMediaConstraint);

  inflate(this, 'audio', audio);
  inflate(this, 'video', video || new RTMPMediaVideoConstraint());
};

exports.RTCMediaConstraint = RTCMediaConstraint;
exports.RTMPMediaConstraint = RTMPMediaConstraint;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderEventTypes = exports.SliderEvent = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _event = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SliderEvent = function (_Event) {
  _inherits(SliderEvent, _Event);

  function SliderEvent(type, control, data) {
    _classCallCheck(this, SliderEvent);

    var _this = _possibleConstructorReturn(this, (SliderEvent.__proto__ || Object.getPrototypeOf(SliderEvent)).call(this, type, data));

    _this._control = control;
    return _this;
  }

  _createClass(SliderEvent, [{
    key: 'control',
    get: function get() {
      return this._control;
    }
  }]);

  return SliderEvent;
}(_event.Event);

var SliderEventTypes = Object.freeze({
  CHANGE_START: 'changestart',
  CHANGE: 'change',
  CHANGE_COMPLETE: 'changecomplete'
});

exports.SliderEvent = SliderEvent;
exports.SliderEventTypes = SliderEventTypes;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImplFactoryOrder = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _promise = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var map = new WeakMap();

var pvt = function pvt(ctx) {
  if (!map.has(ctx)) {
    map.set(ctx, {});
  }

  return map.get(ctx);
};

var ImplFactoryOrder = exports.ImplFactoryOrder = function () {
  function ImplFactoryOrder() {
    var _this = this;

    _classCallCheck(this, ImplFactoryOrder);

    this.listorder = function () {
      return regeneratorRuntime.mark(function listorder(list) {
        return regeneratorRuntime.wrap(function listorder$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(list.length > 0)) {
                  _context.next = 5;
                  break;
                }

                _context.next = 3;
                return list.shift();

              case 3:
                _context.next = 0;
                break;

              case 5:
              case 'end':
                return _context.stop();
            }
          }
        }, listorder, this);
      });
    }();

    pvt(this).find = function (iterator, map, options, promise) {
      var initFn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var lastError = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

      var _pvt$next = pvt(_this).next(iterator, map),
          _pvt$next2 = _slicedToArray(_pvt$next, 2),
          type = _pvt$next2[0],
          Impl = _pvt$next2[1];

      if (!Impl) {
        promise.reject(lastError);
      } else {
        var p = void 0;
        var src = options[type];
        src = src || options;
        if (initFn) {
          p = new Impl()[initFn](src);
        } else {
          p = new Impl(src);
        }
        p.then(function (concrete) {
          promise.resolve(concrete);
        }).catch(function (error) {
          // eslint-disable-line no-unused-vars
          lastError = error;
          pvt(_this).find(iterator, map, options, promise, initFn, lastError);
        });
      }
    };

    pvt(this).next = function (order, map) {
      var Impl = void 0;
      var key = void 0;
      var next = order.next();
      if (!next.done) {
        key = next.value;
        Impl = map.get(key);
      }
      return [key, Impl];
    };
  }

  _createClass(ImplFactoryOrder, [{
    key: 'create',
    value: function create(order, map, options) {
      var initFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var promise = new _promise.DeferredPromise();
      pvt(this).find(this.listorder(order.slice()), map, options, promise, initFn);
      return promise.promise;
    }
  }]);

  return ImplFactoryOrder;
}();

exports.default = ImplFactoryOrder;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://blog.carbonfive.com/2015/01/14/gettin-freaky-functional-wcurried-javascript/

Object.defineProperty(exports, "__esModule", {
  value: true
});
var curry = exports.curry = function curry(fx) {
  var arity = fx.length;
  return function f1() {
    var args = Array.prototype.slice.call(arguments, 0);
    if (args.length >= arity) {
      return fx.apply(null, args);
    } else {
      return function f2() {
        var args2 = Array.prototype.slice.call(arguments, 0);
        return f1.apply(null, args.concat(args2));
      };
    }
  };
};

var filter = exports.filter = curry(function (fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
});

var toInt = exports.toInt = function toInt(value) {
  if (typeof value === 'string') {
    return value.parseInt(10);
  } else {
    return Math.round(value);
  }
};

var getOrElse = exports.getOrElse = function getOrElse(value, defaultValue) {
  return value || defaultValue;
};

var getIntOrElse = exports.getIntOrElse = function getIntOrElse(value, defaultValue) {
  return !isNaN(toInt(value)) ? toInt(value) : defaultValue;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Modifies target `object` in place with a namespaced value.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var deepDefine = exports.deepDefine = function deepDefine(object, paths, value) {
  var i = 0;
  var tail = object;
  var prop = paths.pop();
  var length = paths.length;
  for (i; i < length; i++) {
    var path = paths[i];
    tail[path] = tail[path] || {};
    tail = tail[path];
  }
  tail[prop] = value;
};

var deepCopy = exports.deepCopy = function deepCopy(obj) {
  var str = JSON.stringify(obj);
  return JSON.parse(str);
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var rtcSocketEndpointFromOptions = exports.rtcSocketEndpointFromOptions = function rtcSocketEndpointFromOptions(options) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  var protocol = options.wsprotocol || options.protocol;
  var port = options.wsport || options.port;
  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
  var endpoint = protocol + '://' + options.host + ':' + port + '/' + appEndpoint;
  if (typeof options.connectionParams !== 'undefined') {
    params = _extends(params, options.connectionParams);
  }
  if (typeof params !== 'undefined') {
    var kv = [];
    Object.keys(params).forEach(function (key, index) {
      // eslint-disable-line no-unused-vars
      kv.push([key, params[key]].join('='));
    });
    if (kv.length > 0) {
      endpoint += '?' + kv.join('&');
    }
  }

  return endpoint;
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * !This is a stripped down version of Bunyan targeted specifically for the browser
 *
 * -------------------------------------------------------------------------------
 *
 * Copyright (c) 2014 Trent Mick. All rights reserved.
 * Copyright (c) 2014 Joyent Inc. All rights reserved.
 *
 * The bunyan logging library for node.js.
 *
 * -*- mode: js -*-
 * vim: expandtab:ts=4:sw=4
 */



var VERSION = '0.2.3';

// Bunyan log format version. This becomes the 'v' field on all log records.
// `0` is until I release a version '1.0.0' of node-bunyan. Thereafter,
// starting with `1`, this will be incremented if there is any backward
// incompatible change to the log record format. Details will be in
// 'CHANGES.md' (the change log).
var LOG_VERSION = 0;

//---- Internal support stuff

/**
 * A shallow copy of an object. Bunyan logging attempts to never cause
 * exceptions, so this function attempts to handle non-objects gracefully.
 */
function objCopy(obj) {
    if (typeof obj === 'undefined' || obj === null) {  // null or undefined
        return obj;
    } else if (Array.isArray(obj)) {
        return obj.slice();
    } else if (typeof (obj) === 'object') {
        var copy = {};
        Object.keys(obj).forEach(function (k) {
            copy[k] = obj[k];
        });
        return copy;
    } else {
        return obj;
    }
}

var format = function(f) {

    if(f === null) {
        return 'null';
    }

    if(typeof f !== 'string') {
        return f.toString();
    }
    var formatRegExp = /%[sdj%]/g;

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') {
            return '%';
        }
        if (i >= len) {
            return x;
        }
        switch (x) {
            case '%s': return String(args[i++]);
            case '%d': return Number(args[i++]);
            case '%j':
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return '[Circular]';
                }
                break;
            default:
                return x;
        }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
        str += ' ' + x;
    }
    return str;
};

/**
 * Gather some caller info 3 stack levels up.
 * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.
 */
function getCaller3Info() {
    var obj = {};
    var saveLimit = Error.stackTraceLimit;
    var savePrepare = Error.prepareStackTrace;
    Error.stackTraceLimit = 3;
    //Error.captureStackTrace(this, getCaller3Info);

    Error.prepareStackTrace = function (_, stack) {
        var caller = stack[2];
        obj.file = caller.getFileName();
        obj.line = caller.getLineNumber();
        var func = caller.getFunctionName();
        if (func) {
            obj.func = func;
        }
    };
    Error.stackTraceLimit = saveLimit;
    Error.prepareStackTrace = savePrepare;
    return obj;
}


function _indent(s, indent) {
    if (!indent) {
        indent = '    ';
    }
    var lines = s.split(/\r?\n/g);
    return indent + lines.join('\n' + indent);
}


/**
 * Warn about an bunyan processing error.
 *
 * @param msg {String} Message with which to warn.
 * @param dedupKey {String} Optional. A short string key for this warning to
 *      have its warning only printed once.
 */
function _warn(msg, dedupKey) {
    if (dedupKey) {
        if (_warned[dedupKey]) {
            return;
        }
        _warned[dedupKey] = true;
    }
    console.error(msg + '\n');
}
function _haveWarned(dedupKey) {
    return _warned[dedupKey];
}
var _warned = {};


function ConsoleRawStream() {
}
ConsoleRawStream.prototype.write = function (rec) {
    if (rec.level < INFO) {
        console.log(rec);
    } else if (rec.level < WARN) {
        console.info(rec);
    } else if (rec.level < ERROR) {
        console.warn(rec);
    } else {
        console.error(rec);
    }

    if(rec.err && rec.err.stack) {
        console.error(rec.err.stack);
    }
};

function ConsoleFormattedStream() {}
ConsoleFormattedStream.prototype.write = function (rec) {

    var levelCss, defaultCss = 'color: DimGray', msgCss = 'color: SteelBlue';

    if (rec.level < DEBUG) {
        levelCss = 'color: DeepPink';
    } else if (rec.level < INFO) {
        levelCss = 'color: GoldenRod';
    } else if (rec.level < WARN) {
        levelCss = 'color: DarkTurquoise';
    } else if (rec.level < ERROR) {
        levelCss = 'color: Purple';
    } else if (rec.level < FATAL) {
        levelCss = 'color: Crimson';
    } else {
        levelCss = 'color: Black';
    }

    var loggerName = rec.childName ? rec.name + '/' + rec.childName : rec.name;

    //get level name and pad start with spacs
    var levelName = nameFromLevel[rec.level].toUpperCase();
    levelName = Array(6 - levelName.length).join(' ') + levelName;

    function padZeros(number, len) {
        return Array((len + 1) - (number + '').length).join('0') + number;
    }

    console.log('[%s:%s:%s:%s] %c%s%c: %s: %c%s',
        padZeros(rec.time.getHours(), 2), padZeros(rec.time.getMinutes(), 2),
        padZeros(rec.time.getSeconds(), 2), padZeros(rec.time.getMilliseconds(), 4),
        levelCss, levelName,
        defaultCss, loggerName,
        msgCss, rec.msg);
    if(rec.err && rec.err.stack) {
        console.log('%c%s,', levelCss, rec.err.stack);
    }
};

//---- Levels

var TRACE = 10;
var DEBUG = 20;
var INFO = 30;
var WARN = 40;
var ERROR = 50;
var FATAL = 60;

var levelFromName = {
    'trace': TRACE,
    'debug': DEBUG,
    'info': INFO,
    'warn': WARN,
    'error': ERROR,
    'fatal': FATAL
};
var nameFromLevel = {};
Object.keys(levelFromName).forEach(function (name) {
    nameFromLevel[levelFromName[name]] = name;
});


/**
 * Resolve a level number, name (upper or lowercase) to a level number value.
 *
 * @api public
 */
function resolveLevel(nameOrNum) {
    var level = (typeof (nameOrNum) === 'string' ? levelFromName[nameOrNum.toLowerCase()] : nameOrNum);
    return level;
}


//---- Logger class

/**
 * Create a Logger instance.
 *
 * @param options {Object} See documentation for full details. At minimum
 *    this must include a 'name' string key. Configuration keys:
 *      - `streams`: specify the logger output streams. This is an array of
 *        objects with these fields:
 *          - `type`: The stream type. See README.md for full details.
 *            Often this is implied by the other fields. Examples are
 *            'file', 'stream' and "raw".
 *          - `level`: Defaults to 'info'.
 *          - `path` or `stream`: The specify the file path or writeable
 *            stream to which log records are written. E.g.
 *            `stream: process.stdout`.
 *          - `closeOnExit` (boolean): Optional. Default is true for a
 *            'file' stream when `path` is given, false otherwise.
 *        See README.md for full details.
 *      - `level`: set the level for a single output stream (cannot be used
 *        with `streams`)
 *      - `stream`: the output stream for a logger with just one, e.g.
 *        `process.stdout` (cannot be used with `streams`)
 *      - `serializers`: object mapping log record field names to
 *        serializing functions. See README.md for details.
 *      - `src`: Boolean (default false). Set true to enable 'src' automatic
 *        field with log call source info.
 *    All other keys are log record fields.
 *
 * An alternative *internal* call signature is used for creating a child:
 *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);
 *
 * @param _childSimple (Boolean) An assertion that the given `_childOptions`
 *    (a) only add fields (no config) and (b) no serialization handling is
 *    required for them. IOW, this is a fast path for frequent child
 *    creation.
 */
function Logger(options, _childOptions, _childSimple) {
    if (!(this instanceof Logger)) {
        return new Logger(options, _childOptions);
    }

    // Input arg validation.
    var parent;
    if (_childOptions !== undefined) {
        parent = options;
        options = _childOptions;
        if (!(parent instanceof Logger)) {
            throw new TypeError(
                'invalid Logger creation: do not pass a second arg');
        }
    }
    if (!options) {
        throw new TypeError('options (object) is required');
    }
    if (!parent) {
        if (!options.name) {
            throw new TypeError('options.name (string) is required');
        }
    } else {
        if (options.name) {
            throw new TypeError(
                'invalid options.name: child cannot set logger name');
        }
    }
    if (options.stream && options.streams) {
        throw new TypeError('cannot mix "streams" and "stream" options');
    }
    if (options.streams && !Array.isArray(options.streams)) {
        throw new TypeError('invalid options.streams: must be an array');
    }
    if (options.serializers && (typeof (options.serializers) !== 'object' || Array.isArray(options.serializers))) {
        throw new TypeError('invalid options.serializers: must be an object');
    }

    var fields, name, i;

    // Fast path for simple child creation.
    if (parent && _childSimple) {
        // `_isSimpleChild` is a signal to stream close handling that this child
        // owns none of its streams.
        this._isSimpleChild = true;

        this._level = parent._level;
        this.streams = parent.streams;
        this.serializers = parent.serializers;
        this.src = parent.src;
        fields = this.fields = {};
        var parentFieldNames = Object.keys(parent.fields);
        for (i = 0; i < parentFieldNames.length; i++) {
            name = parentFieldNames[i];
            fields[name] = parent.fields[name];
        }
        var names = Object.keys(options);
        for (i = 0; i < names.length; i++) {
            name = names[i];
            fields[name] = options[name];
        }
        return;
    }

    // Null values.
    var self = this;
    if (parent) {
        this._level = parent._level;
        this.streams = [];
        for (i = 0; i < parent.streams.length; i++) {
            var s = objCopy(parent.streams[i]);
            s.closeOnExit = false; // Don't own parent stream.
            this.streams.push(s);
        }
        this.serializers = objCopy(parent.serializers);
        this.src = parent.src;
        this.fields = objCopy(parent.fields);
        if (options.level) {
            this.level(options.level);
        }
    } else {
        this._level = Number.POSITIVE_INFINITY;
        this.streams = [];
        this.serializers = null;
        this.src = false;
        this.fields = {};
    }

    // Handle *config* options (i.e. options that are not just plain data
    // for log records).
    if (options.stream) {
        self.addStream({
            type: 'stream',
            stream: options.stream,
            closeOnExit: false,
            level: options.level
        });
    } else if (options.streams) {
        options.streams.forEach(function (s) {
            self.addStream(s, options.level);
        });
    } else if (parent && options.level) {
        this.level(options.level);
    } else if (!parent) {

        /*
         * In the browser we'll be emitting to console.log by default.
         * Any console.log worth its salt these days can nicely render
         * and introspect objects (e.g. the Firefox and Chrome console)
         * so let's emit the raw log record. Are there browsers for which
         * that breaks things?
         */
        self.addStream({
            type: 'raw',
            stream: new ConsoleRawStream(),
            closeOnExit: false,
            level: options.level
        });

    }
    if (options.serializers) {
        self.addSerializers(options.serializers);
    }
    if (options.src) {
        this.src = true;
    }

    // Fields.
    // These are the default fields for log records (minus the attributes
    // removed in this constructor). To allow storing raw log records
    // (unrendered), `this.fields` must never be mutated. Create a copy for
    // any changes.
    fields = objCopy(options);
    delete fields.stream;
    delete fields.level;
    delete fields.streams;
    delete fields.serializers;
    delete fields.src;
    if (this.serializers) {
        this._applySerializers(fields);
    }
    Object.keys(fields).forEach(function (k) {
        self.fields[k] = fields[k];
    });
}

/**
 * Add a stream
 *
 * @param stream {Object}. Object with these fields:
 *    - `type`: The stream type. See README.md for full details.
 *      Often this is implied by the other fields. Examples are
 *      'file', 'stream' and "raw".
 *    - `path` or `stream`: The specify the file path or writeable
 *      stream to which log records are written. E.g.
 *      `stream: process.stdout`.
 *    - `level`: Optional. Falls back to `defaultLevel`.
 *    - `closeOnExit` (boolean): Optional. Default is true for a
 *      'file' stream when `path` is given, false otherwise.
 *    See README.md for full details.
 * @param defaultLevel {Number|String} Optional. A level to use if
 *      `stream.level` is not set. If neither is given, this defaults to INFO.
 */
Logger.prototype.addStream = function addStream(s, defaultLevel) {
    var self = this;
    if (defaultLevel === null || defaultLevel === undefined) {
        defaultLevel = INFO;
    }

    s = objCopy(s);

    // Implicit 'type' from other args.
    if (!s.type && s.stream) {
        s.type = 'raw';
    }
    s.raw = (s.type === 'raw');  // PERF: Allow for faster check in `_emit`.

    if (s.level) {
        s.level = resolveLevel(s.level);
    } else {
        s.level = resolveLevel(defaultLevel);
    }
    if (s.level < self._level) {
        self._level = s.level;
    }

    switch (s.type) {
        case 'stream':
            if (!s.closeOnExit) {
                s.closeOnExit = false;
            }
            break;
        case 'raw':
            if (!s.closeOnExit) {
                s.closeOnExit = false;
            }
            break;
        default:
            throw new TypeError('unknown stream type "' + s.type + '"');
    }

    self.streams.push(s);
    delete self.haveNonRawStreams;  // reset
};


/**
 * Add serializers
 *
 * @param serializers {Object} Optional. Object mapping log record field names
 *    to serializing functions. See README.md for details.
 */
Logger.prototype.addSerializers = function addSerializers(serializers) {
    var self = this;

    if (!self.serializers) {
        self.serializers = {};
    }
    Object.keys(serializers).forEach(function (field) {
        var serializer = serializers[field];
        if (typeof (serializer) !== 'function') {
            throw new TypeError(format(
                'invalid serializer for "%s" field: must be a function',
                field));
        } else {
            self.serializers[field] = serializer;
        }
    });
};


/**
 * Create a child logger, typically to add a few log record fields.
 *
 * This can be useful when passing a logger to a sub-component, e.g. a
 * 'wuzzle' component of your service:
 *
 *    var wuzzleLog = log.child({component: 'wuzzle'})
 *    var wuzzle = new Wuzzle({..., log: wuzzleLog})
 *
 * Then log records from the wuzzle code will have the same structure as
 * the app log, *plus the component='wuzzle' field*.
 *
 * @param options {Object} Optional. Set of options to apply to the child.
 *    All of the same options for a new Logger apply here. Notes:
 *      - The parent's streams are inherited and cannot be removed in this
 *        call. Any given `streams` are *added* to the set inherited from
 *        the parent.
 *      - The parent's serializers are inherited, though can effectively be
 *        overwritten by using duplicate keys.
 *      - Can use `level` to set the level of the streams inherited from
 *        the parent. The level for the parent is NOT affected.
 * @param simple {Boolean} Optional. Set to true to assert that `options`
 *    (a) only add fields (no config) and (b) no serialization handling is
 *    required for them. IOW, this is a fast path for frequent child
 *    creation. See 'tools/timechild.js' for numbers.
 */
Logger.prototype.child = function (options, simple) {
    return new (this.constructor)(this, options || {}, simple);
};

/**
 * Get/set the level of all streams on this logger.
 *
 * Get Usage:
 *    // Returns the current log level (lowest level of all its streams).
 *    log.level() -> INFO
 *
 * Set Usage:
 *    log.level(INFO)       // set all streams to level INFO
 *    log.level('info')     // can use 'info' et al aliases
 */
Logger.prototype.level = function level(value) {
    if (value === undefined) {
        return this._level;
    }
    var newLevel = resolveLevel(value);
    var len = this.streams.length;
    for (var i = 0; i < len; i++) {
        this.streams[i].level = newLevel;
    }
    this._level = newLevel;
};


/**
 * Get/set the level of a particular stream on this logger.
 *
 * Get Usage:
 *    // Returns an array of the levels of each stream.
 *    log.levels() -> [TRACE, INFO]
 *
 *    // Returns a level of the identified stream.
 *    log.levels(0) -> TRACE      // level of stream at index 0
 *    log.levels('foo')           // level of stream with name 'foo'
 *
 * Set Usage:
 *    log.levels(0, INFO)         // set level of stream 0 to INFO
 *    log.levels(0, 'info')       // can use 'info' et al aliases
 *    log.levels('foo', WARN)     // set stream named 'foo' to WARN
 *
 * Stream names: When streams are defined, they can optionally be given
 * a name. For example,
 *       log = new Logger({
 *         streams: [
 *           {
 *             name: 'foo',
 *             path: '/var/log/my-service/foo.log'
 *             level: 'trace'
 *           },
 *         ...
 *
 * @param name {String|Number} The stream index or name.
 * @param value {Number|String} The level value (INFO) or alias ('info').
 *    If not given, this is a 'get' operation.
 * @throws {Error} If there is no stream with the given name.
 */
Logger.prototype.levels = function levels(name, value) {
    if (name === undefined) {
        return this.streams.map(
            function (s) {
                return s.level;
            });
    }
    var stream;
    if (typeof (name) === 'number') {
        stream = this.streams[name];
        if (stream === undefined) {
            throw new Error('invalid stream index: ' + name);
        }
    } else {
        var len = this.streams.length;
        for (var i = 0; i < len; i++) {
            var s = this.streams[i];
            if (s.name === name) {
                stream = s;
                break;
            }
        }
        if (!stream) {
            throw new Error(format('no stream with name "%s"', name));
        }
    }
    if (value === undefined) {
        return stream.level;
    } else {
        var newLevel = resolveLevel(value);
        stream.level = newLevel;
        if (newLevel < this._level) {
            this._level = newLevel;
        }
    }
};


/**
 * Apply registered serializers to the appropriate keys in the given fields.
 *
 * Pre-condition: This is only called if there is at least one serializer.
 *
 * @param fields (Object) The log record fields.
 * @param excludeFields (Object) Optional mapping of keys to `true` for
 *    keys to NOT apply a serializer.
 */
Logger.prototype._applySerializers = function (fields, excludeFields) {
    var self = this;

    // Check each serializer against these (presuming number of serializers
    // is typically less than number of fields).
    Object.keys(this.serializers).forEach(function (name) {
        if (fields[name] === undefined ||
            (excludeFields && excludeFields[name])) {
            return;
        }
        try {
            fields[name] = self.serializers[name](fields[name]);
        } catch (err) {
            _warn(format('bunyan: ERROR: Exception thrown from the "%s" ' +
                    'Bunyan serializer. This should never happen. This is a bug' +
                    'in that serializer function.\n%s',
                name, err.stack || err));
            fields[name] = format('(Error in Bunyan log "%s" serializer broke field. See stderr for details.)', name);
        }
    });
};


/**
 * Emit a log record.
 *
 * @param rec {log record}
 * @param noemit {Boolean} Optional. Set to true to skip emission
 *      and just return the JSON string.
 */
Logger.prototype._emit = function (rec, noemit) {
    var i;

    // Lazily determine if this Logger has non-'raw' streams. If there are
    // any, then we need to stringify the log record.
    if (this.haveNonRawStreams === undefined) {
        this.haveNonRawStreams = false;
        for (i = 0; i < this.streams.length; i++) {
            if (!this.streams[i].raw) {
                this.haveNonRawStreams = true;
                break;
            }
        }
    }

    // Stringify the object. Attempt to warn/recover on error.
    var str;
    if (noemit || this.haveNonRawStreams) {
        try {
            str = JSON.stringify(rec, safeCycles()) + '\n';
        } catch (e) {
            var dedupKey = e.stack.split(/\n/g, 2).join('\n');
            _warn('bunyan: ERROR: Exception in ' +
                    '`JSON.stringify(rec)`. You can install the ' +
                    '"safe-json-stringify" module to have Bunyan fallback ' +
                    'to safer stringification. Record:\n' +
                    _indent(format('%s\n%s', rec, e.stack)),
                dedupKey);
            str = format('(Exception in JSON.stringify(rec): %j. See stderr for details.)\n', e.message);

        }
    }

    if (noemit) {
        return str;
    }


    var level = rec.level;
    for (i = 0; i < this.streams.length; i++) {
        var s = this.streams[i];
        if (s.level <= level) {
            s.stream.write(s.raw ? rec : str);
        }
    }

    return str;
};


/**
 * Build a log emitter function for level minLevel. I.e. this is the
 * creator of `log.info`, `log.error`, etc.
 */
function mkLogEmitter(minLevel) {
    return function () {
        var log = this;

        function mkRecord(args) {
            var excludeFields;
            if (args[0] instanceof Error) {
                // `log.<level>(err, ...)`
                fields = {
                    // Use this Logger's err serializer, if defined.
                    err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : Logger.stdSerializers.err(args[0]))
                };
                excludeFields = {err: true};
                if (args.length === 1) {
                    msgArgs = [fields.err.message];
                } else {
                    msgArgs = Array.prototype.slice.call(args, 1);
                }
            } else if (typeof (args[0]) !== 'object' && args[0] !== null ||
                Array.isArray(args[0])) {
                // `log.<level>(msg, ...)`
                fields = null;
                msgArgs = Array.prototype.slice.call(args);
            } else {  // `log.<level>(fields, msg, ...)`
                fields = args[0];
                msgArgs = Array.prototype.slice.call(args, 1);
            }

            // Build up the record object.
            var rec = objCopy(log.fields);
            rec.level = minLevel;
            var recFields = (fields ? objCopy(fields) : null);
            if (recFields) {
                if (log.serializers) {
                    log._applySerializers(recFields, excludeFields);
                }
                Object.keys(recFields).forEach(function (k) {
                    rec[k] = recFields[k];
                });
            }
            rec.levelName = nameFromLevel[minLevel];
            rec.msg = format.apply(log, msgArgs);
            if (!rec.time) {
                rec.time = (new Date());
            }
            // Get call source info
            if (log.src && !rec.src) {
                rec.src = getCaller3Info();
            }
            rec.v = LOG_VERSION;

            return rec;
        }

        var fields = null;
        var msgArgs = arguments;
        var rec = null;
        if (!this._emit) {
            /*
             * Show this invalid Bunyan usage warning *once*.
             *
             * See <https://github.com/trentm/node-bunyan/issues/100> for
             * an example of how this can happen.
             */
            var dedupKey = 'unbound';
            if (!_haveWarned[dedupKey]) {
                var caller = getCaller3Info();
                _warn(format('bunyan usage error: %s:%s: attempt to log with an unbound log method: `this` is: %s',
                        caller.file, caller.line, this.toString()),
                    dedupKey);
            }
            return;
        } else if (arguments.length === 0) {   // `log.<level>()`
            return (this._level <= minLevel);
        } else if (this._level > minLevel) {
            /* pass through */
        } else {
            rec = mkRecord(msgArgs);
            this._emit(rec);
        }
    };
}


/**
 * The functions below log a record at a specific level.
 *
 * Usages:
 *    log.<level>()  -> boolean is-trace-enabled
 *    log.<level>(<Error> err, [<string> msg, ...])
 *    log.<level>(<string> msg, ...)
 *    log.<level>(<object> fields, <string> msg, ...)
 *
 * where <level> is the lowercase version of the log level. E.g.:
 *
 *    log.info()
 *
 * @params fields {Object} Optional set of additional fields to log.
 * @params msg {String} Log message. This can be followed by additional
 *    arguments that are handled like
 *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).
 */
Logger.prototype.trace = mkLogEmitter(TRACE);
Logger.prototype.debug = mkLogEmitter(DEBUG);
Logger.prototype.info = mkLogEmitter(INFO);
Logger.prototype.warn = mkLogEmitter(WARN);
Logger.prototype.error = mkLogEmitter(ERROR);
Logger.prototype.fatal = mkLogEmitter(FATAL);


//---- Standard serializers
// A serializer is a function that serializes a JavaScript object to a
// JSON representation for logging. There is a standard set of presumed
// interesting objects in node.js-land.

Logger.stdSerializers = {};

/*
 * This function dumps long stack traces for exceptions having a cause()
 * method. The error classes from
 * [verror](https://github.com/davepacheco/node-verror) and
 * [restify v2.0](https://github.com/mcavage/node-restify) are examples.
 *
 * Based on `dumpException` in
 * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js
 */
function getFullErrorStack(ex) {
    var ret = ex.stack || ex.toString();
    if (ex.cause && typeof (ex.cause) === 'function') {
        var cex = ex.cause();
        if (cex) {
            ret += '\nCaused by: ' + getFullErrorStack(cex);
        }
    }
    return (ret);
}

// Serialize an Error object
// (Core error properties are enumerable in node 0.4, not in 0.6).
Logger.stdSerializers.err = function(err) {
    if (!err || !err.stack) {
        return err;
    }

    var obj = {
        message: err.message,
        name: err.name,
        stack: getFullErrorStack(err),
        code: err.code,
        signal: err.signal
    };
    return obj;
};


// A JSON stringifier that handles cycles safely.
// Usage: JSON.stringify(obj, safeCycles())
function safeCycles() {
    var seen = [];
    return function (key, val) {
        if (!val || typeof (val) !== 'object') {
            return val;
        }
        if (seen.indexOf(val) !== -1) {
            return '[Circular]';
        }
        seen.push(val);
        return val;
    };
}

//---- Exports

module.exports = Logger;

module.exports.TRACE = TRACE;
module.exports.DEBUG = DEBUG;
module.exports.INFO = INFO;
module.exports.WARN = WARN;
module.exports.ERROR = ERROR;
module.exports.FATAL = FATAL;
module.exports.resolveLevel = resolveLevel;
module.exports.levelFromName = levelFromName;
module.exports.nameFromLevel = nameFromLevel;

module.exports.VERSION = VERSION;
module.exports.LOG_VERSION = LOG_VERSION;

module.exports.createLogger = function createLogger(options) {
    return new Logger(options);
};

// Useful for custom `type == 'raw'` streams that may do JSON stringification
// of log records themselves. Usage:
//    var str = JSON.stringify(rec, bunyan.safeCycles());
module.exports.safeCycles = safeCycles;

//streams
module.exports.ConsoleFormattedStream = ConsoleFormattedStream;
module.exports.ConsoleRawStream = ConsoleRawStream;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(22);
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(12)
  , toIndex  = __webpack_require__(43)
  , toLength = __webpack_require__(11);

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(46);

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(14)
  , toObject  = __webpack_require__(12)
  , IObject   = __webpack_require__(52)
  , toLength  = __webpack_require__(11);

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction  = __webpack_require__(14)
  , isObject   = __webpack_require__(4)
  , invoke     = __webpack_require__(61)
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP          = __webpack_require__(8).f
  , create      = __webpack_require__(38)
  , redefineAll = __webpack_require__(41)
  , ctx         = __webpack_require__(30)
  , anInstance  = __webpack_require__(36)
  , defined     = __webpack_require__(23)
  , forOf       = __webpack_require__(46)
  , $iterDefine = __webpack_require__(82)
  , step        = __webpack_require__(122)
  , setSpecies  = __webpack_require__(42)
  , DESCRIPTORS = __webpack_require__(7)
  , fastKey     = __webpack_require__(33).fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(51)
  , from    = __webpack_require__(113);
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll       = __webpack_require__(41)
  , getWeak           = __webpack_require__(33).getWeak
  , anObject          = __webpack_require__(1)
  , isObject          = __webpack_require__(4)
  , anInstance        = __webpack_require__(36)
  , forOf             = __webpack_require__(46)
  , createArrayMethod = __webpack_require__(26)
  , $has              = __webpack_require__(13)
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(7) && !__webpack_require__(3)(function(){
  return Object.defineProperty(__webpack_require__(74)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(4)
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 123 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = __webpack_require__(40)
  , gOPS     = __webpack_require__(65)
  , pIE      = __webpack_require__(53)
  , toObject = __webpack_require__(12)
  , IObject  = __webpack_require__(52)
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(8)
  , anObject = __webpack_require__(1)
  , getKeys  = __webpack_require__(40);

module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(18)
  , gOPN      = __webpack_require__(39).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(13)
  , toIObject    = __webpack_require__(18)
  , arrayIndexOf = __webpack_require__(57)(false)
  , IE_PROTO     = __webpack_require__(87)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(40)
  , toIObject = __webpack_require__(18)
  , isEnum    = __webpack_require__(53).f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN     = __webpack_require__(39)
  , gOPS     = __webpack_require__(65)
  , anObject = __webpack_require__(1)
  , Reflect  = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat
  , $trim       = __webpack_require__(49).trim;

module.exports = 1 / $parseFloat(__webpack_require__(92) + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt
  , $trim     = __webpack_require__(49).trim
  , ws        = __webpack_require__(92)
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),
/* 132 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(11)
  , repeat   = __webpack_require__(91)
  , defined  = __webpack_require__(23);

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(6);

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(116);

// 23.1 Map Objects
module.exports = __webpack_require__(58)('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if(__webpack_require__(7) && /./g.flags != 'g')__webpack_require__(8).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(60)
});

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(116);

// 23.2 Set Objects
module.exports = __webpack_require__(58)('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each         = __webpack_require__(26)(0)
  , redefine     = __webpack_require__(16)
  , meta         = __webpack_require__(33)
  , assign       = __webpack_require__(124)
  , weak         = __webpack_require__(118)
  , isObject     = __webpack_require__(4)
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(58)('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

/***/ }),
/* 139 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLogLevel = exports.PlaybackVideoEncoder = exports.PlaybackAudioEncoder = exports.SharedObjectEventTypes = exports.FailoverSubscriberEventTypes = exports.RTCSubscriberEventTypes = exports.SubscriberEventTypes = exports.FailoverPublisherEventTypes = exports.RTCPublisherEventTypes = exports.PublisherEventTypes = exports.Red5ProSharedObject = exports.PlaybackControls = exports.PublisherView = exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = exports.PlaybackView = exports.RTMPSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = exports.getLogger = exports.LogLevels = undefined;

var _log = __webpack_require__(5);

Object.defineProperty(exports, 'LogLevels', {
  enumerable: true,
  get: function get() {
    return _log.LEVELS;
  }
});
Object.defineProperty(exports, 'getLogger', {
  enumerable: true,
  get: function get() {
    return _log.getLogger;
  }
});

var _index = __webpack_require__(55);

Object.defineProperty(exports, 'PlaybackControls', {
  enumerable: true,
  get: function get() {
    return _index.PlaybackControls;
  }
});

var _publisherEvent = __webpack_require__(100);

Object.defineProperty(exports, 'PublisherEventTypes', {
  enumerable: true,
  get: function get() {
    return _publisherEvent.common;
  }
});
Object.defineProperty(exports, 'RTCPublisherEventTypes', {
  enumerable: true,
  get: function get() {
    return _publisherEvent.rtc;
  }
});
Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
  enumerable: true,
  get: function get() {
    return _publisherEvent.failover;
  }
});

var _subscriberEvent = __webpack_require__(101);

Object.defineProperty(exports, 'SubscriberEventTypes', {
  enumerable: true,
  get: function get() {
    return _subscriberEvent.common;
  }
});
Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
  enumerable: true,
  get: function get() {
    return _subscriberEvent.rtc;
  }
});
Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
  enumerable: true,
  get: function get() {
    return _subscriberEvent.failover;
  }
});

var _sharedobjectEvent = __webpack_require__(70);

Object.defineProperty(exports, 'SharedObjectEventTypes', {
  enumerable: true,
  get: function get() {
    return _sharedobjectEvent.common;
  }
});

var _playback = __webpack_require__(98);

Object.defineProperty(exports, 'PlaybackAudioEncoder', {
  enumerable: true,
  get: function get() {
    return _playback.PlaybackAudioEncoder;
  }
});
Object.defineProperty(exports, 'PlaybackVideoEncoder', {
  enumerable: true,
  get: function get() {
    return _playback.PlaybackVideoEncoder;
  }
});

var _index2 = __webpack_require__(155);

var subscriberLib = _interopRequireWildcard(_index2);

var _index3 = __webpack_require__(149);

var publisherLib = _interopRequireWildcard(_index3);

var _index4 = __webpack_require__(153);

var sharedObjectLib = _interopRequireWildcard(_index4);

var _playback2 = __webpack_require__(56);

var _playback3 = _interopRequireDefault(_playback2);

var _publish = __webpack_require__(71);

var _publish2 = _interopRequireDefault(_publish);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Subscription related references.
*/
var Red5ProSubscriber = exports.Red5ProSubscriber = subscriberLib.Red5ProSubscriber;
var RTCSubscriber = exports.RTCSubscriber = subscriberLib.RTCSubscriber;
var HLSSubscriber = exports.HLSSubscriber = subscriberLib.HLSSubscriber;
var RTMPSubscriber = exports.RTMPSubscriber = subscriberLib.RTMPSubscriber;
exports.PlaybackView = _playback3.default;

/**
 * Broadcast related references.
 */

var Red5ProPublisher = exports.Red5ProPublisher = publisherLib.Red5ProPublisher;
var RTMPPublisher = exports.RTMPPublisher = publisherLib.RTMPPublisher;
var RTCPublisher = exports.RTCPublisher = publisherLib.RTCPublisher;
exports.PublisherView = _publish2.default;

/**
 * Playback controls interface.
 */

/**
 * Shared Object references.
 */
var Red5ProSharedObject = exports.Red5ProSharedObject = sharedObjectLib.Red5ProSharedObject;

/**
 * Events
 */


(0, _log.establishLogger)('' + "debug" || _log.LEVELS.DEBUG // eslint-disable-line no-undef
);(0, _log.getLogger)().debug('Red5 Pro SDK Version ' + "4.0.0-RC2" // eslint-disable-line no-undef

);var setLogLevel = exports.setLogLevel = function setLogLevel(level) {
  if (_log.LEVELS.hasOwnProperty(level.toUpperCase())) {
    (0, _log.establishLogger)(level);
  }
};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(343);

__webpack_require__(162);

__webpack_require__(163);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(139)))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var jsonAttr = /['"](.*?)['"]:/gi;
var jsonVal = /:['"](.*?)['"]/gi;

function readUTF(data, start, len) {
  var result = '',
      offset = start,
      end = start + len;
  do {
    result += String.fromCharCode(data[offset++]);
  } while (offset < end);
  return result;
}

function parseJSONForOrientation(text) {
  try {
    var value = JSON.parse(text);
    if (value.hasOwnProperty('orientation')) {
      return {
        orientation: parseInt(value.orientation)
      };
    }
    return undefined;
  } catch (e) {
    var match = jsonAttr.exec(text);
    var match2 = void 0;
    if (match && match.length > 1) {
      match2 = jsonVal.exec(text);
      if (match[1] === 'orientation' && match2 && match2.length > 1) {
        return {
          orientation: parseInt(match2[1])
        };
      }
    }
    return undefined;
  }
}

var onOrientationMetadata = exports.onOrientationMetadata = function onOrientationMetadata(player, callback) {

  var textTracks = typeof player.textTracks === 'function' ? player.textTracks() : player.textTracks;

  if (textTracks) {

    player.addTextTrack('metadata');

    textTracks.addEventListener('addtrack', function (addTrackEvent) {

      var track = addTrackEvent.track;
      track.mode = 'hidden';
      /**
      var cue = new VTTCue(1.0, 0, 'Testing')
      cue.id = 1
      cue.pauseOnExit = false
      track.addCue(cue)
      */

      track.addEventListener('cuechange', function (cueChangeEvent) {
        var cues = void 0;
        var i = void 0;
        // Mostly Chrome.
        if (cueChangeEvent && cueChangeEvent.currentTarget) {
          cues = cueChangeEvent.currentTarget.cues;
        } else if (undefined === undefined) {
          cues = track.cues;
          cues = cues && cues.length > 0 ? cues : track.activeCues;
        } else if (undefined !== undefined) {
          // Mostly Firefox & Safari.
          cues = cues && cues.length > 0 ? cues : undefined.activeCues;
        }
        // Mostly failure.
        cues = cues || [];
        for (i = 0; i < cues.length; i++) {
          var data = cues[i];
          if (data.value) {
            var text = typeof data.value.data === 'string' ? data.value.data : readUTF(data.value.data, 0, data.size);
            var orientation = parseJSONForOrientation(text);
            if (typeof orientation !== 'undefined') {
              callback(orientation);
              break;
            }
          }
        }
      });
    });
  }
};

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NoElementFoundError = exports.NoElementFoundError = function NoElementFoundError(message) {
  _classCallCheck(this, NoElementFoundError);

  this.name = 'NoElementFound';
  this.message = message;
};

var NoSupportedCameraResolutionsError = exports.NoSupportedCameraResolutionsError = function NoSupportedCameraResolutionsError(message) {
  _classCallCheck(this, NoSupportedCameraResolutionsError);

  this.name = 'NoSupportedCameraResolutionsError';
  this.message = message;
};

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _socketHelper = __webpack_require__(103);

var _socketHelper2 = _interopRequireDefault(_socketHelper);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'R5ProPublisherSocket';

var PublisherSocketHelper = function (_SocketHelper) {
  _inherits(PublisherSocketHelper, _SocketHelper);

  function PublisherSocketHelper(responder) {
    _classCallCheck(this, PublisherSocketHelper);

    return _possibleConstructorReturn(this, (PublisherSocketHelper.__proto__ || Object.getPrototypeOf(PublisherSocketHelper)).call(this, responder, NAME));
  }

  _createClass(PublisherSocketHelper, [{
    key: 'respond',
    value: function respond(message) {
      if (message.data) {
        var json = this.getJsonFromSocketMessage(message);
        try {
          if (!_get(PublisherSocketHelper.prototype.__proto__ || Object.getPrototypeOf(PublisherSocketHelper.prototype), 'respond', this).call(this, message)) {
            if (json.data !== undefined) {
              if (json.data.sdp !== undefined) {
                if (json.data.sdp.type === 'answer') {
                  this._responder.onSDPAnswer(json.data);
                }
              }
              if (json.data.candidate !== undefined) {
                this._responder.onAddIceCandidate(json.data.candidate);
              }
              if (json.data.type === 'status') {
                if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
                  this._responder.onSocketIceCandidateEnd();
                } else {
                  this._responder.onPublisherStatus(json.data);
                }
              }
            }
          }
        } catch (e) {
          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
        }
      } else {
        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
      }
    }
  }]);

  return PublisherSocketHelper;
}(_socketHelper2.default);

exports.default = PublisherSocketHelper;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _socketHelper = __webpack_require__(103);

var _socketHelper2 = _interopRequireDefault(_socketHelper);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'R5ProSubscriptionSocket';

var SubscriptionSocketHelper = function (_SocketHelper) {
  _inherits(SubscriptionSocketHelper, _SocketHelper);

  function SubscriptionSocketHelper(responder) {
    _classCallCheck(this, SubscriptionSocketHelper);

    return _possibleConstructorReturn(this, (SubscriptionSocketHelper.__proto__ || Object.getPrototypeOf(SubscriptionSocketHelper)).call(this, responder, NAME));
  }

  _createClass(SubscriptionSocketHelper, [{
    key: 'respond',
    value: function respond(message) {
      //    console.log(message)
      if (message.data) {
        var json = this.getJsonFromSocketMessage(message);
        try {
          if (!_get(SubscriptionSocketHelper.prototype.__proto__ || Object.getPrototypeOf(SubscriptionSocketHelper.prototype), 'respond', this).call(this, message)) {
            if (json.data !== undefined) {
              if (json.data.sdp !== undefined) {
                if (json.data.sdp.type === 'offer') {
                  this._responder.onSDPOffer(json.data);
                }
              }
              if (json.data.candidate !== undefined) {
                this._responder.onAddIceCandidate(json.data.candidate);
              }
              if (json.data.type === 'status') {
                if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
                  this._responder.onSocketIceCandidateEnd();
                } else if (json.data.code === 'NetStream.Play.UnpublishNotify') {
                  this._responder.onUnpublish();
                } else if (json.data.code === 'NetConnection.Connect.Closed') {
                  this._responder.onConnectionClosed();
                } else {
                  this._responder.onSubscriberStatus(json.data);
                }
              }
              if (json.data.hasOwnProperty('status')) {
                if (json.data.status === 'NetStream.Play.UnpublishNotify') {
                  this._responder.onUnpublish();
                }
              }
              if (json.type !== undefined) {
                if (json.type === 'metadata') {
                  // It is a `send` API invocation.
                  if (json.method !== undefined) {
                    this._responder.onSendReceived(json.method, json.data);
                  }
                  // Else it is normal metadata.
                  else {
                      this._responder.onMetaData(json.data);
                    }
                }
              }
            } else if (json.type !== undefined) {
              if (json.type === 'metadata') {
                this._responder.onMetaData(json.metadata);
              }
            }
          }
        } catch (e) {
          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
        }
      } else {
        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
      }
    }
  }]);

  return SubscriptionSocketHelper;
}(_socketHelper2.default);

exports.default = SubscriptionSocketHelper;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _webrtc = __webpack_require__(54);

var webrtc = _interopRequireWildcard(_webrtc);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'R5ProPublishPeer';

var PublisherPeerHelper = function () {
  function PublisherPeerHelper(responder) {
    _classCallCheck(this, PublisherPeerHelper);

    this._responder = responder;
    this._peerConnection = undefined;
  }

  _createClass(PublisherPeerHelper, [{
    key: '_removeConnectionHandlers',
    value: function _removeConnectionHandlers(connection) {
      connection.onconnectionstatechange = undefined;
      connection.oniceconnectionstatechange = undefined;
      connection.onicecandidate = undefined;
    }
  }, {
    key: '_addConnectionHandlers',
    value: function _addConnectionHandlers(connection, promise) {
      var _this = this;

      connection.onconnectionstatechange = function () {
        if (connection.connectionState === 'connected') {
          (0, _log.debug)(NAME, '[peerconnection:open]');
          if (promise) {
            promise.resolve(_this);
          }
        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
          (0, _log.warn)(NAME, '[peerconnection:error]');
          if (promise) {
            promise.reject();
          }
        } else {
          (0, _log.debug)(NAME, '[peerconnection:' + connection.connectionState + ']');
        }
      };

      connection.onicecandidate = function (event) {
        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
        if (event.candidate) {
          _this._responder.onIceCandidate(event.candidate);
        } else if (event.candidate === null) {
          // null means they have finished sending candidates back and forth?
          // Moved to notification from server on trickle end event.
          // this._responder.onIceCandidateTrickleEnd()
        }
      };

      connection.oniceconnectionstatechange = function (event) {
        var state = event.currentTarget.iceConnectionState;
        (0, _log.debug)(NAME, '[peer.oniceconnectionstatechange] - State: ' + state);
        if (state === 'disconnected' || state === 'failed') {
          _this._responder.onPeerConnectionClose(event);
        }
      };
    }
  }, {
    key: 'getUserMedia',
    value: function getUserMedia(constraints) {
      return webrtc.getUserMedia(constraints);
    }
  }, {
    key: 'forceUserMedia',
    value: function forceUserMedia(constraints) {
      return webrtc.forceUserMedia(constraints);
    }
  }, {
    key: 'createOffer',
    value: function createOffer() {
      var _this2 = this;

      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var offerPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      (0, _log.debug)(NAME, '[createoffer]');
      var p = offerPromise || new _promise.DeferredPromise();
      this._peerConnection.createOffer().then(function (sessionDescription) {
        _this2.setLocalDescription(sessionDescription, bandwidth).then(function () {
          if (bandwidth) {
            sessionDescription.sdp = webrtc.updateBandwidth(bandwidth, sessionDescription.sdp);
          }
          _this2._responder.onSDPSuccess();
          p.resolve(sessionDescription);
        }).catch(function (err) {
          _this2._responder.onSDPError(err);
          p.reject(err);
        });
      }).catch(function (err) {
        (0, _log.debug)(NAME, '[createoffer:error]');
        p.reject(err);
      });
      return p.hasOwnProperty('promise') ? p.promise : p;
    }
  }, {
    key: 'setLocalDescription',
    value: function setLocalDescription(sessionDescription) {
      var bandwidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // eslint-disable-line no-unused-vars
      (0, _log.debug)(NAME, '[setlocaldescription]');
      return this._peerConnection.setLocalDescription(sessionDescription);
    }
  }, {
    key: 'setRemoteDescription',
    value: function setRemoteDescription(sdp) {
      (0, _log.debug)(NAME, '[setremotedescription]');
      return this._peerConnection.setRemoteDescription(new webrtc.RTCSessionDescription(sdp));
    }
  }, {
    key: 'addIceCandidate',
    value: function addIceCandidate(candidate) {
      (0, _log.debug)(NAME, '[addcandidate]');
      return this._peerConnection.addIceCandidate(candidate);
    }
  }, {
    key: 'setUp',
    value: function setUp(iceServers) {
      var setUpPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var rtcpMuxPolicy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      this.tearDown();
      var p = setUpPromise || new _promise.DeferredPromise();
      try {
        var peerConfig = {
          iceServers: iceServers,
          rtcpMuxPolicy: 'negotiate'
        };
        if (typeof rtcpMuxPolicy !== 'undefined') {
          peerConfig.rtcpMuxPolicy = rtcpMuxPolicy;
        }
        (0, _log.debug)(NAME, '[peerconnection:setup]: ' + JSON.stringify(peerConfig, null, 2));
        var peer = new webrtc.RTCPeerConnection(peerConfig, {
          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
        });
        this._addConnectionHandlers(peer);
        this._peerConnection = peer;
        p.resolve(peer);
      } catch (e) {
        (0, _log.warn)(NAME, 'Could not establish a PeerConnection. ' + e.message);
        p.reject(e.message);
      }
      return p.hasOwnProperty('promise') ? p.promise : p;
    }
  }, {
    key: 'tearDown',
    value: function tearDown() {
      (0, _log.debug)(NAME, '[teardown]');
      if (this._peerConnection) {
        this._removeConnectionHandlers(this._peerConnection);
        try {
          this._peerConnection.close();
        } catch (e) {
          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
        }
      }
    }
  }, {
    key: 'connection',
    get: function get() {
      return this._peerConnection;
    }
  }]);

  return PublisherPeerHelper;
}();

exports.default = PublisherPeerHelper;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _webrtc = __webpack_require__(54);

var webrtc = _interopRequireWildcard(_webrtc);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'R5ProSubscriptionPeer';

var isEmptyCandidate = function isEmptyCandidate(candidate) {
  return typeof candidate === 'undefined' || typeof candidate === 'string' && candidate.length === 0;
};

var SubscriptionPeerHelper = function () {
  function SubscriptionPeerHelper(responder) {
    _classCallCheck(this, SubscriptionPeerHelper);

    this._responder = responder;
    this._peerConnection = undefined;
    this._pendingMediaStream = undefined;
  }

  _createClass(SubscriptionPeerHelper, [{
    key: '_removeConnectionHandlers',
    value: function _removeConnectionHandlers(connection) {
      connection.onconnectionstatechange = undefined;
      connection.oniceconnectionstatechange = undefined;
      connection.onicecandidate = undefined;
      connection.onaddstream = undefined;
      connection.ontrack = undefined;
    }
  }, {
    key: '_addConnectionHandlers',
    value: function _addConnectionHandlers(connection, promise) {
      var _this = this;

      connection.onconnectionstatechange = function () {
        if (connection.connectionState === 'connected') {
          (0, _log.debug)(NAME, '[peerconnection:open]');
          if (promise) {
            promise.resolve(_this);
          }
        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
          (0, _log.warn)(NAME, '[peerconnection:error]');
          if (promise) {
            promise.reject();
          }
        }
      };

      connection.onicecandidate = function (event) {
        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
        if (event.candidate) {
          _this._responder.onIceCandidate(event.candidate);
        } else if (event.candidate === null) {
          // null means they have finished sending candidates back and forth?
          _this._responder.onIceCandidateTrickleEnd(_this._pendingMediaStream);
          _this._pendingMediaStream = undefined;
        }
      };

      connection.onaddstream = function (event) {
        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.stream);
        if (event.stream) {
          _this._pendingMediaStream = event.stream;
          _this._responder.onAnswerMediaStream(event.stream);
        }
      };

      connection.ontrack = function (event) {
        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.streams);
        if (event.streams && event.streams.length > 0) {
          _this._pendingMediaStream = event.streams[0];
        }
      };

      connection.oniceconnectionstatechange = function (event) {
        var state = event.currentTarget.iceConnectionState;
        (0, _log.debug)(NAME, '[peer.oniceconnectionstatechange] - State: ' + state);
        if (state === 'disconnected' || state === 'failed') {
          _this._responder.onPeerConnectionClose(event);
        }
      };
    }
  }, {
    key: 'setUp',
    value: function setUp(iceServers) {
      var setUpPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var rtcpMuxPolicy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      this.tearDown();
      var p = setUpPromise || new _promise.DeferredPromise();
      try {
        var peerConfig = {
          iceServers: iceServers,
          rtcpMuxPolicy: 'negotiate'
        };
        if (typeof rtcpMuxPolicy !== 'undefined') {
          peerConfig.rtcpMuxPolicy = rtcpMuxPolicy;
        }
        (0, _log.debug)(NAME, '[peerconnection:setup]: ' + JSON.stringify(peerConfig, null, 2));
        var peer = new webrtc.RTCPeerConnection(peerConfig, {
          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
        });
        this._peerConnection = peer;
        this._addConnectionHandlers(peer);
        p.resolve();
      } catch (e) {
        (0, _log.warn)(NAME, 'Could not create a RTCPeerConnection. Error: ' + e.message);
        p.reject(e.message);
      }
      return p.hasOwnProperty('promise') ? p.promise : p;
    }
  }, {
    key: 'tearDown',
    value: function tearDown() {
      (0, _log.debug)(NAME, '[teardown]');
      if (this._peerConnection) {
        this._removeConnectionHandlers(this._peerConnection);
        try {
          this._peerConnection.close();
        } catch (e) {
          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
        }
      }
      this._pendingMediaStream = undefined;
      this._peerConnection = undefined;
    }
  }, {
    key: 'createAnswer',
    value: function createAnswer(sdp) {
      var _this2 = this;

      (0, _log.debug)(NAME, '[createanswer]');
      var deferred = new _promise.DeferredPromise();

      this._peerConnection.setRemoteDescription(sdp).then(this._responder.onSDPSuccess).catch(function (err) {
        _this2._responder.onSDPError(err);
      });

      this._peerConnection.createAnswer().then(function (sessionDescription) {
        _this2._peerConnection.setLocalDescription(sessionDescription).then(_this2._responder.onSDPSuccess).catch(function (err) {
          _this2._responder.onSDPError(err);
        });
        deferred.resolve(sessionDescription);
      }).catch(deferred.reject);

      return deferred.promise;
    }
  }, {
    key: 'addIceCandidate',
    value: function addIceCandidate(candidate) {
      if (isEmptyCandidate(candidate)) {
        (0, _log.debug)(NAME, '[addicecandidate]:: empty');
      } else {
        (0, _log.debug)(NAME, '[addicecandidate]');
        var iceCandidate = new webrtc.RTCIceCandidate({
          sdpMLineIndex: candidate.sdpMLineIndex,
          candidate: candidate.candidate
        });
        this._peerConnection.addIceCandidate(iceCandidate).then(function () {
          // nada
        }).catch(function (err) {
          (0, _log.error)(NAME, 'Error in add of ICE Candidiate + ' + err);
        });
      }
    }
  }, {
    key: 'connection',
    get: function get() {
      return this._peerConnection;
    }
  }]);

  return SubscriptionPeerHelper;
}();

exports.default = SubscriptionPeerHelper;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RawStream = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _browserBunyan = __webpack_require__(110);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RawStream = exports.RawStream = function () {
  function RawStream() {
    _classCallCheck(this, RawStream);
  }

  _createClass(RawStream, [{
    key: 'write',
    value: function write(rec) {
      console.log('[%s] %s: %s',
      //                rec.time.toISOString(),
      rec.name, _browserBunyan.nameFromLevel[rec.level], rec.msg);
    }
  }]);

  return RawStream;
}();

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Main entry for failover support of all publisher implementations.
 */


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _implFactoryOrder = __webpack_require__(106);

var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _red5proRtmp = __webpack_require__(152);

var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);

var _red5proRtc = __webpack_require__(151);

var _red5proRtc2 = _interopRequireDefault(_red5proRtc);

var _promise = __webpack_require__(10);

var _publish = __webpack_require__(69);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'R5ProPublisher';
var publishFactory = new _implFactoryOrder2.default();
var publisherImpl = function () {
  var map = new Map();
  map.set(_publish.PublishTypes.RTC, _red5proRtc2.default);
  map.set(_publish.PublishTypes.RTMP, _red5proRtmp2.default);
  return map;
}();

var Red5ProPublisher = function (_EventEmitter) {
  _inherits(Red5ProPublisher, _EventEmitter);

  function Red5ProPublisher() {
    _classCallCheck(this, Red5ProPublisher);

    var _this = _possibleConstructorReturn(this, (Red5ProPublisher.__proto__ || Object.getPrototypeOf(Red5ProPublisher)).call(this));

    _this._options = undefined;
    _this._view = undefined;
    _this._currentPublisher = undefined;
    _this._boundBubblePublisherEvent = _this.bubblePublisherEvent.bind(_this);
    _this._order = [_publish.PublishTypes.RTC, _publish.PublishTypes.RTMP];
    return _this;
  }

  _createClass(Red5ProPublisher, [{
    key: 'getPublishOrder',
    value: function getPublishOrder() {
      return this._order;
    }
  }, {
    key: 'setPublishOrder',
    value: function setPublishOrder(order) {
      // Allow for string value to define single item in order.
      order = typeof order === 'string' ? [order] : order;

      // Filter out values not available in enumeration of playback types.
      var t = order.filter(function (entry) {
        var key = void 0;
        for (key in _publish.PublishTypes) {
          if (_publish.PublishTypes[key].toLowerCase() === entry.toLowerCase()) {
            return true;
          }
        }
        return false;
      }).map(function (entry) {
        return entry.toLowerCase();
      }

      // Define new order.
      );this._order = [].concat(_toConsumableArray(new Set(t)));
      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
      return this;
    }
  }, {
    key: 'setView',
    value: function setView(publishView) {
      this._view = publishView;
      return this;
    }
  }, {
    key: 'getPublisherFromOrder',
    value: function getPublisherFromOrder(order, options) {
      return publishFactory.create(order, publisherImpl, options, 'init');
    }
  }, {
    key: 'init',
    value: function init(options) {
      var _this2 = this;

      var deferred = new _promise.DeferredPromise();
      (0, _log.debug)(NAME, '[publish]');
      this._options = options;
      this.getPublisherFromOrder(this._order, this._options).then(function (publisher) {
        _this2._currentPublisher = publisher;
        if (_this2._view) {
          _this2._view.attachPublisher(_this2._currentPublisher);
        }
        _this2._currentPublisher.on('*', _this2._boundBubblePublisherEvent);
        deferred.resolve(_this2._currentPublisher);
      }).catch(function (err) {
        (0, _log.warn)(NAME, '[publisherror]: Could not implement a publisher: ' + err);
        deferred.reject(err);
      });
      return deferred.promise;
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _this3 = this;

      var deferred = new _promise.DeferredPromise();
      if (!this._currentPublisher) {
        (0, _log.warn)(NAME, '[stop]: Could not invoke stop() on undefined publisher.');
        deferred.reject('A current publisher is not available to issue a :stop() command to.');
      } else {
        (0, _log.debug)(NAME, '[stop]: Invoking stop on held publisher');
        this._currentPublisher.unpublish().then(function () {
          (0, _log.debug)(NAME, '[stopsuccess]');
          _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
          _this3._currentPublisher = undefined;
          deferred.resolve();
        }).catch(function (err) {
          (0, _log.debug)(NAME, '[stoperror]: ' + err);
          if (_this3._currentPublisher) {
            _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
          }
          _this3._currentPublisher = undefined;
          deferred.reject(err);
        });
      }
      return deferred.promise;
    }
  }, {
    key: 'bubblePublisherEvent',
    value: function bubblePublisherEvent(publisherEvent) {
      this.trigger.call(this, publisherEvent);
    }
  }, {
    key: 'publishTypes',
    get: function get() {
      return _publish.PublishTypes;
    }
  }, {
    key: 'currentPublisher',
    get: function get() {
      return this._currentPublisher;
    }
  }]);

  return Red5ProPublisher;
}(_eventEmitter2.default);

exports.Red5ProPublisher = Red5ProPublisher;
exports.RTMPPublisher = _red5proRtmp2.default;
exports.RTCPublisher = _red5proRtc2.default;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _embed = __webpack_require__(99);

var embed = _interopRequireWildcard(_embed);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _sharedobjectHelperRtmp = __webpack_require__(102);

var _sharedobjectHelperRtmp2 = _interopRequireDefault(_sharedobjectHelperRtmp);

var _util = __webpack_require__(107);

var _object = __webpack_require__(108);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'R5ProPublisherSourceHandler';

var convertDimensionOptions = function convertDimensionOptions(vo) {
  return vo.exact || vo.ideal || vo.max || vo.min || vo;
};
var mediaConstraintsToFlashvars = function mediaConstraintsToFlashvars(constraints, flashvars) {
  var fv = (0, _object.deepCopy)(flashvars);
  if (typeof constraints.video === 'boolean') {
    fv.video = constraints.video;
  } else {
    var key = void 0;
    for (key in constraints.video) {
      fv[key] = convertDimensionOptions(constraints.video[key]);
    }
  }
  fv.audio = constraints.audio;
  return fv;
};

var PublisherSourceHandler = function () {
  function PublisherSourceHandler(video, type) {
    var soResponder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    _classCallCheck(this, PublisherSourceHandler);

    this.video = video;
    this.clone = this.video.cloneNode(true);
    this.holder = this.video.parentNode;
    this.publisherType = type;
    this._swfId = null;
    this._embedFuture = undefined;
    this._soResponder = soResponder || new _sharedobjectHelperRtmp2.default();
  }

  _createClass(PublisherSourceHandler, [{
    key: 'getEmbedOperation',
    value: function getEmbedOperation() {
      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
      return this._embedFuture.promise;
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      // Return to prior DOM manipulation.
      this.video.remove();
      this.video = this.clone.cloneNode(true);
      this.holder.appendChild(this.video);
      this._embedFuture = undefined;
    }
  }, {
    key: 'addSource',
    value: function addSource(swfId, options) {
      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      (0, _log.debug)(NAME, '[addsource]');
      var self = this;
      this._swfId = swfId;
      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
      var deferred = this._embedFuture;
      options.swf = swfUrl || options.swf;
      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
      embed.defineEmbedElement(this.video, this.holder).then(function (elementId) {
        (0, _log.debug)(NAME, '[element:complete]');
        var flashvars = {
          buffer: options.buffer != null ? options.buffer : 1,
          streamMode: options.streamMode,
          streamName: options.streamName,
          appName: options.app,
          host: options.host
        };
        if (options.backgroundColor) {
          flashvars.backgroundColor = options.backgroundColor;
        }
        if (options.context) {
          flashvars.roomName = options.context;
        }
        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
          flashvars.autosize = true;
        }
        if (typeof options.connectionParams !== 'undefined') {
          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
        }
        flashvars = mediaConstraintsToFlashvars(options.mediaConstraints, flashvars);
        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
      }).then(function () {
        (0, _log.debug)(NAME, '[embed:complete]');
        deferred.resolve(self);
      }).catch(function (err) {
        return deferred.reject(err);
      });
      return deferred.promise;
    }
  }, {
    key: 'connect',
    value: function connect(publishOptions) {
      (0, _log.debug)(NAME, '[connect]');
      var el = _browser2.default.getEmbedObject(this._swfId);
      if (el) {
        el.connect(publishOptions);
        this._soResponder.connect(this._swfId);
      } else {
        (0, _log.warn)(NAME, 'Could not determine embedded element with swf id: ' + this._swfId + '.');
      }
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      (0, _log.debug)(NAME, '[disconnect]');
      try {
        // No invocable API for custom live flash publisher from Red5 Pro at the time.
      } catch (e) {
        // nada.
      }
      this.cleanUp();
      this._soResponder.disconnect();
    }
  }, {
    key: 'send',
    value: function send(methodName, data) {
      var el = _browser2.default.getEmbedObject(this._swfId);
      if (el) {
        el.send(methodName, data);
      }
    }
  }, {
    key: 'addSharedObjectResponseHandler',
    value: function addSharedObjectResponseHandler(handler) {
      this._soResponder.addResponseHandler(handler);
    }
  }, {
    key: 'removeSharedObjectResponseHandler',
    value: function removeSharedObjectResponseHandler(handler) {
      this._soResponder.removeResponseHandler(handler);
    }
  }, {
    key: 'sendToSharedObject',
    value: function sendToSharedObject(name, callName, message) {
      this._soResponder.sendToSharedObject(name, callName, message);
    }
  }, {
    key: 'sendPropertyToSharedObject',
    value: function sendPropertyToSharedObject(name, key, value) {
      this._soResponder.sendPropertyToSharedObject(name, key, value);
    }
  }, {
    key: 'getRemoteSharedObject',
    value: function getRemoteSharedObject(sharedObjectName) {
      this._soResponder.getRemoteSharedObject(sharedObjectName);
    }
  }, {
    key: 'connectToSharedObject',
    value: function connectToSharedObject(sharedObjectName) {
      this._soResponder.connectToSharedObject(sharedObjectName);
    }
  }, {
    key: 'closeSharedObject',
    value: function closeSharedObject(sharedObjectName) {
      this._soResponder.closeSharedObject(sharedObjectName);
    }
  }, {
    key: 'setMediaQuality',
    value: function setMediaQuality(quality) {
      var el = _browser2.default.getEmbedObject(this._swfId);
      if (el) {
        if (quality.video && typeof quality.video !== 'boolean') {
          var w = !isNaN(quality.video.width) ? (0, _util.toInt)(quality.video.width) : Number.isNaN;
          var h = !isNaN(quality.video.height) ? (0, _util.toInt)(quality.video.height) : Number.isNaN;
          el.updateResolution(w, h);
        }
      }
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.publisherType;
    }
  }]);

  return PublisherSourceHandler;
}();

exports.default = PublisherSourceHandler;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _webrtc = __webpack_require__(54);

var webrtc = _interopRequireWildcard(_webrtc);

var _websocket = __webpack_require__(68);

var websocket = _interopRequireWildcard(_websocket);

var _socketHelperPub = __webpack_require__(144);

var _socketHelperPub2 = _interopRequireDefault(_socketHelperPub);

var _webrtcHelperPub = __webpack_require__(146);

var _webrtcHelperPub2 = _interopRequireDefault(_webrtcHelperPub);

var _publish = __webpack_require__(71);

var _publish2 = _interopRequireDefault(_publish);

var _event = __webpack_require__(25);

var _publish3 = __webpack_require__(69);

var _promise = __webpack_require__(10);

var _constraint = __webpack_require__(104);

var _urlEndpoint = __webpack_require__(109);

var _log = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Default to secure settings.
var defaultOptions = {
  protocol: 'wss',
  port: 8083,
  app: 'live',
  streamMode: _publish3.PublishModeTypes.LIVE,
  mediaElementId: 'red5pro-publisher',
  bandwidth: {
    audio: 56,
    video: 512
  },
  mediaConstraints: new _constraint.RTCMediaConstraint(),
  onGetUserMedia: undefined
};

var pubStartRegex = /(.*) starting/i;
var pubStopRegex = /(.*) stopping/i;
var NAME = 'RTCPublisher';
var debug = function debug(message) {
  (0, _log.debug)(NAME, message);
};
var warn = function warn(message) {
  (0, _log.warn)(NAME, message);
};
var error = function error(message) {
  (0, _log.error)(NAME, message);
};

var RTCPublisher = function (_EventEmitter) {
  _inherits(RTCPublisher, _EventEmitter);

  function RTCPublisher() {
    _classCallCheck(this, RTCPublisher);

    var _this = _possibleConstructorReturn(this, (RTCPublisher.__proto__ || Object.getPrototypeOf(RTCPublisher)).call(this));

    _this._options = undefined;
    _this._view = undefined;
    _this._peerHelper = undefined;
    _this._socketHelper = undefined;
    _this._mediaStream = undefined;

    _this._streamFuture = undefined;
    _this._availableFuture = undefined;
    _this._peerFuture = undefined;
    _this._offerFuture = undefined;
    _this._sendOfferFuture = undefined;
    _this._trickleEndFuture = undefined;
    _this._publishFuture = undefined;
    _this._unpublishFuture = undefined;
    return _this;
  }

  _createClass(RTCPublisher, [{
    key: '_gum',
    value: function _gum(options) {
      var _this2 = this;

      if (options.onGetUserMedia !== undefined) {
        debug('Requesting gUM from user-defined configuration:onGetUserMedia.');
        options.onGetUserMedia().then(function (media) {
          _this2._streamFuture.resolve(media);
        }).catch(function (err) {
          error('Could not resolve MediaAsset from provided gUM. Error - ' + err);
          _this2._streamFuture.reject(err);
        });
      } else {
        debug('Requesting gUM using mediaConstraints: ' + JSON.stringify(options.mediaConstraints, null, 2));
        this._peerHelper.getUserMedia(options.mediaConstraints).then(function (res) {
          debug('Found valid constraints: ' + JSON.stringify(res.constraints, null, 2));
          _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.DIMENSION_CHANGE, _this2, res.constraints));
          _this2._streamFuture.resolve(res.media);
        }).catch(function (rej) {
          debug('Could not find valid constraint resolutions from: ' + JSON.stringify(rej.constraints, null, 2));
          error('Could not resolve MediaAsset from provided mediaConstraints. Error - ' + rej.error);
          debug('Attempting to find resolutions from original provided constraints: ' + JSON.stringify(rej.constraints, null, 2)
          // allowing to try original constraint requested.
          );options.onGetUserMedia = function () {
            return _this2._peerHelper.forceUserMedia(rej.constraints);
          };
          _this2._gum(options);
        });
      }
    }
  }, {
    key: '_onMediaStreamReceived',
    value: function _onMediaStreamReceived(mediaStream) {
      this._mediaStream = mediaStream;
      this.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.MEDIA_STREAM_AVAILABLE, this, mediaStream));
      if (this._view) {
        this._view.preview(this._mediaStream);
      }
    }
  }, {
    key: '_getMediaStream',
    value: function _getMediaStream() {
      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
      return this._streamFuture.promise;
    }
  }, {
    key: '_getTrickleEnd',
    value: function _getTrickleEnd() {
      return _promise.Future.createIfNotExist(this._trickleEndFuture);
    }
  }, {
    key: '_setViewIfNotExist',
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new _publish2.default(mediaElementId);
        view.attachPublisher(this);
      }
    }
  }, {
    key: 'init',
    value: function init(options) {
      var deferred = new _promise.DeferredPromise();
      if (!webrtc.isSupported() || !websocket.isSupported()) {
        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
      } else {
        this._options = _extends({}, defaultOptions, options);
        this._peerHelper = new _webrtcHelperPub2.default(this);
        this._socketHelper = new _socketHelperPub2.default(this);
        this._getMediaStream().then(this._onMediaStreamReceived.bind(this));
        this._gum(options
        // auto preview.
        );this._setViewIfNotExist(this._view, this._options.mediaElementId);
        deferred.resolve(this);
      }
      return deferred.promise;
    }
  }, {
    key: 'setView',
    value: function setView(view) {
      this._view = view;
      if (this._mediaStream && this._view) {
        this._view.preview(this._mediaStream);
      }
      return this;
    }
  }, {
    key: 'attachStream',
    value: function attachStream(media) {
      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
      this._streamFuture.resolve(media);
      return this;
    }
  }, {
    key: 'detachStream',
    value: function detachStream() {
      if (this._mediaStream && this._mediaStream.stop) {
        this._mediaStream.stop();
      } else if (this._mediaStream && this._mediaStream.getTracks) {
        var tracks = this._mediaStream.getTracks();
        var trackLength = tracks.length;
        while (--trackLength > -1) {
          if (tracks[trackLength].stop) {
            tracks[trackLength].stop();
          }
        }
      }
      this._streamFuture = undefined;
      this._mediaStream = undefined;
      return this;
    }
  }, {
    key: 'requestAvailability',
    value: function requestAvailability(streamName, type) {
      debug('[requestavailability]');
      this._availableFuture = undefined;
      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture
      // message on socket returns -> onStream(Un)Available
      );this._socketHelper.post({
        isAvailable: streamName,
        type: type,
        bundle: false
      });
      return this._availableFuture.promise;
    }
  }, {
    key: 'createPeerConnection',
    value: function createPeerConnection(iceServers) {
      debug('[createpeeer]');
      this._peerFuture = undefined;
      this._peerFuture = _promise.Future.createIfNotExist(this._peerFuture);
      this._peerHelper.setUp(iceServers, this._peerFuture, this._options.rtcpMuxPolicy);
      return this._peerFuture.promise;
    }
  }, {
    key: 'createOffer',
    value: function createOffer() {
      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      debug('[createoffer]');
      this._offerFuture = undefined;
      this._offerFuture = _promise.Future.createIfNotExist(this._offerFuture);
      this._peerHelper.createOffer(bandwidth, this._offerFuture);
      return this._offerFuture.promise;
    }
  }, {
    key: 'setRemoteDescription',
    value: function setRemoteDescription(sdp) {
      debug('[setremotedescription]');
      return this._peerHelper.setRemoteDescription(sdp);
    }
  }, {
    key: 'sendOffer',
    value: function sendOffer(sdp, streamName) {
      debug('[sendoffer]');
      this._sendOfferFuture = undefined;
      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOffFuture);
      this._socketHelper.post({
        handleOffer: streamName,
        data: {
          sdp: sdp
        }
      });
      return this._sendOfferFuture.promise;
    }
  }, {
    key: 'sendCandidate',
    value: function sendCandidate(candidate, streamName) {
      debug('[sendcandidate]');
      this._socketHelper.post({
        handleCandidate: streamName,
        data: {
          candidate: candidate
        }
      });
    }
  }, {
    key: 'requestPublish',
    value: function requestPublish(streamName, streamMode) {
      debug('[requestpublish]');
      this._publishFuture = undefined;
      this._publishFuture = _promise.Future.createIfNotExist(this._publishFuture);
      this._socketHelper.post({
        publish: streamName,
        mode: streamMode
      });
      return this._publishFuture.promise;
    }
  }, {
    key: 'requestUnpublish',
    value: function requestUnpublish(streamName) {
      this._unpublishFuture = undefined;
      this._unpublishFuture = _promise.Future.createIfNotExist(this._unpublishFuture
      // If we get a false response from tyring to send a close POST,
      //  it means that the socket has already been closed by another impetus -
      //  most likley loss of network or server failure.
      );if (!this._socketHelper.post({
        unpublish: streamName
      })) {
        this._unpublishFuture.resolve();
      }
      return this._unpublishFuture.promise;
    }
  }, {
    key: 'preview',
    value: function preview() {
      var _this3 = this;

      debug('[preview]');
      var p = new Promise(function (res) {
        res(_this3);
      });
      this._setViewIfNotExist(this._view, this._options.mediaElementId);
      return p;
    }
  }, {
    key: 'publish',
    value: function publish() {
      var _this4 = this;

      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      debug('[publish]');
      this._options.streamName = streamName || this._options.streamName;
      var p = promise || new _promise.DeferredPromise();
      var socketPromise = new _promise.DeferredPromise();
      var socketurl = (0, _urlEndpoint.rtcSocketEndpointFromOptions)(this._options, {
        id: this._options.streamName
      });
      this._trickleEndFuture = this._getTrickleEnd();
      this._socketHelper.setUp(socketurl, socketPromise
      // 0. Establish socket connection.
      );socketPromise.promise
      // 1. Wait for stream attach
      .then(function () {
        _this4.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS, _this4));
        return _this4._getMediaStream();
      }
      // 2. Request available stream to publish on
      ).then(function () {
        return _this4.requestAvailability(_this4._options.streamName, _this4._options.streamType);
      }
      // 3. Create Peer Connection
      ).then(function () {
        return _this4.createPeerConnection(_this4._options.iceServers);
      }
      // 4. Make Offer on Peer Connection
      ).then(function (connection) {
        connection.addStream(_this4._mediaStream);
        _this4.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.PEER_CONNECTION_AVAILABLE, _this4, connection));
        return _this4.createOffer(_this4._options.bandwidth);
      }
      // 5. Send Offer
      ).then(function (sessionDescription) {
        _this4.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_START, _this4, sessionDescription));
        return _this4.sendOffer(sessionDescription, _this4._options.streamName);
      }
      // 6. Set the session description remotely
      ).then(function (sdp) {
        return _this4.setRemoteDescription(sdp.sdp);
      }
      // 7. Wait until ice trickle end
      ).then(function (sdp) {
        _this4.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_END, _this4, sdp));
        return _this4._getTrickleEnd().promise;
      }
      // 8. Request to publish stream
      ).then(function () {
        _this4.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.ICE_TRICKLE_COMPLETE, _this4));
        return _this4.requestPublish(_this4._options.streamName, _this4._options.streamMode);
      }
      // 9. Results in socket message of publish (see :onPublishStatus)
      ).then(function () {
        p.resolve(_this4);
        _this4.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START, _this4));
      }).catch(function (error) {
        p.reject(error);
        _this4.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this4, error));
      });
      return p.hasOwnProperty('promise') ? p.promise : p;
    }
  }, {
    key: 'unpublish',
    value: function unpublish() {
      var _this5 = this;

      debug('[unpublish]');
      var clearHelpers = function clearHelpers() {
        if (_this5._socketHelper) {
          _this5._socketHelper.tearDown();
        }
        if (_this5._peerHelper) {
          _this5._peerHelper.tearDown();
        }
      };
      this._availableFuture = undefined;
      this._peerFuture = undefined;
      this._offerFuture = undefined;
      this._sendOfferFuture = undefined;
      this._trickleEndFuture = undefined;
      this._publishFuture = undefined;
      var f = this.requestUnpublish(this._options.streamName);
      f.then(function () {
        _this5._unpublishFuture = undefined;
        clearHelpers();
        _this5.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS, _this5));
      });
      return f;
    }
  }, {
    key: 'mute',
    value: function mute() {
      // backward comatibility - to be deprecated.
      this.muteAudio();
    }
  }, {
    key: 'unmute',
    value: function unmute() {
      // backward comatibility - to be deprecated.
      this.unmuteAudio();
    }
  }, {
    key: 'muteAudio',
    value: function muteAudio() {
      this._socketHelper.post({
        mute: {
          muteAudio: true
        }
      });
    }
  }, {
    key: 'unmuteAudio',
    value: function unmuteAudio() {
      this._socketHelper.post({
        mute: {
          muteAudio: false
        }
      });
    }
  }, {
    key: 'muteVideo',
    value: function muteVideo() {
      this._socketHelper.post({
        mute: {
          muteVideo: true
        }
      });
    }
  }, {
    key: 'unmuteVideo',
    value: function unmuteVideo() {
      this._socketHelper.post({
        mute: {
          muteVideo: false
        }
      });
    }
  }, {
    key: 'send',
    value: function send(methodName, data) {
      this._socketHelper.post({
        send: {
          method: methodName,
          data: typeof data === 'string' ? JSON.parse(data) : data
        }
      });
    }
  }, {
    key: 'onStreamAvailable',
    value: function onStreamAvailable(receipt) {
      debug('[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
      this._availableFuture.reject('Stream with name ' + this._options.streamName + ' already has a broadcast session.');
      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME, this));
    }
  }, {
    key: 'onStreamUnavailable',
    value: function onStreamUnavailable(receipt) {
      // Being unavailable, is a good thing for allowing to publish using `options.streamName`
      debug('Stream ' + this._options.streamName + ' does not exist.');
      debug('[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
      this._availableFuture.resolve(true);
    }
  }, {
    key: 'onSocketMessageError',
    value: function onSocketMessageError(message) {
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      error('Error in stream playback: ' + message + '.\n[Optional detail]: ' + detail);
      if (this._publishFuture) {
        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, this));
        this._publishFuture.reject(message);
      }
    }
  }, {
    key: 'onSocketClose',
    value: function onSocketClose(closeEvent) {
      debug(NAME, '[onsocketclose]');
      if (this._peerHelper) {
        this._peerHelper.tearDown();
      }
      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECTION_CLOSED, this, closeEvent));
    }
  }, {
    key: 'onPeerConnectionClose',
    value: function onPeerConnectionClose(event) {
      debug(NAME, '[onpeerconnectionclose]');
      if (this._socketHelper) {
        this._socketHelper.tearDown();
      }
      this.onSocketClose(event);
    }
  }, {
    key: 'onSDPSuccess',
    value: function onSDPSuccess(receipt) {
      var info = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
      debug('[onsdpsuccess]' + info);
    }
  }, {
    key: 'onSDPError',
    value: function onSDPError(receipt) {
      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, this));
      var error = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
      error('[onsdperror]' + error);
    }
  }, {
    key: 'onSDPAnswer',
    value: function onSDPAnswer(sdp) {
      debug('[sdpanswer]:: ' + JSON.stringify(sdp, null, 2));
      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOfferFuture);
      this._sendOfferFuture.resolve(sdp);
    }
  }, {
    key: 'onAddIceCandidate',
    value: function onAddIceCandidate(candidate) {
      debug('[addicecandidate]');
      this._peerHelper.addIceCandidate(candidate).then(function () {
        debug('[addicecandidate:success]');
      }).catch(function (err) {
        warn('[addicecandidate:error] - ' + err);
      });
    }
  }, {
    key: 'onIceCandidate',
    value: function onIceCandidate(candidate) {
      debug('[icecandidatetrickle]');
      this.sendCandidate(candidate, this._options.streamName);
    }
  }, {
    key: 'onIceCandidateTrickleEnd',
    value: function onIceCandidateTrickleEnd() {
      debug('[icecandidatetrickle:end]');
    }
  }, {
    key: 'onSocketIceCandidateEnd',
    value: function onSocketIceCandidateEnd() {
      debug('[socketicecandidate:end]');
      this._getTrickleEnd().resolve
      // this._trickleEndFuture = undefined
      ();
    }
  }, {
    key: 'onPublisherStatus',
    value: function onPublisherStatus(status) {
      debug('[publisherstatus] - ' + JSON.stringify(status, null, 2));
      var stopResult = pubStopRegex.exec(status.message);
      var startResult = pubStartRegex.exec(status.message);
      if (stopResult && stopResult[1] === this._options.streamName) {
        this._unpublishFuture.resolve();
      } else if (startResult && startResult[1] === this._options.streamName) {
        this._publishFuture.resolve();
      } else {
        warn('Publisher status received, but could not handle.');
      }
    }
  }, {
    key: 'overlayOptions',
    value: function overlayOptions(newOptions) {
      this._options = _extends(this._options, newOptions);
    }
  }, {
    key: 'getConnection',
    value: function getConnection() {
      return this._socketHelper;
    }
  }, {
    key: 'getPeerConnection',
    value: function getPeerConnection() {
      return this._peerHelper ? this._peerHelper.connection : undefined;
    }
  }, {
    key: 'getMediaStream',
    value: function getMediaStream() {
      return this._mediaStream;
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      return this._options;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return _publish3.PublishTypes.RTC.toUpperCase();
    }
  }]);

  return RTCPublisher;
}(_eventEmitter2.default);

exports.default = RTCPublisher;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _pubSourceHandler = __webpack_require__(150);

var _pubSourceHandler2 = _interopRequireDefault(_pubSourceHandler);

var _publish = __webpack_require__(71);

var _publish2 = _interopRequireDefault(_publish);

var _event = __webpack_require__(25);

var _promise = __webpack_require__(10);

var _publish3 = __webpack_require__(69);

var _constraint = __webpack_require__(104);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'RTMPPublisher';
var defaultOptions = {
  protocol: 'rtmp',
  port: 1935,
  streamMode: 'live',
  mediaElementId: 'red5pro-publisher',
  embedWidth: '100%', // DOM display style
  embedHeight: '100%', // DOM display style
  minFlashVersion: '10.0.0',
  swf: 'lib/red5pro/red5pro-publisher.swf',
  swfobjectURL: 'lib/swfobject/swfobject.js',
  productInstallURL: 'lib/swfobject/playerProductInstall.swf',
  mediaConstraints: new _constraint.RTMPMediaConstraint()
};

var RTMPPublisher = function (_EventEmitter) {
  _inherits(RTMPPublisher, _EventEmitter);

  function RTMPPublisher() {
    _classCallCheck(this, RTMPPublisher);

    var _this = _possibleConstructorReturn(this, (RTMPPublisher.__proto__ || Object.getPrototypeOf(RTMPPublisher)).call(this));

    _this._options = undefined;
    _this._view = undefined;
    _this._sourceHandler = undefined;
    _this._elementId = undefined;
    _this._connectFuture = undefined;
    return _this;
  }

  _createClass(RTMPPublisher, [{
    key: '_setViewIfNotExist',
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new _publish2.default(mediaElementId);
        view.attachPublisher(this);
      }
    }
  }, {
    key: 'init',
    value: function init(options) {
      var self = this;
      var deferred = new _promise.DeferredPromise();
      var version = options.minFlashVersion || defaultOptions.minFlashVersion;
      if (!_browser2.default.supportsFlashVersion(version)) {
        deferred.reject('Could not resolve RTMPPublisher instance. Requires minimum Flash Player install of ' + version);
      } else {
        this._options = _extends({}, defaultOptions, options);
        try {
          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
            (0, _log.debug)(NAME, 'SWFObject embedded.');
            if (self._sourceHandler) {
              (0, _log.debug)(NAME, 'Publish handler established.');
              return self._sourceHandler.addSource(self._elementId, self._options);
            } else {
              (0, _log.debug)(NAME, 'Publish handler not established.');
              return true;
            }
          }).then(function () {
            self._setViewIfNotExist(self._view, self._options.mediaElementId);
            deferred.resolve(self);
          }).catch(function (err) {
            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Publisher. Reason: ' + err);
            if (self._sourceHandler) {
              self._sourceHandler.disconnect();
            }
            deferred.reject(err);
            self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
          });
        } catch (e) {
          deferred.reject('Could not inject Flash-based Publisher into the page. Reason: ' + e.message);
          self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
        }
      }
      return deferred.promise;
    }
  }, {
    key: '_setUpConnectCallback',
    value: function _setUpConnectCallback(promise) {
      var _this2 = this;

      window.setActiveId = function (successId) {
        // successId === _options.streamName
        (0, _log.debug)(NAME, 'Embed and connect() complete for publisher swf. successId(' + successId + ').');
        promise.resolve(successId);
        _this2.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_SUCCESS, _this2));
        _this2._tearDownConnectCallback();
      };
      // TODO: Setup timeout to reject?
    }
  }, {
    key: '_tearDownConnectCallback',
    value: function _tearDownConnectCallback() {
      window.setActiveId = undefined;
    }
  }, {
    key: '_establishExtIntHandlers',
    value: function _establishExtIntHandlers() {
      var _this3 = this;

      var id = this._options.streamName;
      var invokeFn = function invokeFn(label) {
        return ['publisher', label, id].join('_');
      };
      window[invokeFn('r5proConnectClosed')] = function () {
        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECTION_CLOSED, _this3));
      };
      window[invokeFn('r5proConnectSuccess')] = function () {
        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS, _this3));
      };
      window[invokeFn('r5proUnpublishSuccess')] = function () {
        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS, _this3));
      };
      window[invokeFn('r5proPublishStart')] = function () {
        _this3._connectFuture.resolve(_this3);
        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START, _this3));
      };
      window[invokeFn('r5proPublishMetadata')] = function (metadata) {
        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_METADATA, _this3, metadata));
      };
      window[invokeFn('r5proConnectFailure')] = function () {
        _this3._connectFuture.reject(_event.PublisherEventTypes.CONNECT_FAILURE);
        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this3));
      };
      window[invokeFn('r5proPublishFail')] = function () {
        _this3._connectFuture.reject(_event.PublisherEventTypes.PUBLISH_FAIL);
        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, _this3));
      };
      window[invokeFn('r5proPublishInvalidName')] = function () {
        _this3._connectFuture.reject(_event.PublisherEventTypes.PUBLISH_INVALID_NAME);
        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME, _this3));
      };
    }
  }, {
    key: 'publish',
    value: function publish() {
      var _this4 = this;

      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      // eslint-disable-line no-unused-vars
      var dfd = new _promise.DeferredPromise();
      this._setUpConnectCallback(dfd);
      this._options.streamName = streamName || this._options.streamName;
      var publishOptions = this._options;
      try {
        var srcHandler = this._sourceHandler;
        this._sourceHandler.getEmbedOperation().then(function () {
          (0, _log.debug)(NAME, '[handler:embed:complete]');
          var el = _browser2.default.getEmbedObject(_this4._elementId);
          if (el) {
            _this4._establishExtIntHandlers();
          }
          var count = 0;
          var limit = 100;
          var tryConnect = function tryConnect() {
            var timeout = void 0;
            timeout = setTimeout(function () {
              try {
                clearTimeout(timeout);
                srcHandler.connect(JSON.stringify(publishOptions));
              } catch (e) {
                if (count++ > limit) {
                  throw e;
                } else {
                  tryConnect();
                }
              }
            }, 300);
          };
          tryConnect();
        }).catch(function (err) {
          dfd.reject(err);
          _this4.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this4));
        });
      } catch (e) {
        (0, _log.error)(NAME, '[handler:embed:error]');
        dfd.reject('Could not initiate connection sequence. Reason: ' + e.message);
        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, this));
        this._tearDownConnectCallback();
      }
      this._connectFuture = dfd;
      return dfd.promise;
    }
  }, {
    key: 'unpublish',
    value: function unpublish() {
      var deferred = new _promise.DeferredPromise();
      try {
        _browser2.default.getEmbedObject(this._elementId).disconnect();
        deferred.resolve();
      } catch (e) {
        (0, _log.error)(NAME, 'Could not initiate disconnection sequence. Reason: ' + e.message);
        deferred.reject(e.message);
      }
      this._connectFuture = undefined;
      return deferred.promise;
    }
  }, {
    key: 'send',
    value: function send(methodName, data) {
      this._sourceHandler.send(methodName, typeof data === 'string' ? data : JSON.stringify(data));
    }
  }, {
    key: 'setView',
    value: function setView(view, elementId) {
      var _this5 = this;

      this._view = view;
      this._elementId = elementId;
      if (this._sourceHandler !== undefined) {
        this._sourceHandler.disconnect();
        this._sourceHandler = undefined;
      }
      if (this._view) {
        this._sourceHandler = new _pubSourceHandler2.default(this._view.view, this.getType());
      }
      if (this._options && this._sourceHandler) {
        this._sourceHandler.addSource(this._elementId, this._options).catch(function (err) {
          (0, _log.error)(NAME, 'Could not establish proper RTMP publisher: ' + err);
          _this5.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, _this5));
        });
      }
      return this;
    }
  }, {
    key: 'setMediaQuality',
    value: function setMediaQuality(quality) {
      if (this._sourceHandler) {
        this._sourceHandler.setMediaQuality(quality);
      }
    }
  }, {
    key: 'overlayOptions',
    value: function overlayOptions(newOptions) {
      this._options = _extends(this._options, newOptions);
    }
  }, {
    key: 'getConnection',
    value: function getConnection() {
      return this._sourceHandler;
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      return this._options;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return _publish3.PublishTypes.RTMP.toUpperCase();
    }
  }]);

  return RTMPPublisher;
}(_eventEmitter2.default);

exports.default = RTMPPublisher;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Red5ProSharedObject = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _index = __webpack_require__(25);

var _sharedobjectEvent = __webpack_require__(70);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NAME = 'Red5ProSharedObject';
var debug = function debug(soName, message) {
  (0, _log.debug)([NAME, soName].join(':'), message);
};
var warn = function warn(soName, message) {
  (0, _log.warn)([NAME, soName].join(':'), message);
};
var error = function error(soName, message) {
  (0, _log.error)([NAME, soName].join(':'), message);
};

var SO_SUBTYPE_PROPERTY = 4;
var SO_SUBTYPE_METHOD = 6;

var decodeMessageIfJSONString = function decodeMessageIfJSONString(message) {
  return typeof message === 'string' ? JSON.parse(message) : message;
};

var PropertyData = function () {
  function PropertyData(key, value) {
    _classCallCheck(this, PropertyData);

    this.key = key;
    this.value = value;
  }

  _createClass(PropertyData, [{
    key: 'toObject',
    value: function toObject() {
      var obj = {};
      obj[this.key] = this.value;
      return obj;
    }
  }]);

  return PropertyData;
}();

var MethodData = function () {
  function MethodData(methodName, message) {
    _classCallCheck(this, MethodData);

    this.methodName = methodName;
    var messageList = void 0;
    if (Object.prototype.toString.call(message) === '[object Array]') {
      var i = void 0;
      var msg = void 0;
      var length = message.length;
      messageList = [];
      for (i = 0; i < length; i++) {
        msg = decodeMessageIfJSONString(message[i]);
        if (Object.prototype.toString.call(message) === '[object Array]') {
          messageList = messageList.concat(msg);
        } else {
          messageList.push(msg);
        }
      }
    } else {
      messageList = [decodeMessageIfJSONString(message)];
    }
    this.message = messageList.length === 1 ? messageList[0] : messageList;
  }

  _createClass(MethodData, [{
    key: 'toObject',
    value: function toObject() {
      return {
        methodName: this.methodName,
        message: this.message
      };
    }
  }]);

  return MethodData;
}();

var Red5ProSharedObject = function (_EventEmitter) {
  _inherits(Red5ProSharedObject, _EventEmitter);

  function Red5ProSharedObject(name, connection) {
    _classCallCheck(this, Red5ProSharedObject);

    var _this = _possibleConstructorReturn(this, (Red5ProSharedObject.__proto__ || Object.getPrototypeOf(Red5ProSharedObject)).call(this));

    _this._name = name;
    _this._socket = connection.getConnection();
    _this._socket.addSharedObjectResponseHandler(_this);
    _this._onclose = _this.close.bind(_this);
    try {
      debug(_this._name, '[sharedobject:connect:attempt]');
      _this._socket.getRemoteSharedObject(_this._name);
      _browser2.default.addCloseHandler(_this._onclose, 0);
    } catch (e) {
      error(_this._name, '[sharedobject:connect:error]: ' + e.message);
    }
    return _this;
  }

  _createClass(Red5ProSharedObject, [{
    key: 'getJsonFromSocketMessage',
    value: function getJsonFromSocketMessage(message) {
      try {
        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
      } catch (e) {
        warn(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
      }
      return null;
    }
  }, {
    key: 'notifyOfPropertyValues',
    value: function notifyOfPropertyValues(valueObject) {
      if (Object.keys(valueObject).length === 0) {
        this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, {}));
      } else {
        var key = void 0;
        for (key in valueObject) {
          this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, new PropertyData(key, valueObject[key]).toObject()));
        }
      }
    }
  }, {
    key: 'notifyOfEvents',
    value: function notifyOfEvents(events) {
      var i = void 0,
          event = void 0;
      var length = events.length;
      for (i = 0; i < length; i++) {
        event = events[i];
        switch (event.subtype) {
          case SO_SUBTYPE_PROPERTY:
            this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, new PropertyData(event.attribute, event.value).toObject()));
            return true;
          case SO_SUBTYPE_METHOD:
            this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.METHOD_UPDATE, this._name, new MethodData(event.method, event.value).toObject()));
            return true;
        }
      }
      return false;
    }
  }, {
    key: 'respond',
    value: function respond(message) {
      if (message.data) {
        var json = this.getJsonFromSocketMessage(message);
        if (json === null) {
          warn(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
          return true;
        }
        if (json.data !== undefined) {
          if (json.data.name === this._name) {
            debug(this._name, '[sharedobject-response]: ' + JSON.stringify(json, null, 2));
            if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Success') {
              this._socket.connectToSharedObject(this._name);
              return true;
            } else if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Fail') {
              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_FAILURE, this._name));
              return true;
            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Success') {
              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_SUCCESS, this._name));
              return true;
            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Fail') {
              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_FAILURE, this._name));
              return true;
            } else if (json.data.type === 'sharedobject') {
              if (json.data.hasOwnProperty('events')) {
                return this.notifyOfEvents(json.data.events);
              } else if (json.data.hasOwnProperty('value')) {
                return this.notifyOfPropertyValues(json.data.value);
              }
            }
          } else {
            debug('Unhandled Socket exchange: ' + JSON.stringify(json, null, 2));
          }
        }
      }
      return false;
    }
  }, {
    key: 'send',
    value: function send(messageName, data) {
      this._socket.sendToSharedObject(this._name, messageName, data);
    }
  }, {
    key: 'setProperty',
    value: function setProperty(key, value) {
      this._socket.sendPropertyToSharedObject(this._name, key, value);
    }
  }, {
    key: 'close',
    value: function close() {
      if (this._socket === undefined) {
        warn('Socket no longer exist to close shared object properly.');
      }
      this._socket.closeSharedObject(this._name);
      if (this._socket) {
        this._socket.removeSharedObjectResponseHandler(this);
      }
      this._socket = undefined;
      this._name = undefined;
      _browser2.default.removeCloseHandler(this._onclose);
    }
  }, {
    key: 'getName',
    value: function getName() {
      return this._name;
    }
  }]);

  return Red5ProSharedObject;
}(_eventEmitter2.default);

exports.Red5ProSharedObject = Red5ProSharedObject;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _event = __webpack_require__(105);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'ControlSlider';

var ControlSlider = function (_EventEmitter) {
  _inherits(ControlSlider, _EventEmitter);

  function ControlSlider(type) {
    _classCallCheck(this, ControlSlider);

    var _this = _possibleConstructorReturn(this, (ControlSlider.__proto__ || Object.getPrototypeOf(ControlSlider)).call(this));

    NAME = [NAME, type].join('::');
    (0, _log.debug)(NAME, '[init]');
    _this._container = _browser2.default.createElement('div');
    _this._button = _this.createButton();
    _this._track = _this.createTrack();
    _this._progressBar = _this.createProgressBar();
    _this._container.appendChild(_this._track);
    _this._container.appendChild(_this._progressBar);
    _this._container.appendChild(_this._button);
    _this._value = 0; // 0 - 1
    _this._disabled = false;
    _this._eventStartPosition = 0;
    _this._layout();
    _this._mouseupHandler = _this._mouseup.bind(_this);
    _this._mousedownHandler = _this._mousedown.bind(_this);
    _this._mousemoveHandler = _this._mousemove.bind(_this);
    _this._updateHandlers(_this._disabled);
    return _this;
  }

  _createClass(ControlSlider, [{
    key: '_mouseup',
    value: function _mouseup() {
      this._eventStartPosition = 0;
      document.removeEventListener('mousemove', this._mousemoveHandler);
      document.removeEventListener('mouseup', this._mouseupHandler);
      this.trigger(new _event.SliderEvent(_event.SliderEventTypes.CHANGE_COMPLETE, this));
    }
  }, {
    key: '_mousemove',
    value: function _mousemove(event) {
      var positionOffset = _browser2.default.getMouseXFromEvent(event) - this._eventStartPosition;
      var rect = this._button.parentNode.getBoundingClientRect();
      var position = this._eventStartPosition + positionOffset - rect.left; // - environment.getScrollX()
      position = Math.max(0, position);
      position = Math.min(position, rect.width);
      var percentage = position / rect.width;
      this.trigger(new _event.SliderEvent(_event.SliderEventTypes.CHANGE, this, percentage));
    }
  }, {
    key: '_mousedown',
    value: function _mousedown(event) {
      this._eventStartPosition = _browser2.default.getMouseXFromEvent(event);
      this.trigger(new _event.SliderEvent(_event.SliderEventTypes.CHANGE_START, this));
      document.addEventListener('mousemove', this._mousemoveHandler);
      document.addEventListener('mouseup', this._mouseupHandler);
    }
  }, {
    key: '_updateHandlers',
    value: function _updateHandlers(isDisabled) {
      this._eventStartPosition = 0;
      if (isDisabled) {
        this._track.removeEventListener('click', this._mousemoveHandler);
        this._progressBar.removeEventListener('click', this._mousemoveHandler);
        this._button.removeEventListener('mousedown', this._mousedownHandler);
        document.removeEventListener('mousemove', this._mousemoveHandler);
        document.removeEventListener('mouseup', this._mouseupHandler);
        this._track.classList.add('red5pro-media-slider-disabled');
        this._progressBar.classList.add('red5pro-media-slider-disabled');
        this._button.classList.add('red5pro-media-slider-disabled');
      } else {
        this._track.addEventListener('click', this._mousemoveHandler);
        this._progressBar.addEventListener('click', this._mousemoveHandler);
        this._button.addEventListener('mousedown', this._mousedownHandler);
        this._track.classList.remove('red5pro-media-slider-disabled');
        this._progressBar.classList.remove('red5pro-media-slider-disabled');
        this._button.classList.remove('red5pro-media-slider-disabled');
      }
    }
  }, {
    key: '_layout',
    value: function _layout() {
      var position = this._progressBar.parentNode.clientWidth * this._value;
      this._progressBar.style.width = position + 'px';
      this._button.style.left = position - this._button.clientWidth * 0.5 + 'px';
    }
  }, {
    key: 'createButton',
    value: function createButton() {
      var span = _browser2.default.createElement('span');
      span.classList.add('red5pro-media-slider-button');
      return span;
    }
  }, {
    key: 'createProgressBar',
    value: function createProgressBar() {
      var span = _browser2.default.createElement('span');
      span.classList.add('red5pro-media-slider-progress');
      return span;
    }
  }, {
    key: 'createTrack',
    value: function createTrack() {
      var span = _browser2.default.createElement('span');
      span.classList.add('red5pro-media-slider-track');
      return span;
    }
  }, {
    key: 'value',
    get: function get() {
      return this._value;
    },
    set: function set(percentValue /* 0 - 1 */) {
      this._value = percentValue;
      this._layout();
    }
  }, {
    key: 'disabled',
    get: function get() {
      return this._disabled;
    },
    set: function set(bool) {
      this._disabled = bool;
      this._updateHandlers(bool);
    }
  }, {
    key: 'view',
    get: function get() {
      return this._container;
    }
  }]);

  return ControlSlider;
}(_eventEmitter2.default);

exports.default = ControlSlider;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Main entry for failover support of all subscriber implementations.
 */


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RTMPSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _red5proRtc = __webpack_require__(157);

var _red5proRtc2 = _interopRequireDefault(_red5proRtc);

var _red5proRtmp = __webpack_require__(158);

var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);

var _red5proHls = __webpack_require__(156);

var _red5proHls2 = _interopRequireDefault(_red5proHls);

var _implFactoryOrder = __webpack_require__(106);

var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);

var _promise = __webpack_require__(10);

var _playback = __webpack_require__(98);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'R5ProSubscriber';
var playbackFactory = new _implFactoryOrder2.default();

var playbackImpl = function () {
  var map = new Map();
  map.set(_playback.PlaybackTypes.RTC, _red5proRtc2.default);
  map.set(_playback.PlaybackTypes.RTMP, _red5proRtmp2.default);
  map.set(_playback.PlaybackTypes.HLS, _red5proHls2.default);
  return map;
}();

var Red5ProSubscriber = function (_EventEmitter) {
  _inherits(Red5ProSubscriber, _EventEmitter);

  function Red5ProSubscriber() {
    _classCallCheck(this, Red5ProSubscriber);

    // Configuration options
    var _this = _possibleConstructorReturn(this, (Red5ProSubscriber.__proto__ || Object.getPrototypeOf(Red5ProSubscriber)).call(this));

    _this._options = undefined;
    // The playback view
    _this._view = undefined;
    // Selected failover subscriber.
    _this._currentSubscriber = undefined;
    // Default order.
    _this._order = [_playback.PlaybackTypes.RTC, _playback.PlaybackTypes.RTMP, _playback.PlaybackTypes.HLS];
    _this._boundBubbleSubscriberEvent = _this.bubbleSubscriberEvent.bind(_this);
    return _this;
  }

  _createClass(Red5ProSubscriber, [{
    key: 'getPlaybackOrder',
    value: function getPlaybackOrder() {
      return this._order;
    }
  }, {
    key: 'setPlaybackOrder',
    value: function setPlaybackOrder(order) {
      // Allow for string value to define single item in order.
      order = typeof order === 'string' ? [order] : order;

      // Filter out values not available in enumeration of playback types.
      var t = order.filter(function (entry) {
        var key = void 0;
        for (key in _playback.PlaybackTypes) {
          if (_playback.PlaybackTypes[key].toLowerCase() === entry.toLowerCase()) {
            return true;
          }
        }
        return false;
      }).map(function (entry) {
        return entry.toLowerCase();
      }

      // Define new order.
      );this._order = [].concat(_toConsumableArray(new Set(t)));
      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
      return this;
    }
  }, {
    key: 'setView',
    value: function setView(playbackView) {
      this._view = playbackView;
      return this;
    }
  }, {
    key: 'getPlaybackFromOrder',
    value: function getPlaybackFromOrder(order, options) {
      return playbackFactory.create(order, playbackImpl, options, 'init');
    }
  }, {
    key: 'init',
    value: function init(options) {
      var _this2 = this;

      this._options = options;
      var deferred = new _promise.DeferredPromise();
      (0, _log.debug)(NAME, '[init]');
      this.getPlaybackFromOrder(this._order, this._options).then(function (subscriber) {
        (0, _log.debug)(NAME, '[init:success]: subscriber found ' + subscriber.getType());
        subscriber.on('*', _this2._boundBubbleSubscriberEvent);
        _this2._currentSubscriber = subscriber;
        if (_this2._view) {
          _this2._view.attachSubscriber(_this2._currentSubscriber);
        }
        deferred.resolve(_this2._currentSubscriber);
      }).catch(function (err) {
        (0, _log.warn)(NAME, '[playerror]: Could not implement a subscriber: ' + err);
        deferred.reject(err);
      });
      return deferred.promise;
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      var _this3 = this;

      var deferred = new _promise.DeferredPromise();
      if (!this._currentSubscriber) {
        (0, _log.warn)(NAME, '[cancel]: Could not invoke cancel() on undefined subscriber.');
        deferred.reject('A current subscriber is not available to issue a :cancel() command to.');
      } else {
        (0, _log.debug)(NAME, '[cancel]: Invoking cancel on held subscriber.');
        this._currentSubscriber.cancel().then(function () {
          (0, _log.debug)(NAME, '[stopsuccess]');
          _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
          _this3._currentSubscriber = undefined;
          deferred.resolve();
        }).catch(function (err) {
          (0, _log.debug)(NAME, '[stoperror]: ' + err);
          if (_this3._currentSubscriber) {
            _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
          }
          _this3._currentSubscriber = undefined;
          deferred.reject(err);
        });
      }
      return deferred.promise;
    }
  }, {
    key: 'bubbleSubscriberEvent',
    value: function bubbleSubscriberEvent(subscriberEvent) {
      this.trigger.call(this, subscriberEvent);
    }
  }, {
    key: 'playbackTypes',
    get: function get() {
      return _playback.PlaybackTypes;
    }
  }, {
    key: 'currentSubscriber',
    get: function get() {
      return this._currentSubscriber;
    }
  }]);

  return Red5ProSubscriber;
}(_eventEmitter2.default);

exports.Red5ProSubscriber = Red5ProSubscriber;
exports.RTCSubscriber = _red5proRtc2.default;
exports.HLSSubscriber = _red5proHls2.default;
exports.RTMPSubscriber = _red5proRtmp2.default;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _red5proSourceHandlerHls = __webpack_require__(159);

var _red5proSourceHandlerHls2 = _interopRequireDefault(_red5proSourceHandlerHls);

var _playback = __webpack_require__(56);

var _playback2 = _interopRequireDefault(_playback);

var _event = __webpack_require__(25);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'HLSSubscriber';

// Default to secure settings.
var defaultOptions = {
  protocol: 'https',
  port: 443,
  app: 'live',
  mimeType: 'application/x-mpegURL',
  mediaElementId: 'red5pro-subscriber'
};

var optionsToHlsURL = function optionsToHlsURL(options) {
  var protocol = options.hlsprotocol ? options.hlsprotocol : options.protocol;
  var port = options.hlsport ? options.hlsport : options.port;
  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '/' + options.streamName + '.m3u8';
};

var R5ProHLSSubscriber = function (_EventEmitter) {
  _inherits(R5ProHLSSubscriber, _EventEmitter);

  function R5ProHLSSubscriber() {
    _classCallCheck(this, R5ProHLSSubscriber);

    var _this = _possibleConstructorReturn(this, (R5ProHLSSubscriber.__proto__ || Object.getPrototypeOf(R5ProHLSSubscriber)).call(this));

    _this._options = undefined;
    _this._view = undefined;
    _this._sourceHandler = undefined;
    _this._viewResolver = new _promise.DeferredPromise();
    _this._subscriptionResolver = new _promise.DeferredPromise();
    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(_this);
    return _this;
  }

  _createClass(R5ProHLSSubscriber, [{
    key: '_getViewResolverPromise',
    value: function _getViewResolverPromise() {
      return this._viewResolver.promise;
    }
  }, {
    key: '_getSubscriptionResolverPromise',
    value: function _getSubscriptionResolverPromise() {
      return this._subscriptionResolver.promise;
    }
  }, {
    key: '_glomSourceHandlerAPI',
    value: function _glomSourceHandlerAPI(handler) {
      var _this2 = this;

      this.play = handler.play.bind(handler);
      this.pause = handler.pause.bind(handler);
      this.resume = handler.resume.bind(handler);
      this.stop = handler.stop.bind(handler);
      this.mute = handler.mute.bind(handler);
      this.unmute = handler.unmute.bind(handler);
      this.setVolume = handler.setVolume.bind(handler);
      this.seekTo = handler.seekTo.bind(handler);
      this.toggleFullScreen = handler.toggleFullScreen.bind(handler);
      handler.on('*', function (event) {
        _this2.trigger(new _event.SubscriberEvent(event.type, _this2, event.data));
      });
    }
  }, {
    key: '_setViewIfNotExist',
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new _playback2.default(mediaElementId);
        view.attachSubscriber(this);
      }
    }
  }, {
    key: 'bubbleSubscriberEvents',
    value: function bubbleSubscriberEvents(event) {
      if (event.type === _event.SubscriberEventTypes.SUBSCRIBE_START) {
        this._subscriptionResolver.resolve(this);
      }
      this.trigger(new _event.SubscriberEvent(event.type, this, event.data));
    }
  }, {
    key: 'init',
    value: function init(options) {
      var _this3 = this;

      var deferred = new _promise.DeferredPromise();
      if (!_browser2.default.supportsHLS()) {
        (0, _log.warn)(NAME, 'Could not resolve HLSSubscriber instance.');
        deferred.reject('Could not resolve HLSSubscriber instance.');
      } else {
        this._options = _extends({}, defaultOptions, options);
        this._setViewIfNotExist(this._view, this._options.mediaElementId);
        this._getViewResolverPromise().then(function (view) {
          _this3._sourceHandler = new _red5proSourceHandlerHls2.default(view.view, _this3.getType());
          _this3._glomSourceHandlerAPI(_this3._sourceHandler);
          if (_this3._options) {
            _this3.initHandler(_this3._options);
          }
        });
        deferred.resolve(this);
      }
      return deferred.promise;
    }
  }, {
    key: 'initHandler',
    value: function initHandler(options) {
      var _this4 = this;

      var urlRegex = /^http(|s).*\.m3u8/g;
      var url = this._options.streamName.match(urlRegex) ? this._options.streamName : optionsToHlsURL(this._options);
      this._sourceHandler.on('*', this._boundBubbleSubscriberEvents);
      this._sourceHandler.addSource(url, options.mimeType, options).then(function () {
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS));
      }).catch(function (error) {
        error(NAME, 'Could not establish an HLS Subscriber: ' + error);
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE));
      });
    }
  }, {
    key: 'setView',
    value: function setView(view) {
      this._view = view;
      this._viewResolver.resolve(view);
      return this;
    }
  }, {
    key: 'subscribe',
    value: function subscribe() {
      return this._getSubscriptionResolverPromise();
    }
  }, {
    key: 'unsubscribe',
    value: function unsubscribe() {
      (0, _log.debug)(NAME, '[unscubscribe]');
      var deferred = new _promise.DeferredPromise();
      try {
        this._sourceHandler.stop();
        this._sourceHandler.cleanUp();
        deferred.resolve();
      } catch (e) {
        deferred.reject(e.message);
      }
      return deferred.promise;
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      return this._options;
    }
  }, {
    key: 'getControls',
    value: function getControls() {
      return this._sourceHandler ? this._sourceHandler.getControls() : undefined;
    }
  }, {
    key: 'getPlayer',
    value: function getPlayer() {
      return this._view.view;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return 'HLS';
    }
  }]);

  return R5ProHLSSubscriber;
}(_eventEmitter2.default);

exports.default = R5ProHLSSubscriber;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _webrtc = __webpack_require__(54);

var webrtc = _interopRequireWildcard(_webrtc);

var _websocket = __webpack_require__(68);

var websocket = _interopRequireWildcard(_websocket);

var _red5proSourceHandlerRtc = __webpack_require__(160);

var _red5proSourceHandlerRtc2 = _interopRequireDefault(_red5proSourceHandlerRtc);

var _socketHelperSub = __webpack_require__(145);

var _socketHelperSub2 = _interopRequireDefault(_socketHelperSub);

var _webrtcHelperSub = __webpack_require__(147);

var _webrtcHelperSub2 = _interopRequireDefault(_webrtcHelperSub);

var _playback = __webpack_require__(56);

var _playback2 = _interopRequireDefault(_playback);

var _urlEndpoint = __webpack_require__(109);

var _event = __webpack_require__(25);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var subStartRegex = /(.*) starting/i;

var NAME = 'RTCSubscriber';

var generateSubscriptionId = function generateSubscriptionId() {
  var id = Math.floor(Math.random() * 0x10000).toString(16);
  return 'subscriber-' + id;
};

// Default to secure settings.
var defaultOptions = {
  protocol: 'wss',
  port: 8083,
  app: 'live',
  mediaElementId: 'red5pro-subscriber'
};

var RTCSubscriber = function (_EventEmitter) {
  _inherits(RTCSubscriber, _EventEmitter);

  function RTCSubscriber() {
    _classCallCheck(this, RTCSubscriber);

    var _this = _possibleConstructorReturn(this, (RTCSubscriber.__proto__ || Object.getPrototypeOf(RTCSubscriber)).call(this));

    _this._view = undefined;
    _this._options = undefined;
    _this._peerHelper = undefined;
    _this._socketHelper = undefined;
    _this._sourceHandler = undefined;
    _this._viewResolver = new _promise.DeferredPromise();
    _this._availabilityResolver = new _promise.DeferredPromise();
    _this._subscriptionResolver = new _promise.DeferredPromise();
    _this._orientation = 0;
    return _this;
  }

  _createClass(RTCSubscriber, [{
    key: '_getViewResolverPromise',
    value: function _getViewResolverPromise() {
      return this._viewResolver.promise;
    }
  }, {
    key: '_getAvailabilityResolverPromise',
    value: function _getAvailabilityResolverPromise() {
      return this._availabilityResolver.promise;
    }
  }, {
    key: '_getSubscriptionResolverPromise',
    value: function _getSubscriptionResolverPromise() {
      return this._subscriptionResolver.promise;
    }
  }, {
    key: '_glomSourceHandlerAPI',
    value: function _glomSourceHandlerAPI(handler) {
      var _this2 = this;

      this.play = handler.play.bind(handler);
      this.pause = handler.pause.bind(handler);
      this.resume = handler.resume.bind(handler);
      this.stop = handler.stop.bind(handler);
      this.mute = handler.mute.bind(handler);
      this.unmute = handler.unmute.bind(handler);
      this.setVolume = handler.setVolume.bind(handler);
      this.seekTo = handler.seekTo.bind(handler);
      this.toggleFullScreen = handler.toggleFullScreen.bind(handler);
      handler.on('*', function (event) {
        _this2.trigger(new _event.SubscriberEvent(event.type, _this2, event.data));
      });
    }
  }, {
    key: '_setViewIfNotExist',
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new _playback2.default(mediaElementId);
        view.attachSubscriber(this);
      }
    }
  }, {
    key: 'init',
    value: function init(options) {
      var _this3 = this;

      var deferred = new _promise.DeferredPromise();
      if (!webrtc.isSupported() || !websocket.isSupported()) {
        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
      } else {
        this._options = _extends({}, defaultOptions, options);
        this._options.subscriptionId = this._options.subscriptionId || generateSubscriptionId();

        this._peerHelper = new _webrtcHelperSub2.default(this);
        this._socketHelper = new _socketHelperSub2.default(this);
        var socketPromise = new _promise.DeferredPromise();
        var socketurl = (0, _urlEndpoint.rtcSocketEndpointFromOptions)(this._options, {
          id: this._options.subscriptionId
        });

        socketPromise.promise.then(function () {
          deferred.resolve(_this3);
          _this3.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS, _this3));
        }).catch(function (error) {
          deferred.reject(error);
          _this3.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this3, error));
        });
        this._socketHelper.setUp(socketurl, socketPromise);
      }
      return deferred.promise;
    }
  }, {
    key: 'initHandler',
    value: function initHandler(options, handler) {
      if (options && handler) {
        handler.on('*', this._boundBubbleSubscriberEvents);
        handler.addSource(options);
      }
    }
  }, {
    key: 'setView',
    value: function setView(view) {
      this._view = view;
      this._viewResolver.resolve(this._view);
      return this;
    }
  }, {
    key: 'requestAvailability',
    value: function requestAvailability(streamName) {
      (0, _log.debug)(NAME, '[requestavailability]'
      // message on socket returns -> onStream(Un)Available
      );this._socketHelper.post({
        isAvailable: streamName
      });
    }
  }, {
    key: 'requestOffer',
    value: function requestOffer(streamName, subscriptionId) {
      var vEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var aEncoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

      (0, _log.debug)(NAME, '[requestoffer]');
      var offer = {
        requestOffer: streamName,
        requestId: subscriptionId
      };
      if (typeof vEncoding !== 'undefined') {
        offer.videoEncoding = vEncoding;
      }
      if (typeof aEncoding !== 'undefined') {
        offer.audioEncoding = aEncoding;
      }
      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_START, this)
      // message on socket returns -> onSDPOffer
      );this._socketHelper.post(offer);
    }
  }, {
    key: 'requestAnswer',
    value: function requestAnswer(sdp) {
      var _this4 = this;

      (0, _log.debug)(NAME, '[requestanswer]'
      // invokes -> sendAnswer
      );this._peerHelper.createAnswer(sdp).then(function (sessionDescription) {
        (0, _log.debug)(NAME, '[onanswercreated]');
        if (_this4._options.bandwidth) {
          sessionDescription.sdp = webrtc.updateBandwidth(_this4._options.bandwidth, sessionDescription.sdp);
        }
        (0, _log.debug)(NAME, '[> sendanswer]');
        _this4.sendAnswer(_this4._options.streamName, _this4._options.subscriptionId, sessionDescription);
      }).catch(function (error) {
        _this4.onSDPError(error);
      });
    }
  }, {
    key: 'sendAnswer',
    value: function sendAnswer(streamName, subscriptionId, sdp) {
      (0, _log.debug)(NAME, '[sendanswer]: streamname(' + streamName + '), subscriptionid(' + subscriptionId + ')');
      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_START, this, sdp)
      // message on socket response -> onAddIceCandidate
      // message on peer response -> onaddstream
      );this._socketHelper.post({
        handleAnswer: streamName,
        requestId: subscriptionId,
        data: {
          sdp: sdp
        }
      });
    }
  }, {
    key: 'sendCandidate',
    value: function sendCandidate(candidate) {
      (0, _log.debug)(NAME, '[sendcandidate]');
      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_START, this, candidate)
      // message on peer response -> onicecandidate
      );this._socketHelper.post({
        handleCandidate: this._options.streamName,
        requestId: this._options.subscriptionId,
        data: {
          candidate: candidate
        }
      });
    }
  }, {
    key: 'sendSubscribe',
    value: function sendSubscribe() {
      (0, _log.debug)(NAME, '[sendsubscribe]');
      this._socketHelper.post({
        subscribe: this._options.streamName,
        requestId: this._options.subscriptionId
      });
    }
  }, {
    key: 'onStreamAvailable',
    value: function onStreamAvailable(receipt) {
      (0, _log.debug)(NAME, '[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
      this._availabilityResolver.resolve(this);
    }
  }, {
    key: 'onStreamUnavailable',
    value: function onStreamUnavailable(receipt) {
      (0, _log.debug)(NAME, 'Stream ' + this._options.streamName + ' does not exist.');
      (0, _log.debug)(NAME, '[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, this));
      this._availabilityResolver.reject('Stream ' + this._options.streamName + ' does not exist.');
      this._subscriptionResolver.reject('Stream ' + this._options.streamName + ' does not exist.');
      this._disconnect();
    }
  }, {
    key: 'onSDPSuccess',
    value: function onSDPSuccess(receipt) {
      (0, _log.debug)(NAME, '[onsdpsuccess]: ' + JSON.stringify(receipt, null, 2));
    }
  }, {
    key: 'onSDPOffer',
    value: function onSDPOffer(receipt) {
      (0, _log.debug)(NAME, '[onsdpoffer]: ' + JSON.stringify(receipt, null, 2));
      var sdp = new webrtc.RTCSessionDescription(receipt.sdp);
      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_END, this));
      this.requestAnswer(sdp);
    }
  }, {
    key: 'onSDPError',
    value: function onSDPError(receipt) {
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, receipt));
      this._subscriptionResolver.reject('Invalid SDP.');
      (0, _log.error)(NAME, '[onsdperror]');
      (0, _log.error)(receipt);
    }
  }, {
    key: 'onAnswerMediaStream',
    value: function onAnswerMediaStream() {
      var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      // eslint-disable-line no-unused-vars
      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_END, this));
    }
  }, {
    key: 'onIceCandidate',
    value: function onIceCandidate(candidate) {
      (0, _log.debug)(NAME, '[onicecandidate]');
      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_END, this));
      this.sendCandidate(candidate);
    }
  }, {
    key: 'onIceCandidateTrickleEnd',
    value: function onIceCandidateTrickleEnd(stream) {
      (0, _log.debug)(NAME, '[onicetrickleend]');
      this._getViewResolverPromise().then(function (view) {
        view.attachStream(stream);
      });
    }
  }, {
    key: 'onAddIceCandidate',
    value: function onAddIceCandidate(candidate) {
      (0, _log.debug)(NAME, '[onaddicecandidate]');
      this._peerHelper.addIceCandidate(candidate);
    }
  }, {
    key: 'onSocketIceCandidateEnd',
    value: function onSocketIceCandidateEnd() {
      (0, _log.debug)(NAME, '[onsocketicecandidateend]');
      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ICE_TRICKLE_COMPLETE, this));
      this.sendSubscribe();
    }
  }, {
    key: 'onSocketMessageError',
    value: function onSocketMessageError(message) {
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      (0, _log.error)(NAME, 'Error in stream subscription: ' + message + '.\n[Optional detail]: ' + detail);
      this._subscriptionResolver.reject('Error in stream subscription: ' + message + '.');
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, message));
    }
  }, {
    key: 'onSocketClose',
    value: function onSocketClose(closeEvent) {
      (0, _log.debug)(NAME, '[onsocketclose]');
      if (this._peerHelper) {
        this._peerHelper.tearDown();
      }
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECTION_CLOSED, this, closeEvent));
    }
  }, {
    key: 'onPeerConnectionClose',
    value: function onPeerConnectionClose(event) {
      (0, _log.debug)(NAME, '[onpeerconnectionclose]');
      if (this._socketHelper) {
        this._socketHelper.tearDown();
      }
      this.onSocketClose(event);
    }
  }, {
    key: 'onUnpublish',
    value: function onUnpublish() {
      (0, _log.debug)(NAME, '[onunpublish]');
      if (this._sourceHandler) {
        this._sourceHandler.unpublish();
      }
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAY_UNPUBLISH, this));
    }
  }, {
    key: 'onConnectionClosed',
    value: function onConnectionClosed() {
      (0, _log.debug)(NAME, '[onconnectionclosed]');
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECTION_CLOSED, this));
    }
  }, {
    key: 'onSendReceived',
    value: function onSendReceived(methodName, data) {
      if (methodName === 'onMetaData') {
        this.onMetaData(data);
      } else {
        // environment.invoke(methodName, data)
        this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_SEND_INVOKE, this, {
          methodName: methodName,
          data: data
        }));
      }
    }
  }, {
    key: 'onSubscriberStatus',
    value: function onSubscriberStatus(status) {
      (0, _log.debug)(NAME, '[subscriberstatus] - ' + JSON.stringify(status, null, 2));
      var startResult = subStartRegex.exec(status.message);
      if (startResult && startResult[1] === this._options.streamName) {
        this._subscriptionResolver.resolve(this);
        this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START, this));
        this.playIfAutoplaySet(this._options, this._view);
      }
    }
  }, {
    key: 'onMetaData',
    value: function onMetaData(metadata) {
      if (typeof metadata.orientation !== 'undefined' && metadata.orientation !== this._orientation) {
        this._orientation = metadata.orientation;
        _browser2.default.applyOrientation(this._view.view, metadata.orientation);
        if (this._sourceHandler) {
          this._sourceHandler.handleOrientationChange(parseInt(metadata.orientation));
        }
        this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.ORIENTATION_CHANGE, this, {
          orientation: parseInt(metadata.orientation),
          viewElement: this._view.view
        }));
      }
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, this, metadata));
    }
  }, {
    key: '_connect',
    value: function _connect(iceServers) {
      var _this5 = this;

      (0, _log.debug)(NAME, '[connect]');
      this._options.iceServers = iceServers;
      var p = this._peerHelper.setUp(this._options.iceServers, undefined, this._options.rtcpMuxPolicy);
      p.then(function () {
        _this5.requestOffer(_this5._options.streamName, _this5._options.subscriptionId, _this5._options.videoEncoding, _this5._options.audioEncoding);
      }).catch(function () {
        (0, _log.warn)(NAME, 'Could not establish RTCPeerConnection.');
        _this5.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this5));
      }
      //  TODO: Normalize returns to either all be chainable or not be chainable
      );return this;
    }
  }, {
    key: '_disconnect',
    value: function _disconnect() {
      (0, _log.debug)(NAME, '[disconnect]');
      if (this._socketHelper) {
        this._socketHelper.tearDown();
      }
      if (this._peerHelper) {
        this._peerHelper.tearDown();
      }
    }
  }, {
    key: 'playIfAutoplaySet',
    value: function playIfAutoplaySet(options, view) {
      if (options && view) {
        options.autoplay = _browser2.default.hasAttributeDefined(view.view, 'autoplay');
        if (options.autoplay) {
          this.play();
        }
      }
    }
  }, {
    key: 'subscribe',
    value: function subscribe() {
      var _this6 = this;

      this._getViewResolverPromise().then(function (view) {
        _this6._sourceHandler = new _red5proSourceHandlerRtc2.default(view.view, _this6.getType());
        _this6._glomSourceHandlerAPI(_this6._sourceHandler);
        _this6.initHandler(_this6._options, _this6._sourceHandler);
      });
      this._getAvailabilityResolverPromise().then(function () {
        _this6._connect(_this6._options.iceServers);
      });
      this._setViewIfNotExist(this._view, this._options.mediaElementId);
      this.requestAvailability(this._options.streamName, this._options.streamType);
      return this._getSubscriptionResolverPromise();
    }
  }, {
    key: 'unsubscribe',
    value: function unsubscribe() {
      (0, _log.debug)(NAME, '[unsubscribe]');
      var deferred = new _promise.DeferredPromise();
      this.stop();
      this._disconnect();
      this._sourceHandler.cleanUp();
      deferred.resolve(this);
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP, this));
      return deferred.promise;
    }
  }, {
    key: 'getConnection',
    value: function getConnection() {
      return this._socketHelper;
    }
  }, {
    key: 'getPeerConnection',
    value: function getPeerConnection() {
      return this._peerHelper ? this._peerHelper.connection : undefined;
    }
  }, {
    key: 'getControls',
    value: function getControls() {
      return this._sourceHandler ? this._sourceHandler.getControls() : undefined;
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      return this._options;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return 'RTC';
    }
  }]);

  return RTCSubscriber;
}(_eventEmitter2.default);

exports.default = RTCSubscriber;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _red5proSourceHandlerRtmp = __webpack_require__(161);

var _red5proSourceHandlerRtmp2 = _interopRequireDefault(_red5proSourceHandlerRtmp);

var _playback = __webpack_require__(56);

var _playback2 = _interopRequireDefault(_playback);

var _event = __webpack_require__(25);

var _promise = __webpack_require__(10);

var _state = __webpack_require__(50);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'RTMPSubcriber';

var defaultOptions = {
  protocol: 'rtmp',
  port: 1935,
  width: 320, // media playback
  height: 240, // media playback
  embedWidth: '100%', // DOM display style
  embedHeight: '100%', // DOM display style
  minFlashVersion: '10.0.0',
  swf: 'lib/red5pro/red5pro-subscriber.swf',
  swfobjectURL: 'lib/swfobject/swfobject.js',
  productInstallUrl: 'lib/swfobject/playerProductInstall.swf',
  mediaElementId: 'red5pro-subscriber'
};

var RTMPSubscriber = function (_EventEmitter) {
  _inherits(RTMPSubscriber, _EventEmitter);

  function RTMPSubscriber() {
    _classCallCheck(this, RTMPSubscriber);

    var _this = _possibleConstructorReturn(this, (RTMPSubscriber.__proto__ || Object.getPrototypeOf(RTMPSubscriber)).call(this));

    _this._options = undefined;
    _this._view = undefined;
    _this._sourceHandler = undefined;
    _this._elementId = undefined;
    _this._embedPromise = undefined;
    _this._getEmbedPromise().then(function () {
      _this.onEmbedComplete();
    }).catch(function (err) {
      return _this.onEmbedFailure(err);
    });
    _this._viewResolver = new _promise.DeferredPromise();
    _this._subscriptionResolver = new _promise.DeferredPromise();
    return _this;
  }

  _createClass(RTMPSubscriber, [{
    key: '_getViewResolverPromise',
    value: function _getViewResolverPromise() {
      return this._viewResolver.promise;
    }
  }, {
    key: '_getSubscriptionResolverPromise',
    value: function _getSubscriptionResolverPromise() {
      return this._subscriptionResolver.promise;
    }
  }, {
    key: '_glomSourceHandlerAPI',
    value: function _glomSourceHandlerAPI(handler) {
      var _this2 = this;

      this.pause = handler.pause.bind(handler);
      this.resume = handler.resume.bind(handler);
      this.stop = handler.stop.bind(handler);
      this.mute = handler.mute.bind(handler);
      this.unmute = handler.unmute.bind(handler);
      this.setVolume = handler.setVolume.bind(handler);
      this.seekTo = handler.seekTo.bind(handler);
      this.toggleFullScreen = handler.toggleFullScreen.bind(handler);
      handler.on('*', function (event) {
        _this2.trigger(new _event.SubscriberEvent(event.type, _this2, event.data));
      });
    }
  }, {
    key: '_getEmbedPromise',
    value: function _getEmbedPromise() {
      this._embedPromise = _promise.Future.createIfNotExist(this._embedPromise);
      return this._embedPromise.promise;
    }
  }, {
    key: '_setViewIfNotExist',
    value: function _setViewIfNotExist(currentView) {
      var mediaElementId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (typeof currentView === 'undefined' && mediaElementId !== undefined) {
        var view = new _playback2.default(mediaElementId);
        view.attachSubscriber(this);
      }
    }
  }, {
    key: 'init',
    value: function init(options) {
      var _this3 = this;

      var deferred = new _promise.DeferredPromise();
      var version = options.minFlashVersion || defaultOptions.minFlashVersion;
      if (!_browser2.default.supportsFlashVersion(version)) {
        (0, _log.warn)(NAME, 'Could not resolve RTMPSubscriber instance. Requires minimum Flash Player install of ' + version + '.');
        deferred.reject('Could not resolve RTMPSubscriber instance. Requires minimum Flash Player install of ' + version + '.');
      } else {
        this._options = _extends({}, defaultOptions, options);

        var establishSourceHandler = function establishSourceHandler() {
          _this3._getViewResolverPromise().then(function (view) {
            _this3._sourceHandler = new _red5proSourceHandlerRtmp2.default(_this3, view.view, _this3.getType());
            _this3._glomSourceHandlerAPI(_this3._sourceHandler);
            if (_this3._options) {
              var dfd = _this3._embedPromise;
              _this3._sourceHandler.addSource(_this3._elementId, _this3._options).then(function (subscriberId) {
                _this3._establishExtIntHandlers(subscriberId);
                dfd.resolve(_this3);
              }).catch(function (err) {
                return dfd.reject(err);
              });
            }
          });
        };

        try {
          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
            var embedDfd = _this3._embedPromise;
            (0, _log.debug)(NAME, 'SWFObject embedded.');
            if (_this3._sourceHandler) {
              _this3._sourceHandler.addSource(_this3._elementId, _this3._options).then(function (subscriberId) {
                _this3._establishExtIntHandlers(subscriberId);
                embedDfd.resolve(_this3);
              }).catch(function (err) {
                embedDfd.reject(err);
              });
              return _this3._getEmbedPromise();
            }
            establishSourceHandler();
            return true;
          }).then(function () {
            _this3._setViewIfNotExist(_this3._view, _this3._options.mediaElementId);
            deferred.resolve(_this3);
          }).catch(function (err) {
            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Player. Reason: ' + err);
            if (_this3._sourceHandler) {
              _this3._sourceHandler.disconnect();
            }
            deferred.reject(err);
            _this3.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, _this3));
          });
        } catch (e) {
          deferred.reject('Could not inject Flash-based Player into the page. Reason: ' + e.message);
          this.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, this));
        }
      }
      return deferred.promise;
    }
  }, {
    key: '_establishExtIntHandlers',
    value: function _establishExtIntHandlers(id) {
      var _this4 = this;

      (0, _log.debug)(NAME, 'Subscriber ID provided to client: (' + id + ').');
      var invokeFn = function invokeFn(label) {
        return ['subscriber', label, id].join('_');
      };
      window[invokeFn('r5proConnectClosed')] = function () {
        return _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECTION_CLOSED, _this4));
      };
      window[invokeFn('r5proConnectSuccess')] = function () {
        return _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS, _this4));
      };
      window[invokeFn('r5proConnectFailure')] = function () {
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this4));
      };
      window[invokeFn('r5proSubscribeStop')] = function () {
        return _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP, _this4));
      };
      window[invokeFn('r5proSubscribeMetadata')] = function (metadata) {
        return _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, _this4, JSON.parse(metadata)));
      };
      window[invokeFn('r5proSubscribeUnpublish')] = function () {
        return _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAY_UNPUBLISH, _this4));
      };
      window[invokeFn('r5proSubscribeSendInvoke')] = function (payload) {
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_SEND_INVOKE, _this4, typeof payload === 'string' ? JSON.parse(payload) : payload));
      };
      window[invokeFn('r5proSubscribePlayRequest')] = function () {
        _this4.play();
      };
      window[invokeFn('r5proSubscribeStart')] = function () {
        _this4._subscriptionResolver.resolve(_this4);
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START, _this4));
      };
      window[invokeFn('r5proSubscribeInvalidName')] = function () {
        _this4._subscriptionResolver.reject(_this4);
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, _this4));
      };
      window[invokeFn('r5proSubscribeFail')] = function () {
        _this4._subscriptionResolver.reject(_this4);
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, _this4));
      };
      window[invokeFn('r5proSubscribeVolumeChange')] = function (payload) {
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.VOLUME_CHANGE, _this4, {
          volume: JSON.parse(payload).volume
        }));
      };
      window[invokeFn('r5proSubscribePlaybackTimeChange')] = function (payload) {
        var data = JSON.parse(payload);
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_TIME_UPDATE, _this4, {
          time: data.value,
          duration: data.duration
        }));
      };
      window[invokeFn('r5proSubscribePlaybackStateChange')] = function (payload) {
        var code = JSON.parse(payload).code;
        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, _this4, {
          code: code,
          state: _state.PlaybackStateReadable[code]
        }));
      };
    }
  }, {
    key: 'onEmbedComplete',
    value: function onEmbedComplete() {
      (0, _log.debug)(NAME, '[embed:complete]');
      this.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_SUCCESS, this));
    }
  }, {
    key: 'onEmbedFailure',
    value: function onEmbedFailure(err) {
      (0, _log.debug)(NAME, '[embed:failure] - ' + err);
      this.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, this));
    }
  }, {
    key: 'setView',
    value: function setView(view, elementId) {
      this._view = view;
      this._elementId = elementId;
      this._viewResolver.resolve(this._view);
      return this;
    }
  }, {
    key: 'play',
    value: function play() {
      var _this5 = this;

      (0, _log.debug)(NAME, '[play]');
      this._getEmbedPromise().then(function () {
        _this5._sourceHandler.play();
      });
    }
  }, {
    key: 'subscribe',
    value: function subscribe() {
      return this._getSubscriptionResolverPromise();
    }
  }, {
    key: 'unsubscribe',
    value: function unsubscribe() {
      var _this6 = this;

      (0, _log.debug)(NAME, '[unsubscribe]');
      var cb = function cb(resolve, reject) {
        try {
          _this6._sourceHandler.disconnect();
          _this6._sourceHandler.cleanUp();
          resolve();
        } catch (e) {
          reject(e.message);
        }
      };
      return new Promise(cb);
    }
  }, {
    key: 'getConnection',
    value: function getConnection() {
      return this._sourceHandler;
    }
  }, {
    key: 'getControls',
    value: function getControls() {
      return this._sourceHandler ? this._sourceHandler.getControls() : undefined;
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      return this._options;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return 'RTMP';
    }
  }]);

  return RTMPSubscriber;
}(_eventEmitter2.default);

exports.default = RTMPSubscriber;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _controls = __webpack_require__(55);

var _state = __webpack_require__(50);

var _event = __webpack_require__(25);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'HLSSourceHandler';

var HLSSourceHandler = function (_EventEmitter) {
  _inherits(HLSSourceHandler, _EventEmitter);

  function HLSSourceHandler(media, type) {
    _classCallCheck(this, HLSSourceHandler);

    var _this = _possibleConstructorReturn(this, (HLSSourceHandler.__proto__ || Object.getPrototypeOf(HLSSourceHandler)).call(this));

    _this.media = media;
    _this.clone = _this.media.cloneNode(true);
    _this.holder = _this.determineHolder(media);
    _this.playerType = type;
    _this._isVOD = false;
    _this._controls = undefined;
    _this._playbackNotificationCenter = _this.media;
    _browser2.default.onFullScreenStateChange(_this._handleFullScreenChange.bind(_this));
    return _this;
  }

  _createClass(HLSSourceHandler, [{
    key: 'determineHolder',
    value: function determineHolder(media) {
      if (media.parentNode.classList.contains('red5pro-media-container')) {
        return media.parentNode;
      } else {
        var parent = media.parentNode;
        var div = _browser2.default.createElement('div');
        div.classList.add('red5pro-media-container');
        parent.insertBefore(div, media);
        parent.removeChild(media);
        div.appendChild(media);
        return div;
      }
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      // Return to prior DOM manipulation.
      this.media.remove();
      this.media = this.clone.cloneNode(true);
      this.holder.appendChild(this.media);
    }
  }, {
    key: '_addPlaybackHandlers',
    value: function _addPlaybackHandlers(notifier) {
      var _this2 = this;

      var controls = this.getControls();
      var hasControls = typeof controls !== 'undefined';

      notifier.oncanplay = function () {
        if (controls) {
          controls.enablePlayPause(true);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.AVAILABLE,
          state: _state.PlaybackStateReadable[_state.PlaybackState.AVAILABLE]
        }));
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.volume
        }));
      };
      notifier.ondurationchange = function (event) {
        // eslint-disable-line no-unused-vars
        if (!isNaN(notifier.duration) && Number.isFinite(notifier.duration)) {
          _this2.isVOD = true;
        }
        if (hasControls) {
          controls.setPlaybackDuration(notifier.duration);
        }
      };
      notifier.onended = function () {
        if (hasControls) {
          controls.setState(_state.PlaybackState.IDLE);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.IDLE,
          state: _state.PlaybackStateReadable[_state.PlaybackState.IDLE]
        }));
      };
      notifier.ontimeupdate = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls) {
          controls.setSeekTime(notifier.currentTime, self.isVOD ? notifier.duration : undefined);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_TIME_UPDATE, undefined, {
          time: notifier.currentTime,
          duration: notifier.duration
        }));
      };
      notifier.onseeked = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeked.')
      };
      notifier.onseeking = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeking.')
      };
      notifier.onplay = function () {
        if (hasControls) {
          controls.setState(_state.PlaybackState.PLAYING);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.PLAYING,
          state: _state.PlaybackStateReadable[_state.PlaybackState.PLAYING]
        }));
      };
      notifier.onpause = function () {
        if (hasControls) {
          controls.setState(_state.PlaybackState.PAUSED);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.PAUSED,
          state: _state.PlaybackStateReadable[_state.PlaybackState.PAUSED]
        }));
      };
      notifier.onvolumechange = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls && controls.getVolume() !== _this2.media.volume) {
          controls.setVolume(_this2.media.volume);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.muted ? 0 : notifier.volume
        }));
      };
    }
  }, {
    key: '_handleFullScreenChange',
    value: function _handleFullScreenChange(isFullScreen) {
      if (isFullScreen) {
        this.holder.classList.add('red5pro-media-container-full-screen');
        this.media.classList.add('red5pro-media-container-full-screen');
      } else {
        this.holder.classList.remove('red5pro-media-container-full-screen');
        this.media.classList.remove('red5pro-media-container-full-screen');
      }
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, undefined, isFullScreen));
    }
  }, {
    key: 'embedMediaSource',
    value: function embedMediaSource(url, type, options) {
      // eslint-disable-line no-unused-vars
      var self = this;
      var deferred = new _promise.DeferredPromise();
      try {
        var source = _browser2.default.createElement('source');
        source.type = type;
        source.src = url;
        if (this.media.firstChild) {
          this.media.insertBefore(source, this.media.firstChild);
        } else {
          this.media.appendChild(source);
        }
        self.orientation = 0;
        _browser2.default.onOrientationMetadata(this.media, function (metadata) {
          (0, _log.debug)(NAME, 'Metadata received: ' + JSON.stringify(metadata, null, 2));
          if (self.orientation !== metadata.orientation) {
            self.orientation = metadata.orientation;
            _browser2.default.applyOrientation(self.media, metadata.orientation);
            self.handleOrientationChange(parseInt(self.orientation));
            self.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.ORIENTATION_CHANGE, undefined, {
              orientation: parseInt(self.orientation),
              viewElement: self.media
            }));
            self.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, undefined, metadata));
          }
          self.orientation = metadata.orientation;
        });
        deferred.resolve();
      } catch (e) {
        deferred.reject(e.message);
      }
      return deferred.promise;
    }
  }, {
    key: 'addSource',
    value: function addSource(url, type, options) {
      var _this3 = this;

      (0, _log.debug)(NAME, '[addsource]');
      var deferred = new _promise.DeferredPromise();
      var hasDefinedControls = options.controls;
      var isMuted = _browser2.default.hasAttributeDefined(this.media, 'muted');
      var usePlaybackControls = _browser2.default.hasAttributeDefined(this.media, 'controls') && _browser2.default.hasClassDefined(this.media, 'red5pro-media');
      this.embedMediaSource(url, type, options).then(function () {
        if (hasDefinedControls || usePlaybackControls) {
          if (hasDefinedControls) {
            _this3._controls = options.controls;
          } else {
            _this3._controls = new _controls.PlaybackControlsImpl(_this3, _this3.holder);
          }
          _this3.media.controls = false;
          _this3._controls.setAsVOD(_this3.isVOD);
          _this3._controls.setMutedState(isMuted);
        }
        _this3._addPlaybackHandlers(_this3._playbackNotificationCenter);
        deferred.resolve();
      }).catch(function (e) {
        return deferred.reject(e);
      });
      return deferred.promise;
    }
  }, {
    key: 'connect',
    value: function connect() {
      (0, _log.debug)(NAME, '[connect]');
    }
  }, {
    key: 'play',
    value: function play() {
      this.media.play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.media.pause();
    }
  }, {
    key: 'resume',
    value: function resume() {
      this.media.play();
    }
  }, {
    key: 'stop',
    value: function stop() {
      try {
        this.media.stop();
      } catch (e) {
        // ok.
      }
    }
  }, {
    key: 'mute',
    value: function mute() {
      this.media.muted = true;
    }
  }, {
    key: 'unmute',
    value: function unmute() {
      this.media.muted = false;
    }

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'setVolume',
    value: function setVolume(value) {
      this.unmute();
      this.media.volume = value;
    }

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'seekTo',
    value: function seekTo(percentage) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      this.media.currentTime = duration ? percentage * duration : percentage;
    }
  }, {
    key: 'toggleFullScreen',
    value: function toggleFullScreen() {
      try {
        _browser2.default.toggleFullScreen(this.holder);
      } catch (e) {
        throw e;
        // nada.
      }
    }
  }, {
    key: 'unpublish',
    value: function unpublish() {
      try {
        this.stop();
        this.media.onended.call(this.media);
      } catch (e) {
        // nada.
      }
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      (0, _log.debug)(NAME, '[disconnect]');
      this.cleanUp();
    }
  }, {
    key: 'handleOrientationChange',
    value: function handleOrientationChange(orientation) {
      if (this._controls && orientation % 180 !== 0) {
        this.holder.classList.add('red5pro-media-background');
        this.media.classList.remove('red5pro-media-background');
      }
    }

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'addSharedObjectResponseHandler',
    value: function addSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'removeSharedObjectResponseHandler',
    value: function removeSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'sendToSharedObject',
    value: function sendToSharedObject(name, callName, message) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'sendPropertyToSharedObject',
    value: function sendPropertyToSharedObject(name, key, value) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'getRemoteSharedObject',
    value: function getRemoteSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'connectToSharedObject',
    value: function connectToSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'closeSharedObject',
    value: function closeSharedObject(sharedObjectName) {}
  }, {
    key: 'getControls',
    value: function getControls() {
      return this._controls;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.playerType;
    }
  }, {
    key: 'isVOD',
    get: function get() {
      return this._isVOD;
    },
    set: function set(value) {
      this._isVOD = value;
      if (this._controls) {
        this._controls.setAsVOD(value);
      }
    }
  }]);

  return HLSSourceHandler;
}(_eventEmitter2.default);

exports.default = HLSSourceHandler;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _controls = __webpack_require__(55);

var _state = __webpack_require__(50);

var _event = __webpack_require__(25);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'RTCSourceHandler';

var RTCSourceHandler = function (_EventEmitter) {
  _inherits(RTCSourceHandler, _EventEmitter);

  function RTCSourceHandler(media, type) {
    _classCallCheck(this, RTCSourceHandler);

    var _this = _possibleConstructorReturn(this, (RTCSourceHandler.__proto__ || Object.getPrototypeOf(RTCSourceHandler)).call(this));

    _this.media = media;
    _this.clone = _this.media.cloneNode(true);
    _this.holder = _this.determineHolder(_this.media);
    _this.playerType = type;
    _this._isVOD = false;
    _this._controls = undefined;
    _this._playbackNotificationCenter = _this.media;
    _browser2.default.onFullScreenStateChange(_this._handleFullScreenChange.bind(_this));
    return _this;
  }

  _createClass(RTCSourceHandler, [{
    key: 'determineHolder',
    value: function determineHolder(media) {
      if (media.parentNode.classList.contains('red5pro-media-container')) {
        return media.parentNode;
      } else {
        var parent = media.parentNode;
        var div = _browser2.default.createElement('div');
        div.classList.add('red5pro-media-container');
        parent.insertBefore(div, media);
        parent.removeChild(media);
        div.appendChild(media);
        return div;
      }
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      // Return to prior DOM manipulation.
      this.media.remove();
      this.media = this.clone.cloneNode(true);
      this.holder.appendChild(this.media);
    }
  }, {
    key: '_addPlaybackHandlers',
    value: function _addPlaybackHandlers(notifier) {
      var _this2 = this;

      var controls = this.getControls();
      var hasControls = typeof controls !== 'undefined';

      notifier.oncanplay = function () {
        if (controls) {
          controls.enablePlayPause(true);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.AVAILABLE,
          state: _state.PlaybackStateReadable[_state.PlaybackState.AVAILABLE]
        }));
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.volume
        }));
      };
      notifier.ondurationchange = function (event) {
        // eslint-disable-line no-unused-vars
        if (!isNaN(notifier.duration) && Number.isFinite(notifier.duration)) {
          _this2.isVOD = true;
        }
        if (hasControls) {
          controls.setPlaybackDuration(notifier.duration);
        }
      };
      notifier.onended = function () {
        if (hasControls) {
          controls.setState(_state.PlaybackState.IDLE);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.IDLE,
          state: _state.PlaybackStateReadable[_state.PlaybackState.IDLE]
        }));
      };
      notifier.ontimeupdate = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls) {
          controls.setSeekTime(notifier.currentTime, self.isVOD ? notifier.duration : undefined);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_TIME_UPDATE, undefined, {
          time: notifier.currentTime,
          duration: notifier.duration
        }));
      };
      notifier.onseeked = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeked.')
      };
      notifier.onseeking = function (event) {// eslint-disable-line no-unused-vars
        //      debug(NAME, 'Seeking.')
      };
      notifier.onplay = function () {
        if (hasControls) {
          controls.setState(_state.PlaybackState.PLAYING);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.PLAYING,
          state: _state.PlaybackStateReadable[_state.PlaybackState.PLAYING]
        }));
      };
      notifier.onpause = function () {
        if (hasControls) {
          controls.setState(_state.PlaybackState.PAUSED);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.PAUSED,
          state: _state.PlaybackStateReadable[_state.PlaybackState.PAUSED]
        }));
      };
      notifier.onvolumechange = function (event) {
        // eslint-disable-line no-unused-vars
        if (hasControls && controls.getVolume() !== _this2.media.volume) {
          controls.setVolume(_this2.media.volume);
        }
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.VOLUME_CHANGE, undefined, {
          volume: notifier.muted ? 0 : notifier.volume
        }));
      };
    }
  }, {
    key: '_handleFullScreenChange',
    value: function _handleFullScreenChange(isFullScreen) {
      if (isFullScreen) {
        this.holder.classList.add('red5pro-media-container-full-screen');
        this.media.classList.add('red5pro-media-container-full-screen');
      } else {
        this.holder.classList.remove('red5pro-media-container-full-screen');
        this.media.classList.remove('red5pro-media-container-full-screen');
      }
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, undefined, isFullScreen));
    }
  }, {
    key: 'addSource',
    value: function addSource(options) {
      (0, _log.debug)(NAME, '[addsource]');
      var deferred = new _promise.DeferredPromise();
      var hasDefinedControls = options.controls;
      var isMuted = _browser2.default.hasAttributeDefined(this.media, 'muted');
      var usePlaybackControls = _browser2.default.hasAttributeDefined(this.media, 'controls') && _browser2.default.hasClassDefined(this.media, 'red5pro-media');
      if (hasDefinedControls || usePlaybackControls) {
        if (hasDefinedControls) {
          this._controls = options.controls;
        } else {
          this._controls = new _controls.PlaybackControlsImpl(this, this.holder);
        }
        this.media.controls = false;
        this._controls.setAsVOD(this.isVOD);
        this._controls.setMutedState(isMuted);
      }
      this._addPlaybackHandlers(this._playbackNotificationCenter);
      deferred.resolve();
      return deferred.promise;
    }
  }, {
    key: 'connect',
    value: function connect() {
      (0, _log.debug)(NAME, '[connect]');
    }
  }, {
    key: 'play',
    value: function play() {
      this.media.play();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this.media.pause();
    }
  }, {
    key: 'resume',
    value: function resume() {
      this.media.play();
    }
  }, {
    key: 'stop',
    value: function stop() {
      try {
        this.media.stop();
      } catch (e) {
        // ok.
      }
    }
  }, {
    key: 'mute',
    value: function mute() {
      this.media.muted = true;
    }
  }, {
    key: 'unmute',
    value: function unmute() {
      this.media.muted = false;
    }

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'setVolume',
    value: function setVolume(value) {
      this.unmute();
      this.media.volume = value;
    }

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'seekTo',
    value: function seekTo(percentage) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      this.media.currentTime = duration ? percentage * duration : percentage;
    }
  }, {
    key: 'toggleFullScreen',
    value: function toggleFullScreen() {
      try {
        _browser2.default.toggleFullScreen(this.holder);
      } catch (e) {
        throw e;
        // nada.
      }
    }
  }, {
    key: 'unpublish',
    value: function unpublish() {
      try {
        this.stop();
        this.media.onended.call(this.media);
      } catch (e) {
        // nada.
      }
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      (0, _log.debug)(NAME, '[disconnect]');
      this.cleanUp();
    }
  }, {
    key: 'handleOrientationChange',
    value: function handleOrientationChange(orientation) {
      if (this._controls && orientation % 180 !== 0) {
        this.holder.classList.add('red5pro-media-background');
        this.media.classList.remove('red5pro-media-background');
      }
    }

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'addSharedObjectResponseHandler',
    value: function addSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'removeSharedObjectResponseHandler',
    value: function removeSharedObjectResponseHandler(handler) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'sendToSharedObject',
    value: function sendToSharedObject(name, callName, message) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'sendPropertyToSharedObject',
    value: function sendPropertyToSharedObject(name, key, value) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'getRemoteSharedObject',
    value: function getRemoteSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'connectToSharedObject',
    value: function connectToSharedObject(sharedObjectName) {}

    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'closeSharedObject',
    value: function closeSharedObject(sharedObjectName) {}
  }, {
    key: 'getControls',
    value: function getControls() {
      return this._controls;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.playerType;
    }
  }, {
    key: 'isVOD',
    get: function get() {
      return this._isVOD;
    },
    set: function set(value) {
      this._isVOD = value;
      if (this._controls) {
        this._controls.setAsVOD(value);
      }
    }
  }]);

  return RTCSourceHandler;
}(_eventEmitter2.default);

exports.default = RTCSourceHandler;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _eventEmitter = __webpack_require__(19);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

var _embed = __webpack_require__(99);

var embed = _interopRequireWildcard(_embed);

var _browser = __webpack_require__(9);

var _browser2 = _interopRequireDefault(_browser);

var _sharedobjectHelperRtmp = __webpack_require__(102);

var _sharedobjectHelperRtmp2 = _interopRequireDefault(_sharedobjectHelperRtmp);

var _controls = __webpack_require__(55);

var _state = __webpack_require__(50);

var _event = __webpack_require__(25);

var _promise = __webpack_require__(10);

var _log = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NAME = 'RTMPSourceHandler';

var toInt = function toInt(value) {
  if (typeof value === 'string') {
    return value.parseInt(10);
  } else {
    return Math.round(value);
  }
};

var isVODStreamName = function isVODStreamName(streamName) {
  return (/^.*\.(flv|mp4|mp3)/.test(streamName)
  );
};

var RTMPSourceHandler = function (_EventEmitter) {
  _inherits(RTMPSourceHandler, _EventEmitter);

  function RTMPSourceHandler(notificationCenter, media, type) {
    var soResponder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

    _classCallCheck(this, RTMPSourceHandler);

    var _this = _possibleConstructorReturn(this, (RTMPSourceHandler.__proto__ || Object.getPrototypeOf(RTMPSourceHandler)).call(this));

    _this.media = media;
    _this.clone = _this.media.cloneNode(true);
    _this.holder = _this.determineHolder(_this.media);
    _this.playerType = type;
    _this._swfId = undefined;
    _this._controls = undefined;
    _this._soResponder = soResponder || new _sharedobjectHelperRtmp2.default();
    _this._playbackNotificationCenter = notificationCenter;
    _browser2.default.onFullScreenStateChange(_this._handleFullScreenChange.bind(_this));
    return _this;
  }

  _createClass(RTMPSourceHandler, [{
    key: 'determineHolder',
    value: function determineHolder(media) {
      if (media.parentNode.classList.contains('red5pro-media-container')) {
        return media.parentNode;
      } else {
        var parent = media.parentNode;
        var div = _browser2.default.createElement('div');
        div.classList.add('red5pro-media-container');
        parent.insertBefore(div, media);
        parent.removeChild(media);
        div.appendChild(media);
        return div;
      }
    }
  }, {
    key: 'cleanUp',
    value: function cleanUp() {
      // Return to prior DOM manipulation.
      this.media.remove();
      this.media = this.clone.cloneNode(true);
      this.holder.appendChild(this.media);
    }
  }, {
    key: '_addPlaybackHandlers',
    value: function _addPlaybackHandlers(notifier) {
      var controls = this.getControls();
      if (typeof controls === 'undefined') {
        return;
      }
      notifier.on(_event.SubscriberEventTypes.SUBSCRIBE_START, function () {
        controls.setState(_state.PlaybackState.PLAYING);
      });
      notifier.on(_event.SubscriberEventTypes.SUBSCRIBE_STOP, function () {
        controls.setState(_state.PlaybackState.IDLE);
      });
      notifier.on(_event.SubscriberEventTypes.PLAY_UNPUBLISH, function () {
        controls.setState(_state.PlaybackState.IDLE);
      });
      notifier.on(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, function (event) {
        if (event.data.duration) {
          controls.setPlaybackDuration(event.data.duration);
        }
      });
      notifier.on(_event.SubscriberEventTypes.VOLUME_CHANGE, function (event) {
        controls.setVolume(event.data.volume);
      });
      notifier.on(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, function (event) {
        if (event.data.code === _state.PlaybackState.AVAILABLE) {
          controls.enablePlayPause(true);
        }
        controls.setState(event.data.code);
      });
      notifier.on(_event.SubscriberEventTypes.PLAYBACK_TIME_UPDATE, function (event) {
        controls.setSeekTime(event.data.time, event.data.duration);
      });
      notifier.on(_event.SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, function (event) {
        controls.onFullScreenChange(event.data);
      });
    }
  }, {
    key: '_handleFullScreenChange',
    value: function _handleFullScreenChange(isFullScreen) {
      var swfobject = this.getEmbeddedView();
      if (isFullScreen) {
        this.holder.classList.add('red5pro-media-container-full-screen');
        swfobject.classList.add('red5pro-media-container-full-screen');
      } else {
        this.holder.classList.remove('red5pro-media-container-full-screen');
        swfobject.classList.remove('red5pro-media-container-full-screen');
      }
      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.FULL_SCREEN_STATE_CHANGE, undefined, isFullScreen));
    }
  }, {
    key: '_setUpInitCallback',
    value: function _setUpInitCallback(promise) {
      var self = this;
      _browser2.default.addSubscriptionAssignmentHandler(function (successId) {
        (0, _log.debug)(NAME, 'Embed and init() complete for subscriber swf. successId(' + successId + ').');
        promise.resolve(successId);
        self._tearDownInitCallback();
      });
    }
  }, {
    key: '_tearDownInitCallback',
    value: function _tearDownInitCallback() {}
  }, {
    key: 'addSource',
    value: function addSource(swfId, options) {
      var _this2 = this;

      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      (0, _log.debug)(NAME, '[addsource]');
      this._swfId = swfId;
      var soResponder = this._soResponder;
      var deferred = new _promise.DeferredPromise();
      var hasDefinedControls = options.controls;
      var isMuted = _browser2.default.hasAttributeDefined(this.media, 'muted');
      var usePlaybackControls = _browser2.default.hasAttributeDefined(this.media, 'controls') && _browser2.default.hasClassDefined(this.media, 'red5pro-media');
      options.swf = swfUrl || options.swf;
      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
      this._setUpInitCallback(deferred);
      var classList = this.media.classList;
      embed.defineEmbedElement(this.media, this.holder).then(function (elementId) {
        var flashvars = {
          stream: options.streamName,
          app: options.context ? options.app + '/' + options.context : options.app,
          host: options.host,
          muted: _browser2.default.hasAttributeDefined(_this2.media, 'muted'),
          autoplay: _browser2.default.hasAttributeDefined(_this2.media, 'autoplay')
        };
        if (options.backgroundColor) {
          flashvars.backgroundColor = options.backgroundColor;
        }
        if (options.buffer && !isNaN(Number(options.buffer))) {
          flashvars.buffer = options.buffer;
        }
        if (options.width && !isNaN(options.width)) {
          flashvars.width = toInt(options.width);
        }
        if (options.height && !isNaN(options.height)) {
          flashvars.height = toInt(options.height);
        }
        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
          flashvars.autosize = true;
        }
        _this2._swfId = swfId;
        if (typeof options.connectionParams !== 'undefined') {
          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
        }
        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
      }).then(function () {
        if (hasDefinedControls || usePlaybackControls) {
          if (hasDefinedControls) {
            _this2._controls = options.controls;
          } else {
            _this2._controls = new _controls.PlaybackControlsImpl(_this2, _this2.holder);
          }
          _this2.media.controls = false;
          _this2._controls.setAsVOD(isVODStreamName(options.streamName));
          _this2._controls.setMutedState(isMuted);
          var embedded = _this2.getEmbeddedView();
          var index = classList.length,
              clazz = void 0;
          while (--index > -1) {
            clazz = classList.item(index);
            embedded.classList.add(clazz);
          }
        }
        _this2._addPlaybackHandlers(_this2._playbackNotificationCenter);
        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAYBACK_STATE_CHANGE, undefined, {
          code: _state.PlaybackState.AVAILABLE,
          state: _state.PlaybackStateReadable[_state.PlaybackState.AVAILABLE]
        }));
        return true;
      }).then(function () {
        soResponder.connect(swfId);
        return true;
      }).catch(function (e) {
        return deferred.reject(e);
      });
      return deferred.promise;
    }
  }, {
    key: 'connect',
    value: function connect() {
      (0, _log.debug)(NAME, '[connect]');
      try {
        this.getEmbeddedView().connect();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'play',
    value: function play() {
      try {
        this.getEmbeddedView().play();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'pause',
    value: function pause() {
      try {
        this.getEmbeddedView().pause();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'resume',
    value: function resume() {
      try {
        this.getEmbeddedView().resume();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      try {
        this.getEmbeddedView().stop();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'mute',
    value: function mute() {
      try {
        this.getEmbeddedView().mute();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'unmute',
    value: function unmute() {
      try {
        this.getEmbeddedView().unmute();
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'setVolume',
    value: function setVolume(value) {
      try {
        this.getEmbeddedView().setVolume(value);
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'seekTo',
    value: function seekTo(value) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      try {
        this.getEmbeddedView().seekTo(value, duration);
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'toggleFullScreen',
    value: function toggleFullScreen() {
      try {
        _browser2.default.toggleFullScreen(this.holder);
      } catch (e) {
        throw e;
      }
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      (0, _log.debug)(NAME, '[disconnect]');
      try {
        this.getEmbeddedView().disconnect();
      } catch (e) {
        // nada.
      }
      this.cleanUp();
      this._soResponder.disconnect();
    }
  }, {
    key: 'addSharedObjectResponseHandler',
    value: function addSharedObjectResponseHandler(handler) {
      this._soResponder.addResponseHandler(handler);
    }
  }, {
    key: 'removeSharedObjectResponseHandler',
    value: function removeSharedObjectResponseHandler(handler) {
      this._soResponder.removeResponseHandler(handler);
    }
  }, {
    key: 'sendToSharedObject',
    value: function sendToSharedObject(name, callName, message) {
      this._soResponder.sendToSharedObject(name, callName, message);
    }
  }, {
    key: 'sendPropertyToSharedObject',
    value: function sendPropertyToSharedObject(name, key, value) {
      this._soResponder.sendPropertyToSharedObject(name, key, value);
    }
  }, {
    key: 'getRemoteSharedObject',
    value: function getRemoteSharedObject(sharedObjectName) {
      this._soResponder.getRemoteSharedObject(sharedObjectName);
    }
  }, {
    key: 'connectToSharedObject',
    value: function connectToSharedObject(sharedObjectName) {
      this._soResponder.connectToSharedObject(sharedObjectName);
    }
  }, {
    key: 'closeSharedObject',
    value: function closeSharedObject(sharedObjectName) {
      this._soResponder.closeSharedObject(sharedObjectName);
    }
  }, {
    key: 'getEmbeddedView',
    value: function getEmbeddedView() {
      return _browser2.default.getEmbedObject(this._swfId);
    }
  }, {
    key: 'getControls',
    value: function getControls() {
      return this._controls;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.playerType;
    }
  }]);

  return RTMPSourceHandler;
}(_eventEmitter2.default);

exports.default = RTMPSourceHandler;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(139)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(172);
module.exports = __webpack_require__(29).RegExp.escape;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4)
  , isArray  = __webpack_require__(80)
  , SPECIES  = __webpack_require__(6)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(164);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject    = __webpack_require__(1)
  , toPrimitive = __webpack_require__(28)
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(40)
  , gOPS    = __webpack_require__(65)
  , pIE     = __webpack_require__(53);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(40)
  , toIObject = __webpack_require__(18);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var path      = __webpack_require__(170)
  , invoke    = __webpack_require__(61)
  , aFunction = __webpack_require__(14);
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);

/***/ }),
/* 171 */
/***/ (function(module, exports) {

module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0)
  , $re     = __webpack_require__(171)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', {copyWithin: __webpack_require__(112)});

__webpack_require__(45)('copyWithin');

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $every  = __webpack_require__(26)(4);

$export($export.P + $export.F * !__webpack_require__(24)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', {fill: __webpack_require__(72)});

__webpack_require__(45)('fill');

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $filter = __webpack_require__(26)(2);

$export($export.P + $export.F * !__webpack_require__(24)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0)
  , $find   = __webpack_require__(26)(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(45)(KEY);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0)
  , $find   = __webpack_require__(26)(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(45)(KEY);

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export  = __webpack_require__(0)
  , $forEach = __webpack_require__(26)(0)
  , STRICT   = __webpack_require__(24)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx            = __webpack_require__(30)
  , $export        = __webpack_require__(0)
  , toObject       = __webpack_require__(12)
  , call           = __webpack_require__(121)
  , isArrayIter    = __webpack_require__(79)
  , toLength       = __webpack_require__(11)
  , createProperty = __webpack_require__(73)
  , getIterFn      = __webpack_require__(96);

$export($export.S + $export.F * !__webpack_require__(63)(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export       = __webpack_require__(0)
  , $indexOf      = __webpack_require__(57)(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(24)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', {isArray: __webpack_require__(80)});

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export   = __webpack_require__(0)
  , toIObject = __webpack_require__(18)
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(52) != Object || !__webpack_require__(24)(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export       = __webpack_require__(0)
  , toIObject     = __webpack_require__(18)
  , toInteger     = __webpack_require__(35)
  , toLength      = __webpack_require__(11)
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(24)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $map    = __webpack_require__(26)(1);

$export($export.P + $export.F * !__webpack_require__(24)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export        = __webpack_require__(0)
  , createProperty = __webpack_require__(73);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $reduce = __webpack_require__(114);

$export($export.P + $export.F * !__webpack_require__(24)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $reduce = __webpack_require__(114);

$export($export.P + $export.F * !__webpack_require__(24)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export    = __webpack_require__(0)
  , html       = __webpack_require__(77)
  , cof        = __webpack_require__(22)
  , toIndex    = __webpack_require__(43)
  , toLength   = __webpack_require__(11)
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $some   = __webpack_require__(26)(3);

$export($export.P + $export.F * !__webpack_require__(24)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export   = __webpack_require__(0)
  , aFunction = __webpack_require__(14)
  , toObject  = __webpack_require__(12)
  , fails     = __webpack_require__(3)
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(24)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42)('Array');

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0)
  , fails   = __webpack_require__(3)
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export     = __webpack_require__(0)
  , toObject    = __webpack_require__(12)
  , toPrimitive = __webpack_require__(28);

$export($export.P + $export.F * __webpack_require__(3)(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(6)('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))__webpack_require__(15)(proto, TO_PRIMITIVE, __webpack_require__(166));

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  __webpack_require__(16)(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', {bind: __webpack_require__(115)});

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject       = __webpack_require__(4)
  , getPrototypeOf = __webpack_require__(21)
  , HAS_INSTANCE   = __webpack_require__(6)('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(8).f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(8).f
  , createDesc = __webpack_require__(34)
  , has        = __webpack_require__(13)
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0)
  , log1p   = __webpack_require__(123)
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0)
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0 
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0)
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0 
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0)
  , sign    = __webpack_require__(84);

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0)
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0)
  , $expm1  = __webpack_require__(83);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export   = __webpack_require__(0)
  , sign      = __webpack_require__(84)
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(0)
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0)
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {log1p: __webpack_require__(123)});

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {sign: __webpack_require__(84)});

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0)
  , expm1   = __webpack_require__(83)
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0)
  , expm1   = __webpack_require__(83)
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global            = __webpack_require__(2)
  , has               = __webpack_require__(13)
  , cof               = __webpack_require__(22)
  , inheritIfRequired = __webpack_require__(78)
  , toPrimitive       = __webpack_require__(28)
  , fails             = __webpack_require__(3)
  , gOPN              = __webpack_require__(39).f
  , gOPD              = __webpack_require__(20).f
  , dP                = __webpack_require__(8).f
  , $trim             = __webpack_require__(49).trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(__webpack_require__(38)(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = __webpack_require__(7) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(16)(global, NUMBER, $Number);
}

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export   = __webpack_require__(0)
  , _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {isInteger: __webpack_require__(120)});

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export   = __webpack_require__(0)
  , isInteger = __webpack_require__(120)
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var $export     = __webpack_require__(0)
  , $parseFloat = __webpack_require__(130);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , $parseInt = __webpack_require__(131);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , toInteger    = __webpack_require__(35)
  , aNumberValue = __webpack_require__(111)
  , repeat       = __webpack_require__(91)
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , $fails       = __webpack_require__(3)
  , aNumberValue = __webpack_require__(111)
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
  }
});

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', {assign: __webpack_require__(124)});

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(38)});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', {defineProperties: __webpack_require__(125)});

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(7), 'Object', {defineProperty: __webpack_require__(8).f});

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(4)
  , meta     = __webpack_require__(33).onFreeze;

__webpack_require__(27)('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = __webpack_require__(18)
  , $getOwnPropertyDescriptor = __webpack_require__(20).f;

__webpack_require__(27)('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(27)('getOwnPropertyNames', function(){
  return __webpack_require__(126).f;
});

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = __webpack_require__(12)
  , $getPrototypeOf = __webpack_require__(21);

__webpack_require__(27)('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(4);

__webpack_require__(27)('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(4);

__webpack_require__(27)('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(4);

__webpack_require__(27)('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', {is: __webpack_require__(132)});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(12)
  , $keys    = __webpack_require__(40);

__webpack_require__(27)('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(4)
  , meta     = __webpack_require__(33).onFreeze;

__webpack_require__(27)('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(4)
  , meta     = __webpack_require__(33).onFreeze;

__webpack_require__(27)('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(86).set});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(51)
  , test    = {};
test[__webpack_require__(6)('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  __webpack_require__(16)(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var $export     = __webpack_require__(0)
  , $parseFloat = __webpack_require__(130);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , $parseInt = __webpack_require__(131);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY            = __webpack_require__(37)
  , global             = __webpack_require__(2)
  , ctx                = __webpack_require__(30)
  , classof            = __webpack_require__(51)
  , $export            = __webpack_require__(0)
  , isObject           = __webpack_require__(4)
  , aFunction          = __webpack_require__(14)
  , anInstance         = __webpack_require__(36)
  , forOf              = __webpack_require__(46)
  , speciesConstructor = __webpack_require__(88)
  , task               = __webpack_require__(93).set
  , microtask          = __webpack_require__(85)()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[__webpack_require__(6)('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(41)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
__webpack_require__(48)($Promise, PROMISE);
__webpack_require__(42)(PROMISE);
Wrapper = __webpack_require__(29)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(63)(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = __webpack_require__(0)
  , aFunction = __webpack_require__(14)
  , anObject  = __webpack_require__(1)
  , rApply    = (__webpack_require__(2).Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = __webpack_require__(0)
  , create     = __webpack_require__(38)
  , aFunction  = __webpack_require__(14)
  , anObject   = __webpack_require__(1)
  , isObject   = __webpack_require__(4)
  , fails      = __webpack_require__(3)
  , bind       = __webpack_require__(115)
  , rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = __webpack_require__(8)
  , $export     = __webpack_require__(0)
  , anObject    = __webpack_require__(1)
  , toPrimitive = __webpack_require__(28);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = __webpack_require__(0)
  , gOPD     = __webpack_require__(20).f
  , anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export  = __webpack_require__(0)
  , anObject = __webpack_require__(1);
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
__webpack_require__(81)(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = __webpack_require__(20)
  , $export  = __webpack_require__(0)
  , anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = __webpack_require__(0)
  , getProto = __webpack_require__(21)
  , anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = __webpack_require__(20)
  , getPrototypeOf = __webpack_require__(21)
  , has            = __webpack_require__(13)
  , $export        = __webpack_require__(0)
  , isObject       = __webpack_require__(4)
  , anObject       = __webpack_require__(1);

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export       = __webpack_require__(0)
  , anObject      = __webpack_require__(1)
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {ownKeys: __webpack_require__(129)});

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export            = __webpack_require__(0)
  , anObject           = __webpack_require__(1)
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = __webpack_require__(0)
  , setProto = __webpack_require__(86);

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = __webpack_require__(8)
  , gOPD           = __webpack_require__(20)
  , getPrototypeOf = __webpack_require__(21)
  , has            = __webpack_require__(13)
  , $export        = __webpack_require__(0)
  , createDesc     = __webpack_require__(34)
  , anObject       = __webpack_require__(1)
  , isObject       = __webpack_require__(4);

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var global            = __webpack_require__(2)
  , inheritIfRequired = __webpack_require__(78)
  , dP                = __webpack_require__(8).f
  , gOPN              = __webpack_require__(39).f
  , isRegExp          = __webpack_require__(62)
  , $flags            = __webpack_require__(60)
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(3)(function(){
  re2[__webpack_require__(6)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(16)(global, 'RegExp', $RegExp);
}

__webpack_require__(42)('RegExp');

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(59)('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(59)('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(59)('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(59)('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = __webpack_require__(62)
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(136);
var anObject    = __webpack_require__(1)
  , $flags      = __webpack_require__(60)
  , DESCRIPTORS = __webpack_require__(7)
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  __webpack_require__(16)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(__webpack_require__(3)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(17)('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(17)('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(17)('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(17)('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $at     = __webpack_require__(89)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export   = __webpack_require__(0)
  , toLength  = __webpack_require__(11)
  , context   = __webpack_require__(90)
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(76)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(17)('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(17)('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(17)('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var $export        = __webpack_require__(0)
  , toIndex        = __webpack_require__(43)
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export  = __webpack_require__(0)
  , context  = __webpack_require__(90)
  , INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(76)(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(17)('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(89)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(82)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(17)('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , toIObject = __webpack_require__(18)
  , toLength  = __webpack_require__(11);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(91)
});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(17)('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export     = __webpack_require__(0)
  , toLength    = __webpack_require__(11)
  , context     = __webpack_require__(90)
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(76)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(17)('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(17)('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(17)('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(49)('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(2)
  , has            = __webpack_require__(13)
  , DESCRIPTORS    = __webpack_require__(7)
  , $export        = __webpack_require__(0)
  , redefine       = __webpack_require__(16)
  , META           = __webpack_require__(33).KEY
  , $fails         = __webpack_require__(3)
  , shared         = __webpack_require__(66)
  , setToStringTag = __webpack_require__(48)
  , uid            = __webpack_require__(44)
  , wks            = __webpack_require__(6)
  , wksExt         = __webpack_require__(134)
  , wksDefine      = __webpack_require__(95)
  , keyOf          = __webpack_require__(168)
  , enumKeys       = __webpack_require__(167)
  , isArray        = __webpack_require__(80)
  , anObject       = __webpack_require__(1)
  , toIObject      = __webpack_require__(18)
  , toPrimitive    = __webpack_require__(28)
  , createDesc     = __webpack_require__(34)
  , _create        = __webpack_require__(38)
  , gOPNExt        = __webpack_require__(126)
  , $GOPD          = __webpack_require__(20)
  , $DP            = __webpack_require__(8)
  , $keys          = __webpack_require__(40)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(39).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(53).f  = $propertyIsEnumerable;
  __webpack_require__(65).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(37)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(15)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , $typed       = __webpack_require__(67)
  , buffer       = __webpack_require__(94)
  , anObject     = __webpack_require__(1)
  , toIndex      = __webpack_require__(43)
  , toLength     = __webpack_require__(11)
  , isObject     = __webpack_require__(4)
  , ArrayBuffer  = __webpack_require__(2).ArrayBuffer
  , speciesConstructor = __webpack_require__(88)
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(42)(ARRAY_BUFFER);

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(67).ABV, {
  DataView: __webpack_require__(94).DataView
});

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(32)('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(118);

// 23.4 WeakSet Objects
__webpack_require__(58)('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export   = __webpack_require__(0)
  , $includes = __webpack_require__(57)(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(45)('includes');

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = __webpack_require__(0)
  , microtask = __webpack_require__(85)()
  , process   = __webpack_require__(2).process
  , isNode    = __webpack_require__(22)(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0)
  , cof     = __webpack_require__(22);

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(0);

$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(117)('Map')});

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export         = __webpack_require__(0)
  , toObject        = __webpack_require__(12)
  , aFunction       = __webpack_require__(14)
  , $defineProperty = __webpack_require__(8);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(7) && $export($export.P + __webpack_require__(64), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export         = __webpack_require__(0)
  , toObject        = __webpack_require__(12)
  , aFunction       = __webpack_require__(14)
  , $defineProperty = __webpack_require__(8);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(7) && $export($export.P + __webpack_require__(64), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export  = __webpack_require__(0)
  , $entries = __webpack_require__(128)(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = __webpack_require__(0)
  , ownKeys        = __webpack_require__(129)
  , toIObject      = __webpack_require__(18)
  , gOPD           = __webpack_require__(20)
  , createProperty = __webpack_require__(73);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export                  = __webpack_require__(0)
  , toObject                 = __webpack_require__(12)
  , toPrimitive              = __webpack_require__(28)
  , getPrototypeOf           = __webpack_require__(21)
  , getOwnPropertyDescriptor = __webpack_require__(20).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(64), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export                  = __webpack_require__(0)
  , toObject                 = __webpack_require__(12)
  , toPrimitive              = __webpack_require__(28)
  , getPrototypeOf           = __webpack_require__(21)
  , getOwnPropertyDescriptor = __webpack_require__(20).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(7) && $export($export.P + __webpack_require__(64), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0)
  , $values = __webpack_require__(128)(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export     = __webpack_require__(0)
  , global      = __webpack_require__(2)
  , core        = __webpack_require__(29)
  , microtask   = __webpack_require__(85)()
  , OBSERVABLE  = __webpack_require__(6)('observable')
  , aFunction   = __webpack_require__(14)
  , anObject    = __webpack_require__(1)
  , anInstance  = __webpack_require__(36)
  , redefineAll = __webpack_require__(41)
  , hide        = __webpack_require__(15)
  , forOf       = __webpack_require__(46)
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

__webpack_require__(42)('Observable');

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                  = __webpack_require__(31)
  , anObject                  = __webpack_require__(1)
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(31)
  , anObject               = __webpack_require__(1)
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var Set                     = __webpack_require__(137)
  , from                    = __webpack_require__(113)
  , metadata                = __webpack_require__(31)
  , anObject                = __webpack_require__(1)
  , getPrototypeOf          = __webpack_require__(21)
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(31)
  , anObject               = __webpack_require__(1)
  , getPrototypeOf         = __webpack_require__(21)
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                = __webpack_require__(31)
  , anObject                = __webpack_require__(1)
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(31)
  , anObject               = __webpack_require__(1)
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(31)
  , anObject               = __webpack_require__(1)
  , getPrototypeOf         = __webpack_require__(21)
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(31)
  , anObject               = __webpack_require__(1)
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                  = __webpack_require__(31)
  , anObject                  = __webpack_require__(1)
  , aFunction                 = __webpack_require__(14)
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(0);

$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(117)('Set')});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0)
  , $at     = __webpack_require__(89)(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export     = __webpack_require__(0)
  , defined     = __webpack_require__(23)
  , toLength    = __webpack_require__(11)
  , isRegExp    = __webpack_require__(62)
  , getFlags    = __webpack_require__(60)
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

__webpack_require__(81)($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0)
  , $pad    = __webpack_require__(133);

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0)
  , $pad    = __webpack_require__(133);

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(49)('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(49)('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(95)('asyncIterator');

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(95)('observable');

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', {global: __webpack_require__(2)});

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators    = __webpack_require__(97)
  , redefine      = __webpack_require__(16)
  , global        = __webpack_require__(2)
  , hide          = __webpack_require__(15)
  , Iterators     = __webpack_require__(47)
  , wks           = __webpack_require__(6)
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , $task   = __webpack_require__(93);
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global     = __webpack_require__(2)
  , $export    = __webpack_require__(0)
  , invoke     = __webpack_require__(61)
  , partial    = __webpack_require__(169)
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(292);
__webpack_require__(231);
__webpack_require__(233);
__webpack_require__(232);
__webpack_require__(235);
__webpack_require__(237);
__webpack_require__(242);
__webpack_require__(236);
__webpack_require__(234);
__webpack_require__(244);
__webpack_require__(243);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(238);
__webpack_require__(230);
__webpack_require__(241);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(198);
__webpack_require__(200);
__webpack_require__(199);
__webpack_require__(248);
__webpack_require__(247);
__webpack_require__(218);
__webpack_require__(228);
__webpack_require__(229);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(279);
__webpack_require__(284);
__webpack_require__(291);
__webpack_require__(282);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(280);
__webpack_require__(285);
__webpack_require__(287);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(281);
__webpack_require__(283);
__webpack_require__(286);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(193);
__webpack_require__(195);
__webpack_require__(194);
__webpack_require__(197);
__webpack_require__(196);
__webpack_require__(182);
__webpack_require__(180);
__webpack_require__(186);
__webpack_require__(183);
__webpack_require__(189);
__webpack_require__(191);
__webpack_require__(179);
__webpack_require__(185);
__webpack_require__(176);
__webpack_require__(190);
__webpack_require__(174);
__webpack_require__(188);
__webpack_require__(187);
__webpack_require__(181);
__webpack_require__(184);
__webpack_require__(173);
__webpack_require__(175);
__webpack_require__(178);
__webpack_require__(177);
__webpack_require__(192);
__webpack_require__(97);
__webpack_require__(264);
__webpack_require__(269);
__webpack_require__(136);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(249);
__webpack_require__(135);
__webpack_require__(137);
__webpack_require__(138);
__webpack_require__(304);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(299);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(297);
__webpack_require__(300);
__webpack_require__(298);
__webpack_require__(301);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(257);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(263);
__webpack_require__(262);
__webpack_require__(305);
__webpack_require__(331);
__webpack_require__(334);
__webpack_require__(333);
__webpack_require__(335);
__webpack_require__(336);
__webpack_require__(332);
__webpack_require__(337);
__webpack_require__(338);
__webpack_require__(316);
__webpack_require__(319);
__webpack_require__(315);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(317);
__webpack_require__(318);
__webpack_require__(308);
__webpack_require__(330);
__webpack_require__(339);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(310);
__webpack_require__(312);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(324);
__webpack_require__(323);
__webpack_require__(326);
__webpack_require__(325);
__webpack_require__(327);
__webpack_require__(328);
__webpack_require__(329);
__webpack_require__(306);
__webpack_require__(320);
__webpack_require__(342);
__webpack_require__(341);
__webpack_require__(340);
module.exports = __webpack_require__(29);

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(141);
module.exports = __webpack_require__(140);


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA5ODE1OWEyNjQ4NjliMGZkNGNiOSIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Vudi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlsL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29yZS9ldmVudC1lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9ldmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL2NvbnRyb2xzL3N0YXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9hZGFwdGVyL3dlYnJ0Yy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9jb250cm9scy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdmlldy9wbGF5YmFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvYWRhcHRlci93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudW0vcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXZlbnQvc2hhcmVkb2JqZWN0LWV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3L3B1Ymxpc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnVtL3BsYXliYWNrLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnYvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V2ZW50L3B1Ymxpc2hlci1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXZlbnQvc3Vic2NyaWJlci1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaGVscGVyL3NoYXJlZG9iamVjdC1oZWxwZXItcnRtcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3B1Ymxpc2hlci9jb25zdHJhaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL2NvbnRyb2xzL2V2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy91dGlsL2ltcGwtZmFjdG9yeS1vcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWwvdXJsLWVuZHBvaW50LmpzIiwid2VicGFjazovLy8uL34vYnJvd3Nlci1idW55YW4vbGliL2J1bnlhbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZW52L21ldGFkYXRhLXV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V4Y2VwdGlvbi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci9zb2NrZXQtaGVscGVyLXB1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItc3ViLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9oZWxwZXIvd2VicnRjLWhlbHBlci1wdWIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9nL2J1bnlhbi13cml0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3B1Ymxpc2hlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcHVibGlzaGVyL3B1Yi1zb3VyY2UtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9wdWJsaXNoZXIvcmVkNXByby1ydG1wLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zaGFyZWRvYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N1YnNjcmliZXIvY29udHJvbHMvc2xpZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8taGxzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXNvdXJjZS1oYW5kbGVyLWhscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXNvdXJjZS1oYW5kbGVyLXJ0Yy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXNvdXJjZS1oYW5kbGVyLXJ0bXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9iYWJlbC1wb2x5ZmlsbC9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19wYXRoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvc2hpbS5qcyJdLCJuYW1lcyI6WyJsb2dnZXIiLCJmb3JtYXRNZXNzYWdlIiwiZGlzcGF0Y2hlciIsIm1lc3NhZ2UiLCJkZWNvcmF0ZSIsImxldmVsIiwic291cmNlIiwiTEVWRUxTIiwiVFJBQ0UiLCJJTkZPIiwiREVCVUciLCJXQVJOIiwiRVJST1IiLCJGQVRBTCIsImVzdGFibGlzaExvZ2dlciIsInN0cmVhbUxpc3QiLCJ1bmRlZmluZWQiLCJzdHJlYW1zIiwicHVzaCIsInN0cmVhbSIsInR5cGUiLCJsaXN0IiwibWFwIiwiaXRlbSIsImNvbmNhdCIsIm5hbWUiLCJnZXRMb2dnZXIiLCJ0cmFjZSIsImluZm8iLCJkZWJ1ZyIsIndhcm4iLCJlcnJvciIsImZhdGFsIiwicnRtcFN1YnNjcmliZXJBc3NpZ25tZW50cyIsImNsb3NlSGFuZGxlcnMiLCJmdWxsc2NyZWVuSGFuZGxlcnMiLCJzY3JlZW5mdWxsSGFuZGxlckFzc2lnbmVkIiwiZW5hYmxlU2NyZWVuZnVsbEhhbmRsZXIiLCJ3aW5kb3ciLCJzY3JlZW5mdWxsIiwiZW5hYmxlZCIsIm9uY2hhbmdlIiwiaSIsImxlbmd0aCIsImlzRnVsbHNjcmVlbiIsIm9ud2luZG93Y2xvc2UiLCJlIiwiZmxhc2hWZXJzaW9uIiwidmVyc2lvbiIsIkFjdGl2ZVhPYmplY3QiLCJHZXRWYXJpYWJsZSIsInJlcGxhY2UiLCJtYXRjaCIsIm5hdmlnYXRvciIsIm1pbWVUeXBlcyIsImVuYWJsZWRQbHVnaW4iLCJwbHVnaW5zIiwiZGVzY3JpcHRpb24iLCJlcnIiLCJzcGxpdCIsInJlcXVlc3RGcmFtZSIsInRpbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImZuIiwic2V0VGltZW91dCIsInRyYWNrUmVzaXplIiwiZWxlbWVudCIsInJhZiIsInBhcmVudCIsInBhcmVudE5vZGUiLCJzdHlsZSIsImhlaWdodCIsImNsaWVudFdpZHRoIiwicHdpZHRoIiwiZXdpZHRoIiwiY2xpZW50SGVpZ2h0IiwibWFyZ2luIiwicG9zaXRpb24iLCJsZWZ0IiwiaXNNb3oiLCJtb3pHZXRVc2VyTWVkaWEiLCJhZGFwdGVyIiwiZ2V0VXNlck1lZGlhIiwibWVkaWFEZXZpY2VzIiwid2Via2l0R2V0VXNlck1lZGlhIiwibXNHZXRVc2VyTWVkaWEiLCJvcmlnaW4iLCJzdHlsZXMiLCJ0cmFuc2l0aW9uIiwicm90YXRpb25UcmFuc2xhdGlvbnMiLCJ0cmFuc2Zvcm0iLCJnZXRJc01veiIsInN1cHBvcnRzV2ViU29ja2V0IiwiV2ViU29ja2V0Iiwic3VwcG9ydHNITFMiLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNhblBsYXlUeXBlIiwic3VwcG9ydHNGbGFzaFZlcnNpb24iLCJkZWxpbWl0ZXIiLCJyZXNvbHZlRWxlbWVudCIsImlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVXZWJTb2NrZXQiLCJ1cmwiLCJzZXRWaWRlb1NvdXJjZSIsInZpZGVvRWxlbWVudCIsIm1lZGlhU3RyZWFtIiwiYXV0b3BsYXkiLCJzcmNPYmplY3QiLCJzcmMiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJwbGF5Iiwic2V0QXR0cmlidXRlIiwicGF1c2UiLCJpbmplY3RTY3JpcHQiLCJkZmQiLCJzY3JpcHQiLCJvbmxvYWQiLCJyZXNvbHZlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYXBwZW5kQ2hpbGQiLCJwcm9taXNlIiwiZ1VNIiwiY29uc3RyYWludHMiLCJzZXRHbG9iYWwiLCJwcm9wIiwidmFsdWUiLCJnZXRTd2ZPYmplY3QiLCJzd2ZvYmplY3QiLCJnZXRFbWJlZE9iamVjdCIsImdldEVsZW1lbnRJZCIsImdldEF0dHJpYnV0ZSIsImFkZENsb3NlSGFuZGxlciIsImhhbmRsZXIiLCJpbnNlcnRWYWx1ZSIsInNsaWNlIiwib25iZWZvcmV1bmxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2xvc2VIYW5kbGVyIiwiaW52b2tlIiwibWV0aG9kTmFtZSIsImRhdGEiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ0b2dnbGVGdWxsU2NyZWVuIiwidG9nZ2xlIiwib25GdWxsU2NyZWVuU3RhdGVDaGFuZ2UiLCJjYiIsIm9uT3JpZW50YXRpb25NZXRhZGF0YSIsImFwcGx5T3JpZW50YXRpb24iLCJ0cmFuc2xhdGlvbnMiLCJ0b1N0cmluZyIsIndpZHRoIiwicGhlaWdodCIsInNjYWxlIiwiYXR0YWNoRXZlbnQiLCJoYXNBdHRyaWJ1dGVEZWZpbmVkIiwiZWxlbSIsImF0dHJpYnV0ZSIsImF0dCIsImhhc0NsYXNzRGVmaW5lZCIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwidGFnTmFtZSIsIm9wdHMiLCJjcmVhdGVUZXh0Tm9kZSIsImFkZFN1YnNjcmlwdGlvbkFzc2lnbm1lbnRIYW5kbGVyIiwic2V0U3Vic2NyaWJlcklkIiwic2hpZnQiLCJnZXRNb3VzZVhGcm9tRXZlbnQiLCJldmVudCIsInBhZ2VYIiwiY2xpZW50WCIsImJvZHkiLCJzY3JvbGxMZWZ0IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0U2Nyb2xsWCIsInBhZ2VYT2Zmc2V0IiwiZ2V0R2xvYmFsIiwiX0RlZmVycmVkUHJvbWlzZSIsInJlamVjdCIsIlByb21pc2UiLCJfRnV0dXJlIiwiY3JlYXRlSWZOb3RFeGlzdCIsImRlZmVycmVkSWZFeGlzdCIsImYiLCJEZWZlcnJlZFByb21pc2UiLCJGdXR1cmUiLCJXSUxEQ0FSRCIsIldJTERDQVJEX0tFWSIsIkV2ZW50RW1pdHRlciIsIl9jYWxsYmFja3MiLCJjYWxsYmFja3MiLCJpbmRleE9mIiwiaW5kZXgiLCJzcGxpY2UiLCJfbm90aWZ5IiwiY29tbW9uIiwicnRjIiwicnRtcCIsImZhaWxvdmVyIiwiRXZlbnQiLCJfdHlwZSIsIl9kYXRhIiwiUHVibGlzaGVyRXZlbnQiLCJwdWJsaXNoZXIiLCJfcHVibGlzaGVyIiwiU3Vic2NyaWJlckV2ZW50Iiwic3Vic2NyaWJlciIsIl9zdWJzY3JpYmVyIiwiU2hhcmVkT2JqZWN0RXZlbnQiLCJzaGFyZWRPYmplY3ROYW1lIiwiX25hbWUiLCJQbGF5YmFja1N0YXRlIiwiT2JqZWN0IiwiZnJlZXplIiwiVU5BVkFJTEFCTEUiLCJBVkFJTEFCTEUiLCJJRExFIiwiUExBWUlORyIsIlBBVVNFRCIsIlBsYXliYWNrU3RhdGVSZWFkYWJsZSIsImZvcm1hdHMiLCJoYXNSZXNvbHV0aW9uc0RlZmluZWQiLCJ2aWRlbyIsImdldFZhbHVlRnJvbUNvbnN0cmFpbnRBdHRyaWJ1dGUiLCJleGFjdCIsImlkZWFsIiwibWF4IiwibWluIiwiaXNFeGFjdCIsImZvcm1hdCIsInciLCJoIiwiaXNMb3dlciIsImRlc2lyZWQiLCJkaW1lbnNpb25zIiwiaGFzTWF0Y2hpbmdGb3JtYXQiLCJmb3JtYXRzTGlzdCIsImZpbmRMb3dlclJlc29sdXRpb25zIiwicmVzSXNMb3dlciIsImZpbmROZXh0U2VsZWN0aW9uIiwic2VsZWN0aW9ucyIsInAiLCJzZWxlY3Rpb24iLCJ0aGVuIiwibWVkaWEiLCJjYXRjaCIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWlja1Jlc29sdXRpb25TdXBwb3J0IiwiZGV0ZXJtaW5lU3VwcG9ydGVkUmVzb2x1dGlvbiIsImRlZmVycmVkIiwiaXNTdXBwb3J0ZWQiLCJfUlRDUGVlckNvbm5lY3Rpb24iLCJfUlRDSWNlQ2FuZGlkYXRlIiwiX1JUQ1Nlc3Npb25EZXNjcmlwdGlvbiIsImlzQXZhaWxhYmxlSW5Gb3JtYXRzIiwicmVzIiwiYXZhaWxhYmxlIiwiZm9yY2VVc2VyTWVkaWEiLCJ1cGRhdGVCYW5kd2lkdGgiLCJvcHRpb25zIiwic2RwIiwiYXVkaW8iLCJSVENQZWVyQ29ubmVjdGlvbiIsIm1velJUQ1BlZXJDb25uZWN0aW9uIiwid2Via2l0UlRDUGVlckNvbm5lY3Rpb24iLCJSVENJY2VDYW5kaWRhdGUiLCJtb3pSVENJY2VDYW5kaWRhdGUiLCJ3ZWJraXRSVENJY2VDYW5kaWRhdGUiLCJSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJtb3pSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJ3ZWJraXRSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJOQU1FIiwiX1BsYXliYWNrQ29udHJvbHMiLCJzdGF0ZSIsIl9QbGF5YmFja0NvbnRyb2xzSW1wbCIsInBsYXllciIsImNvbnRhaW5lciIsIl9wbGF5UGF1c2VCdXR0b24iLCJfbXV0ZUJ1dHRvbiIsIl92b2x1bWVGaWVsZCIsIl9zZWVrVGltZUZpZWxkIiwiX3RpbWVGaWVsZCIsIl9mdWxsU2NyZWVuQnV0dG9uIiwiX3N0YXRlIiwiX211dGVkU3RhdGUiLCJfcmVzdW1lQWZ0ZXJTZWVrIiwiX3BsYXliYWNrRHVyYXRpb24iLCJfdm9sdW1lVmFsdWUiLCJfb25QbGF5UGF1c2VDbGlja0JvdW5kIiwiX29uUGxheVBhdXNlQ2xpY2siLCJiaW5kIiwiY29udHJvbGJhciIsImFkZCIsIl9jcmVhdGVQbGF5UGF1c2VCdXR0b24iLCJfY3JlYXRlTXV0ZUJ1dHRvbiIsIl9jcmVhdGVWb2x1bWVDb250cm9sIiwiX2NyZWF0ZVNlZWtDb250cm9sIiwiX2NyZWF0ZVBsYXliYWNrVGltZSIsIl9jcmVhdGVGdWxsU2NyZWVuVG9nZ2xlIiwidmlldyIsInJlbW92ZSIsInNldFN0YXRlIiwib25GdWxsU2NyZWVuQ2hhbmdlIiwic2V0U2Vla1RpbWUiLCJlbmFibGVQbGF5UGF1c2UiLCJnZXRTdGF0ZSIsInJlc3VtZSIsImJ1dHRvbiIsInNlbGYiLCJnZXRNdXRlZFN0YXRlIiwidW5tdXRlIiwic2V0TXV0ZWRTdGF0ZSIsIm11dGUiLCJzbGlkZXIiLCJvbiIsIkNIQU5HRSIsInBlcmNlbnRhZ2UiLCJOdW1iZXIiLCJzZXRWb2x1bWUiLCJDSEFOR0VfU1RBUlQiLCJzZWVrVG8iLCJDSEFOR0VfQ09NUExFVEUiLCJzcGFuIiwidGV4dCIsImhycyIsIm1pbnMiLCJwYXJzZUludCIsInNlY3MiLCJmb3JtYXR0ZWRBcnIiLCJqb2luIiwiaW5uZXJUZXh0IiwiZm9ybWF0VGltZSIsIk1hdGgiLCJmbG9vciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvblN0YXRlQ2hhbmdlIiwibXV0ZWQiLCJvbk11dGVkU3RhdGVDaGFuZ2UiLCJpc0Z1bGxTY3JlZW4iLCJpc1ZPRCIsImRpc2FibGVkIiwiUGxheWJhY2tDb250cm9scyIsIlBsYXliYWNrQ29udHJvbHNJbXBsIiwicGxheWJhY2tJZCIsIlBsYXliYWNrVmlldyIsImVsZW1lbnRJZCIsIl90YXJnZXRFbGVtZW50Iiwic2V0VmlldyIsImlzQXV0b3BsYXkiLCJjcmVhdGUiLCJQdWJsaXNoVHlwZXMiLCJSVE1QIiwiUlRDIiwiUHVibGlzaE1vZGVUeXBlcyIsIkxJVkUiLCJSRUNPUkQiLCJBUFBFTkQiLCJDT05ORUNUX1NVQ0NFU1MiLCJDT05ORUNUX0ZBSUxVUkUiLCJQUk9QRVJUWV9VUERBVEUiLCJNRVRIT0RfVVBEQVRFIiwicHVibGlzaGVySWQiLCJQdWJsaXNoVmlldyIsIlBsYXliYWNrVHlwZXMiLCJITFMiLCJQbGF5YmFja0F1ZGlvRW5jb2RlciIsIk9QVVMiLCJQQ01VIiwiUENNQSIsIlNQRUVYIiwiTk9ORSIsIlBsYXliYWNrVmlkZW9FbmNvZGVyIiwiVlA4IiwiSDI2NCIsImRlZmluZUVtYmVkRWxlbWVudCIsInRhcmdldEVsZW1lbnQiLCJ0YXJnZXRQYXJlbnQiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZGl2IiwicGFyZW50RWxlbWVudCIsInJlbW92ZUNoaWxkIiwiZW1iZWRTd2ZPYmplY3QiLCJpZE5hbWUiLCJmbGFzaHZhcnMiLCJwYXJhbXMiLCJxdWFsaXR5Iiwid21vZGUiLCJiZ2NvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYWxsb3dzY3JpcHRhY2Nlc3MiLCJhbGxvd2Z1bGxzY3JlZW4iLCJhbGxvd25ldHdvcmtpbmciLCJhdHRyaWJ1dGVzIiwiYWxpZ24iLCJoYXNGbGFzaFBsYXllclZlcnNpb24iLCJtaW5GbGFzaFZlcnNpb24iLCJlbWJlZFNXRiIsInN3ZiIsImVtYmVkV2lkdGgiLCJlbWJlZEhlaWdodCIsInByb2R1Y3RJbnN0YWxsVVJMIiwiUFVCTElTSF9TVEFSVCIsIlBVQkxJU0hfRkFJTCIsIlBVQkxJU0hfSU5WQUxJRF9OQU1FIiwiVU5QVUJMSVNIX1NVQ0NFU1MiLCJQVUJMSVNIX01FVEFEQVRBIiwiQ09OTkVDVElPTl9DTE9TRUQiLCJESU1FTlNJT05fQ0hBTkdFIiwiUFVCTElTSEVSX1JFSkVDVCIsIlBVQkxJU0hFUl9BQ0NFUFQiLCJNRURJQV9TVFJFQU1fQVZBSUxBQkxFIiwiUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRSIsIk9GRkVSX1NUQVJUIiwiT0ZGRVJfRU5EIiwiSUNFX1RSSUNLTEVfQ09NUExFVEUiLCJFTUJFRF9TVUNDRVNTIiwiRU1CRURfRkFJTFVSRSIsIlNVQlNDUklCRV9TVEFSVCIsIlNVQlNDUklCRV9TVE9QIiwiU1VCU0NSSUJFX0ZBSUwiLCJTVUJTQ1JJQkVfSU5WQUxJRF9OQU1FIiwiU1VCU0NSSUJFX01FVEFEQVRBIiwiU1VCU0NSSUJFX1NFTkRfSU5WT0tFIiwiUExBWV9VTlBVQkxJU0giLCJPUklFTlRBVElPTl9DSEFOR0UiLCJWT0xVTUVfQ0hBTkdFIiwiUExBWUJBQ0tfVElNRV9VUERBVEUiLCJQTEFZQkFDS19TVEFURV9DSEFOR0UiLCJGVUxMX1NDUkVFTl9TVEFURV9DSEFOR0UiLCJTVUJTQ1JJQkVSX1JFSkVDVCIsIlNVQlNDUklCRVJfQUNDRVBUIiwiQU5TV0VSX1NUQVJUIiwiQU5TV0VSX0VORCIsIkNBTkRJREFURV9TVEFSVCIsIkNBTkRJREFURV9FTkQiLCJSVE1QU2hhcmVkT2JqZWN0SGFuZGxlciIsIl9lbGVtZW50IiwiX3Jlc3BvbnNlSGFuZGxlcnMiLCJySGFuZGxlciIsInJlc3BvbmQiLCJwYXJzZSIsIl9oYW5kbGVTaGFyZWRPYmplY3RFdmVudCIsImhhbmRsZVNoYXJlZE9iamVjdEV2ZW50IiwiZWxJZCIsImhhbmRsZXJOYW1lIiwic2V0U2hhcmVkT2JqZWN0UmVzcG9uZGVyIiwic3dmSWQiLCJjYWxsTmFtZSIsInNoYXJlZE9iamVjdFNlbmQiLCJrZXkiLCJzaGFyZWRPYmplY3RTZW5kUHJvcGVydHkiLCJhc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIiLCJnZXRSZW1vdGVTaGFyZWRPYmplY3QiLCJjb25uZWN0VG9TaGFyZWRPYmplY3QiLCJkaXNjb25uZWN0RnJvbVNoYXJlZE9iamVjdCIsIndlYnNvY2tldCIsIlNvY2tldEhlbHBlciIsInJlc3BvbmRlciIsIl9yZXNwb25kZXIiLCJfcGVuZGluZ1Bvc3RSZXF1ZXN0cyIsIl93ZWJzb2NrZXQiLCJfY29ubmVjdGlvblByb21pc2UiLCJfaXNUZXJtaW5hdGVkIiwiX29uY2xvc2UiLCJ0ZWFyRG93biIsIndzIiwib25vcGVuIiwib25tZXNzYWdlIiwib25lcnJvciIsIm9uY2xvc2UiLCJwb3N0IiwiY29kZSIsIm9uU29ja2V0Q2xvc2UiLCJkZXRhaWwiLCJzZXR1cFByb21pc2UiLCJfYWRkU29ja2V0SGFuZGxlcnMiLCJfcmVtb3ZlU29ja2V0SGFuZGxlcnMiLCJjbG9zZSIsInNlbmRSZXF1ZXN0Iiwic2VuZCIsImhhbmRsZWQiLCJoYW5kbGVNZXNzYWdlUmVzcG9uc2UiLCJqc29uIiwiZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlIiwiaXNBdmFpbGFibGUiLCJvblN0cmVhbUF2YWlsYWJsZSIsIm9uU3RyZWFtVW5hdmFpbGFibGUiLCJvblNvY2tldE1lc3NhZ2VFcnJvciIsIm9uVW5leHBlY3RlZFNvY2tldEVycm9yIiwic2hhcmVkT2JqZWN0R2V0UmVtb3RlIiwic2hhcmVkT2JqZWN0Q29ubmVjdCIsInNoYXJlZE9iamVjdFNldFByb3BlcnR5Iiwic2hhcmVkT2JqZWN0Q2xvc2UiLCJpbmZsYXRlIiwib2JqIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJSVENNZWRpYVZpZGVvQ29uc3RyYWludCIsIlJUTVBNZWRpYVZpZGVvQ29uc3RyYWludCIsIlJUQ01lZGlhQ29uc3RyYWludCIsIlJUTVBNZWRpYUNvbnN0cmFpbnQiLCJTbGlkZXJFdmVudCIsImNvbnRyb2wiLCJfY29udHJvbCIsIlNsaWRlckV2ZW50VHlwZXMiLCJXZWFrTWFwIiwicHZ0IiwiY3R4IiwiaGFzIiwic2V0IiwiZ2V0IiwiSW1wbEZhY3RvcnlPcmRlciIsImxpc3RvcmRlciIsImZpbmQiLCJpdGVyYXRvciIsImluaXRGbiIsImxhc3RFcnJvciIsIm5leHQiLCJJbXBsIiwiY29uY3JldGUiLCJvcmRlciIsImRvbmUiLCJjdXJyeSIsImZ4IiwiYXJpdHkiLCJmMSIsImFyZ3MiLCJBcnJheSIsInByb3RvdHlwZSIsImFyZ3VtZW50cyIsImFwcGx5IiwiZjIiLCJhcmdzMiIsImZpbHRlciIsImlkeCIsImxlbiIsInJlc3VsdCIsInRvSW50Iiwicm91bmQiLCJnZXRPckVsc2UiLCJkZWZhdWx0VmFsdWUiLCJnZXRJbnRPckVsc2UiLCJpc05hTiIsImRlZXBEZWZpbmUiLCJvYmplY3QiLCJwYXRocyIsInRhaWwiLCJwb3AiLCJwYXRoIiwiZGVlcENvcHkiLCJzdHIiLCJydGNTb2NrZXRFbmRwb2ludEZyb21PcHRpb25zIiwicHJvdG9jb2wiLCJ3c3Byb3RvY29sIiwicG9ydCIsIndzcG9ydCIsImFwcEVuZHBvaW50IiwiY29udGV4dCIsImFwcCIsImVuZHBvaW50IiwiaG9zdCIsImNvbm5lY3Rpb25QYXJhbXMiLCJrdiIsImtleXMiLCJmb3JFYWNoIiwic3Vic2NyaWJlckxpYiIsInB1Ymxpc2hlckxpYiIsInNoYXJlZE9iamVjdExpYiIsIlJlZDVQcm9TdWJzY3JpYmVyIiwiUlRDU3Vic2NyaWJlciIsIkhMU1N1YnNjcmliZXIiLCJSVE1QU3Vic2NyaWJlciIsIlJlZDVQcm9QdWJsaXNoZXIiLCJSVE1QUHVibGlzaGVyIiwiUlRDUHVibGlzaGVyIiwiUHVibGlzaGVyVmlldyIsIlJlZDVQcm9TaGFyZWRPYmplY3QiLCJzZXRMb2dMZXZlbCIsInRvVXBwZXJDYXNlIiwianNvbkF0dHIiLCJqc29uVmFsIiwicmVhZFVURiIsInN0YXJ0Iiwib2Zmc2V0IiwiZW5kIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicGFyc2VKU09ORm9yT3JpZW50YXRpb24iLCJvcmllbnRhdGlvbiIsImV4ZWMiLCJtYXRjaDIiLCJjYWxsYmFjayIsInRleHRUcmFja3MiLCJhZGRUZXh0VHJhY2siLCJ0cmFjayIsImFkZFRyYWNrRXZlbnQiLCJtb2RlIiwiY3VlcyIsImN1ZUNoYW5nZUV2ZW50IiwiY3VycmVudFRhcmdldCIsImFjdGl2ZUN1ZXMiLCJzaXplIiwiTm9FbGVtZW50Rm91bmRFcnJvciIsIk5vU3VwcG9ydGVkQ2FtZXJhUmVzb2x1dGlvbnNFcnJvciIsIlB1Ymxpc2hlclNvY2tldEhlbHBlciIsIm9uU0RQQW5zd2VyIiwiY2FuZGlkYXRlIiwib25BZGRJY2VDYW5kaWRhdGUiLCJvblNvY2tldEljZUNhbmRpZGF0ZUVuZCIsIm9uUHVibGlzaGVyU3RhdHVzIiwiU3Vic2NyaXB0aW9uU29ja2V0SGVscGVyIiwib25TRFBPZmZlciIsIm9uVW5wdWJsaXNoIiwib25Db25uZWN0aW9uQ2xvc2VkIiwib25TdWJzY3JpYmVyU3RhdHVzIiwic3RhdHVzIiwibWV0aG9kIiwib25TZW5kUmVjZWl2ZWQiLCJvbk1ldGFEYXRhIiwibWV0YWRhdGEiLCJ3ZWJydGMiLCJQdWJsaXNoZXJQZWVySGVscGVyIiwiX3BlZXJDb25uZWN0aW9uIiwiY29ubmVjdGlvbiIsIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvbmljZWNhbmRpZGF0ZSIsImNvbm5lY3Rpb25TdGF0ZSIsIm9uSWNlQ2FuZGlkYXRlIiwiaWNlQ29ubmVjdGlvblN0YXRlIiwib25QZWVyQ29ubmVjdGlvbkNsb3NlIiwiYmFuZHdpZHRoIiwib2ZmZXJQcm9taXNlIiwiY3JlYXRlT2ZmZXIiLCJzZXNzaW9uRGVzY3JpcHRpb24iLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwib25TRFBTdWNjZXNzIiwib25TRFBFcnJvciIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiYWRkSWNlQ2FuZGlkYXRlIiwiaWNlU2VydmVycyIsInNldFVwUHJvbWlzZSIsInJ0Y3BNdXhQb2xpY3kiLCJwZWVyQ29uZmlnIiwicGVlciIsIm9wdGlvbmFsIiwiRHRsc1NydHBLZXlBZ3JlZW1lbnQiLCJSdHBEYXRhQ2hhbm5lbHMiLCJnb29nQ3B1T3ZlcnVzZURldGVjdGlvbiIsIl9hZGRDb25uZWN0aW9uSGFuZGxlcnMiLCJfcmVtb3ZlQ29ubmVjdGlvbkhhbmRsZXJzIiwiaXNFbXB0eUNhbmRpZGF0ZSIsIlN1YnNjcmlwdGlvblBlZXJIZWxwZXIiLCJfcGVuZGluZ01lZGlhU3RyZWFtIiwib25hZGRzdHJlYW0iLCJvbnRyYWNrIiwib25JY2VDYW5kaWRhdGVUcmlja2xlRW5kIiwib25BbnN3ZXJNZWRpYVN0cmVhbSIsImNyZWF0ZUFuc3dlciIsImljZUNhbmRpZGF0ZSIsInNkcE1MaW5lSW5kZXgiLCJSYXdTdHJlYW0iLCJyZWMiLCJjb25zb2xlIiwibG9nIiwibXNnIiwicHVibGlzaEZhY3RvcnkiLCJwdWJsaXNoZXJJbXBsIiwiTWFwIiwiX29wdGlvbnMiLCJfdmlldyIsIl9jdXJyZW50UHVibGlzaGVyIiwiX2JvdW5kQnViYmxlUHVibGlzaGVyRXZlbnQiLCJidWJibGVQdWJsaXNoZXJFdmVudCIsIl9vcmRlciIsInQiLCJlbnRyeSIsIlNldCIsInB1Ymxpc2hWaWV3IiwiZ2V0UHVibGlzaGVyRnJvbU9yZGVyIiwiYXR0YWNoUHVibGlzaGVyIiwidW5wdWJsaXNoIiwib2ZmIiwicHVibGlzaGVyRXZlbnQiLCJ0cmlnZ2VyIiwiZW1iZWQiLCJjb252ZXJ0RGltZW5zaW9uT3B0aW9ucyIsInZvIiwibWVkaWFDb25zdHJhaW50c1RvRmxhc2h2YXJzIiwiZnYiLCJQdWJsaXNoZXJTb3VyY2VIYW5kbGVyIiwic29SZXNwb25kZXIiLCJjbG9uZSIsImNsb25lTm9kZSIsImhvbGRlciIsInB1Ymxpc2hlclR5cGUiLCJfc3dmSWQiLCJfZW1iZWRGdXR1cmUiLCJfc29SZXNwb25kZXIiLCJzd2ZVcmwiLCJidWZmZXIiLCJzdHJlYW1Nb2RlIiwic3RyZWFtTmFtZSIsImFwcE5hbWUiLCJyb29tTmFtZSIsImF1dG9zaXplIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWVkaWFDb25zdHJhaW50cyIsInB1Ymxpc2hPcHRpb25zIiwiY29ubmVjdCIsImNsZWFuVXAiLCJkaXNjb25uZWN0IiwiYWRkUmVzcG9uc2VIYW5kbGVyIiwicmVtb3ZlUmVzcG9uc2VIYW5kbGVyIiwic2VuZFRvU2hhcmVkT2JqZWN0Iiwic2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QiLCJjbG9zZVNoYXJlZE9iamVjdCIsInVwZGF0ZVJlc29sdXRpb24iLCJkZWZhdWx0T3B0aW9ucyIsIm1lZGlhRWxlbWVudElkIiwib25HZXRVc2VyTWVkaWEiLCJwdWJTdGFydFJlZ2V4IiwicHViU3RvcFJlZ2V4IiwiX3BlZXJIZWxwZXIiLCJfc29ja2V0SGVscGVyIiwiX21lZGlhU3RyZWFtIiwiX3N0cmVhbUZ1dHVyZSIsIl9hdmFpbGFibGVGdXR1cmUiLCJfcGVlckZ1dHVyZSIsIl9vZmZlckZ1dHVyZSIsIl9zZW5kT2ZmZXJGdXR1cmUiLCJfdHJpY2tsZUVuZEZ1dHVyZSIsIl9wdWJsaXNoRnV0dXJlIiwiX3VucHVibGlzaEZ1dHVyZSIsInJlaiIsIl9ndW0iLCJwcmV2aWV3IiwiY3VycmVudFZpZXciLCJfZ2V0TWVkaWFTdHJlYW0iLCJfb25NZWRpYVN0cmVhbVJlY2VpdmVkIiwiX3NldFZpZXdJZk5vdEV4aXN0Iiwic3RvcCIsImdldFRyYWNrcyIsInRyYWNrcyIsInRyYWNrTGVuZ3RoIiwiYnVuZGxlIiwic2V0VXAiLCJfc2VuZE9mZkZ1dHVyZSIsImhhbmRsZU9mZmVyIiwiaGFuZGxlQ2FuZGlkYXRlIiwicHVibGlzaCIsInNvY2tldFByb21pc2UiLCJzb2NrZXR1cmwiLCJfZ2V0VHJpY2tsZUVuZCIsInJlcXVlc3RBdmFpbGFiaWxpdHkiLCJzdHJlYW1UeXBlIiwiY3JlYXRlUGVlckNvbm5lY3Rpb24iLCJhZGRTdHJlYW0iLCJzZW5kT2ZmZXIiLCJyZXF1ZXN0UHVibGlzaCIsImNsZWFySGVscGVycyIsInJlcXVlc3RVbnB1Ymxpc2giLCJtdXRlQXVkaW8iLCJ1bm11dGVBdWRpbyIsIm11dGVWaWRlbyIsInJlY2VpcHQiLCJjbG9zZUV2ZW50Iiwic2VuZENhbmRpZGF0ZSIsInN0b3BSZXN1bHQiLCJzdGFydFJlc3VsdCIsIm5ld09wdGlvbnMiLCJzd2ZvYmplY3RVUkwiLCJfc291cmNlSGFuZGxlciIsIl9lbGVtZW50SWQiLCJfY29ubmVjdEZ1dHVyZSIsImFkZFNvdXJjZSIsInNldEFjdGl2ZUlkIiwic3VjY2Vzc0lkIiwiX3RlYXJEb3duQ29ubmVjdENhbGxiYWNrIiwiaW52b2tlRm4iLCJsYWJlbCIsIl9zZXRVcENvbm5lY3RDYWxsYmFjayIsInNyY0hhbmRsZXIiLCJnZXRFbWJlZE9wZXJhdGlvbiIsIl9lc3RhYmxpc2hFeHRJbnRIYW5kbGVycyIsImNvdW50IiwibGltaXQiLCJ0cnlDb25uZWN0IiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImdldFR5cGUiLCJzZXRNZWRpYVF1YWxpdHkiLCJzb05hbWUiLCJTT19TVUJUWVBFX1BST1BFUlRZIiwiU09fU1VCVFlQRV9NRVRIT0QiLCJkZWNvZGVNZXNzYWdlSWZKU09OU3RyaW5nIiwiUHJvcGVydHlEYXRhIiwiTWV0aG9kRGF0YSIsIm1lc3NhZ2VMaXN0IiwiX3NvY2tldCIsImdldENvbm5lY3Rpb24iLCJhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIiLCJ2YWx1ZU9iamVjdCIsInRvT2JqZWN0IiwiZXZlbnRzIiwic3VidHlwZSIsIm5vdGlmeU9mRXZlbnRzIiwibm90aWZ5T2ZQcm9wZXJ0eVZhbHVlcyIsIm1lc3NhZ2VOYW1lIiwicmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIiwiQ29udHJvbFNsaWRlciIsIl9jb250YWluZXIiLCJfYnV0dG9uIiwiY3JlYXRlQnV0dG9uIiwiX3RyYWNrIiwiY3JlYXRlVHJhY2siLCJfcHJvZ3Jlc3NCYXIiLCJjcmVhdGVQcm9ncmVzc0JhciIsIl92YWx1ZSIsIl9kaXNhYmxlZCIsIl9ldmVudFN0YXJ0UG9zaXRpb24iLCJfbGF5b3V0IiwiX21vdXNldXBIYW5kbGVyIiwiX21vdXNldXAiLCJfbW91c2Vkb3duSGFuZGxlciIsIl9tb3VzZWRvd24iLCJfbW91c2Vtb3ZlSGFuZGxlciIsIl9tb3VzZW1vdmUiLCJfdXBkYXRlSGFuZGxlcnMiLCJwb3NpdGlvbk9mZnNldCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpc0Rpc2FibGVkIiwicGVyY2VudFZhbHVlIiwiYm9vbCIsInBsYXliYWNrRmFjdG9yeSIsInBsYXliYWNrSW1wbCIsIl9jdXJyZW50U3Vic2NyaWJlciIsIl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudCIsImJ1YmJsZVN1YnNjcmliZXJFdmVudCIsInBsYXliYWNrVmlldyIsImdldFBsYXliYWNrRnJvbU9yZGVyIiwiYXR0YWNoU3Vic2NyaWJlciIsImNhbmNlbCIsInN1YnNjcmliZXJFdmVudCIsIm1pbWVUeXBlIiwib3B0aW9uc1RvSGxzVVJMIiwiaGxzcHJvdG9jb2wiLCJobHNwb3J0IiwiUjVQcm9ITFNTdWJzY3JpYmVyIiwiX3ZpZXdSZXNvbHZlciIsIl9zdWJzY3JpcHRpb25SZXNvbHZlciIsIl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMiLCJidWJibGVTdWJzY3JpYmVyRXZlbnRzIiwiX2dldFZpZXdSZXNvbHZlclByb21pc2UiLCJfZ2xvbVNvdXJjZUhhbmRsZXJBUEkiLCJpbml0SGFuZGxlciIsInVybFJlZ2V4IiwiX2dldFN1YnNjcmlwdGlvblJlc29sdmVyUHJvbWlzZSIsImdldENvbnRyb2xzIiwic3ViU3RhcnRSZWdleCIsImdlbmVyYXRlU3Vic2NyaXB0aW9uSWQiLCJyYW5kb20iLCJfYXZhaWxhYmlsaXR5UmVzb2x2ZXIiLCJfb3JpZW50YXRpb24iLCJzdWJzY3JpcHRpb25JZCIsInZFbmNvZGluZyIsImFFbmNvZGluZyIsIm9mZmVyIiwicmVxdWVzdE9mZmVyIiwicmVxdWVzdElkIiwidmlkZW9FbmNvZGluZyIsImF1ZGlvRW5jb2RpbmciLCJzZW5kQW5zd2VyIiwiaGFuZGxlQW5zd2VyIiwic3Vic2NyaWJlIiwiX2Rpc2Nvbm5lY3QiLCJyZXF1ZXN0QW5zd2VyIiwiYXR0YWNoU3RyZWFtIiwic2VuZFN1YnNjcmliZSIsInBsYXlJZkF1dG9wbGF5U2V0IiwiaGFuZGxlT3JpZW50YXRpb25DaGFuZ2UiLCJ2aWV3RWxlbWVudCIsIl9nZXRBdmFpbGFiaWxpdHlSZXNvbHZlclByb21pc2UiLCJfY29ubmVjdCIsInByb2R1Y3RJbnN0YWxsVXJsIiwiX2VtYmVkUHJvbWlzZSIsIl9nZXRFbWJlZFByb21pc2UiLCJvbkVtYmVkQ29tcGxldGUiLCJvbkVtYmVkRmFpbHVyZSIsImVzdGFibGlzaFNvdXJjZUhhbmRsZXIiLCJzdWJzY3JpYmVySWQiLCJlbWJlZERmZCIsInBheWxvYWQiLCJ2b2x1bWUiLCJkdXJhdGlvbiIsIkhMU1NvdXJjZUhhbmRsZXIiLCJkZXRlcm1pbmVIb2xkZXIiLCJwbGF5ZXJUeXBlIiwiX2lzVk9EIiwiX2NvbnRyb2xzIiwiX3BsYXliYWNrTm90aWZpY2F0aW9uQ2VudGVyIiwiX2hhbmRsZUZ1bGxTY3JlZW5DaGFuZ2UiLCJpbnNlcnRCZWZvcmUiLCJub3RpZmllciIsImNvbnRyb2xzIiwiaGFzQ29udHJvbHMiLCJvbmNhbnBsYXkiLCJvbmR1cmF0aW9uY2hhbmdlIiwiaXNGaW5pdGUiLCJzZXRQbGF5YmFja0R1cmF0aW9uIiwib25lbmRlZCIsIm9udGltZXVwZGF0ZSIsImN1cnJlbnRUaW1lIiwib25zZWVrZWQiLCJvbnNlZWtpbmciLCJvbnBsYXkiLCJvbnBhdXNlIiwib252b2x1bWVjaGFuZ2UiLCJnZXRWb2x1bWUiLCJmaXJzdENoaWxkIiwiaGFzRGVmaW5lZENvbnRyb2xzIiwiaXNNdXRlZCIsInVzZVBsYXliYWNrQ29udHJvbHMiLCJlbWJlZE1lZGlhU291cmNlIiwic2V0QXNWT0QiLCJfYWRkUGxheWJhY2tIYW5kbGVycyIsIlJUQ1NvdXJjZUhhbmRsZXIiLCJpc1ZPRFN0cmVhbU5hbWUiLCJ0ZXN0IiwiUlRNUFNvdXJjZUhhbmRsZXIiLCJub3RpZmljYXRpb25DZW50ZXIiLCJnZXRFbWJlZGRlZFZpZXciLCJfdGVhckRvd25Jbml0Q2FsbGJhY2siLCJfc2V0VXBJbml0Q2FsbGJhY2siLCJlbWJlZGRlZCIsImNsYXp6Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRix1QkFBdUI7QUFDNUcsbUVBQW1FO0FBQ25FLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLHlCOzs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0M7Ozs7OztBQ0h2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEU7Ozs7OztBQ05BO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDRkE7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFFQSxJQUFJQSxlQUFKO0FBQ0EsSUFBTUMsZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFDQyxVQUFELEVBQWdCO0FBQ3BDLFNBQU8sbUJBQVc7QUFDaEIsaUJBQVdBLFVBQVgsVUFBMEJDLE9BQTFCO0FBQ0QsR0FGRDtBQUdELENBSkQ7QUFLQSxJQUFNQyxXQUFXLFNBQVhBLFFBQVcsQ0FBQ0MsS0FBRCxFQUFXO0FBQzFCLFNBQU8sVUFBQ0MsTUFBRCxFQUFTSCxPQUFULEVBQXFCO0FBQzFCSCxXQUFPSyxLQUFQLEVBQWNKLGNBQWNLLE1BQWQsRUFBc0JILE9BQXRCLENBQWQ7QUFDRCxHQUZEO0FBR0QsQ0FKRDtBQUtPLElBQU1JLDBCQUFTO0FBQ3BCQyxTQUFPLE9BRGE7QUFFcEJDLFFBQU0sTUFGYztBQUdwQkMsU0FBTyxPQUhhO0FBSXBCQyxRQUFNLE1BSmM7QUFLcEJDLFNBQU8sT0FMYTtBQU1wQkMsU0FBTztBQU5hLENBQWY7O0FBVUEsSUFBTUMsNENBQWtCLFNBQWxCQSxlQUFrQixDQUFDVCxLQUFELEVBQW1DO0FBQUEsTUFBM0JVLFVBQTJCLHVFQUFkQyxTQUFjOztBQUNoRSxNQUFJQyxVQUFVLEVBQWQ7QUFDQUEsVUFBUUMsSUFBUixDQUFhO0FBQ1hiLFdBQU9BLEtBREk7QUFFWGMsWUFBUSw2QkFGRztBQUdYQyxVQUFNO0FBSEssR0FBYjtBQUtBLE1BQUlMLFVBQUosRUFBZ0I7QUFDZCxRQUFNTSxPQUFPTixXQUFXTyxHQUFYLENBQWUsZ0JBQVE7QUFDbENDLFdBQUtsQixLQUFMLEdBQWFBLEtBQWI7QUFDRCxLQUZZLENBQWI7QUFHQVksY0FBVUEsUUFBUU8sTUFBUixDQUFlSCxJQUFmLENBQVY7QUFDRDtBQUNEckIsV0FBUyxpQ0FBYTtBQUNwQkssV0FBT0EsS0FEYTtBQUVwQm9CLFVBQU0sYUFGYztBQUdwQlIsYUFBU0E7QUFIVyxHQUFiLENBQVQ7QUFLRCxDQWxCTTs7QUFvQkEsSUFBTVMsZ0NBQVksU0FBWkEsU0FBWSxHQUFNO0FBQzdCLFNBQU8xQixNQUFQO0FBQ0QsQ0FGTTs7QUFJQSxJQUFNMkIsd0JBQVF2QixTQUFTRyxPQUFPQyxLQUFoQixDQUFkO0FBQ0EsSUFBTW9CLHNCQUFPeEIsU0FBU0csT0FBT0UsSUFBaEIsQ0FBYjtBQUNBLElBQU1vQix3QkFBUXpCLFNBQVNHLE9BQU9HLEtBQWhCLENBQWQ7QUFDQSxJQUFNb0Isc0JBQU8xQixTQUFTRyxPQUFPSSxJQUFoQixDQUFiO0FBQ0EsSUFBTW9CLHdCQUFRM0IsU0FBU0csT0FBT0ssS0FBaEIsQ0FBZDtBQUNBLElBQU1vQix3QkFBUTVCLFNBQVNHLE9BQU9NLEtBQWhCLENBQWQsQzs7Ozs7O0FDdkRQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCOzs7Ozs7QUNWQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsZ0JBQWdCLFVBQVUsR0FBRztBQUN0RSxDQUFDLEU7Ozs7OztBQ0hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNmQTs7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFQSxJQUFJb0IsNEJBQTRCLEVBQWhDO0FBQ0EsSUFBSUMsZ0JBQWdCLEVBQXBCO0FBQ0EsSUFBSUMscUJBQXFCLEVBQXpCO0FBQ0EsSUFBSUMsNEJBQTRCLEtBQWhDO0FBQ0EsU0FBU0MsdUJBQVQsR0FBb0M7QUFDbEMsTUFBSSxDQUFDRCx5QkFBRCxJQUE4QkUsT0FBT0MsVUFBckMsSUFBbURELE9BQU9DLFVBQVAsQ0FBa0JDLE9BQXpFLEVBQWtGO0FBQzlFSixnQ0FBNEIsSUFBNUI7QUFDQUUsV0FBT0MsVUFBUCxDQUFrQkUsUUFBbEIsQ0FBMkIsWUFBTTtBQUMvQixVQUFJQyxVQUFKO0FBQUEsVUFBT0MsU0FBU1IsbUJBQW1CUSxNQUFuQztBQUNBLFdBQUtELElBQUksQ0FBVCxFQUFZQSxJQUFJQyxNQUFoQixFQUF3QkQsR0FBeEIsRUFBNkI7QUFDM0JQLDJCQUFtQk8sQ0FBbkIsRUFBc0JKLE9BQU9DLFVBQVAsQ0FBa0JLLFlBQXhDO0FBQ0Q7QUFDRixLQUxEO0FBTUg7QUFDRjs7QUFFRCxTQUFTQyxhQUFULENBQXdCQyxDQUF4QixFQUEyQjtBQUFFO0FBQzNCO0FBQ0EsTUFBSUosVUFBSjtBQUFBLE1BQU9DLFNBQVNULGNBQWNTLE1BQTlCO0FBQ0EsT0FBS0QsSUFBSSxDQUFULEVBQVlBLElBQUlDLE1BQWhCLEVBQXdCRCxHQUF4QixFQUE2QjtBQUMzQlIsa0JBQWNRLENBQWQ7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0EsSUFBTUssZUFBZSxTQUFmQSxZQUFlLEdBQVk7QUFDL0IsTUFBSUMsVUFBVSxPQUFkO0FBQ0E7QUFDQSxNQUFJO0FBQ0ZBLGNBQVUsSUFBSVYsT0FBT1csYUFBWCxDQUF5QiwrQkFBekIsRUFBMERDLFdBQTFELENBQXNFLFVBQXRFLEVBQWtGQyxPQUFsRixDQUEwRixNQUExRixFQUFrRyxHQUFsRyxFQUF1R0MsS0FBdkcsQ0FBNkcsWUFBN0csRUFBMkgsQ0FBM0gsQ0FBVjs7QUFFRjtBQUNDLEdBSkQsQ0FJRSxPQUFPTixDQUFQLEVBQVU7QUFDVixRQUFJO0FBQ0YsVUFBSU8sVUFBVUMsU0FBVixDQUFvQiwrQkFBcEIsRUFBcURDLGFBQXpELEVBQXdFO0FBQ3RFUCxrQkFBVSxDQUFDSyxVQUFVRyxPQUFWLENBQWtCLHFCQUFsQixLQUE0Q0gsVUFBVUcsT0FBVixDQUFrQixpQkFBbEIsQ0FBN0MsRUFBbUZDLFdBQW5GLENBQStGTixPQUEvRixDQUF1RyxNQUF2RyxFQUErRyxHQUEvRyxFQUFvSEMsS0FBcEgsQ0FBMEgsWUFBMUgsRUFBd0ksQ0FBeEksQ0FBVjtBQUNEO0FBQ0YsS0FKRCxDQUlFLE9BQU9NLEdBQVAsRUFBWTtBQUNaO0FBQ0Q7QUFDRjtBQUNELFNBQU9WLFFBQVFXLEtBQVIsQ0FBYyxHQUFkLENBQVA7QUFDRCxDQWpCRDs7QUFtQkEsSUFBTUMsZUFBZ0IsVUFBQ0MsSUFBRCxFQUFVO0FBQzlCLFNBQU92QixPQUFPd0IscUJBQVAsSUFDQXhCLE9BQU95Qix3QkFEUCxJQUVBekIsT0FBTzBCLDJCQUZQLElBR0ExQixPQUFPMkIsdUJBSFAsSUFJQSxVQUFVQyxFQUFWLEVBQWM7QUFDWixXQUFPNUIsT0FBTzZCLFVBQVAsQ0FBa0JELEVBQWxCLEVBQXNCTCxJQUF0QixDQUFQO0FBQ0QsR0FOUjtBQU9ELENBUm9CLENBUWxCLElBUmtCLENBQXJCOztBQVVBLElBQU1PLGNBQWMsU0FBZEEsV0FBYyxDQUFDQyxPQUFELEVBQVVDLEdBQVYsRUFBa0I7QUFDcEMsU0FBTyxZQUFNO0FBQ1gsUUFBTUMsU0FBU0YsUUFBUUcsVUFBdkI7QUFDQUQsV0FBT0UsS0FBUCxDQUFhQyxNQUFiLEdBQXNCTCxRQUFRTSxXQUFSLEdBQXNCLElBQTVDO0FBQ0EsUUFBTUMsU0FBU0wsT0FBT0ksV0FBdEI7QUFDQSxRQUFNRSxTQUFTUixRQUFRUyxZQUF2QjtBQUNBLFFBQU1DLFNBQVMsQ0FBQ0gsU0FBU0MsTUFBVixJQUFvQixHQUFuQztBQUNBUixZQUFRSSxLQUFSLENBQWNPLFFBQWQsR0FBeUIsVUFBekI7QUFDQVgsWUFBUUksS0FBUixDQUFjUSxJQUFkLEdBQXFCRixTQUFTLElBQTlCO0FBQ0FULFFBQUlGLFlBQVlDLE9BQVosRUFBcUJDLEdBQXJCLENBQUo7QUFDRCxHQVREO0FBVUQsQ0FYRDs7QUFhQSxJQUFNWSxRQUFRLENBQUMsQ0FBQzdCLFVBQVU4QixlQUExQjtBQUNBO0FBQ0EsSUFBSSxDQUFDN0MsT0FBTzhDLE9BQVosRUFBcUI7QUFDbkIvQixZQUFVZ0MsWUFBVixHQUEwQmhDLFVBQVVpQyxZQUFWLElBQTBCakMsVUFBVWlDLFlBQVYsQ0FBdUJELFlBQWxELElBQW1FaEMsVUFBVWdDLFlBQTdFLElBQTZGaEMsVUFBVThCLGVBQXZHLElBQTBIOUIsVUFBVWtDLGtCQUFwSSxJQUEwSmxDLFVBQVVtQyxjQUE3TDtBQUNEOztBQUVELElBQU1DLFNBQVMsQ0FDYix1QkFEYSxFQUViLG9CQUZhLEVBR2IsbUJBSGEsRUFJYixrQkFKYSxFQUtiLGlCQUxhLENBQWY7QUFPQSxJQUFNQyxTQUFTLENBQ2IsaUJBRGEsRUFFYixjQUZhLEVBR2IsYUFIYSxFQUliLFlBSmEsRUFLYixXQUxhLENBQWY7QUFPQSxJQUFNQyxhQUFhLENBQ2pCLGtCQURpQixFQUVqQixlQUZpQixFQUdqQixjQUhpQixFQUlqQixhQUppQixFQUtqQixZQUxpQixDQUFuQjtBQU9BLElBQU1DLHVCQUF1QjtBQUMzQixPQUFLO0FBQ0hILFlBQVEsZUFETDtBQUVISSxlQUFXO0FBRlIsR0FEc0I7QUFLM0IsUUFBTTtBQUNKSixZQUFRLFVBREo7QUFFSkksZUFBVztBQUZQLEdBTHFCO0FBUzNCLFNBQU87QUFDTEosWUFBUSxlQURIO0FBRUxJLGVBQVc7QUFGTixHQVRvQjtBQWEzQixTQUFPO0FBQ0xKLFlBQVEsVUFESDtBQUVMSSxlQUFXO0FBRk4sR0Fib0I7QUFpQjNCLFNBQU87QUFDTEosWUFBUSxVQURIO0FBRUxJLGVBQVc7QUFGTixHQWpCb0I7QUFxQjNCLFVBQVE7QUFDTkosWUFBUSxlQURGO0FBRU5JLGVBQVc7QUFGTCxHQXJCbUI7QUF5QjNCLFVBQVE7QUFDTkosWUFBUSxVQURGO0FBRU5JLGVBQVc7QUFGTDtBQXpCbUIsQ0FBN0I7O2tCQStCZTs7QUFFYmpDLGdCQUFjQSxZQUZEOztBQUlia0MsWUFBVSxvQkFBTTtBQUNkLFdBQU9aLEtBQVA7QUFDRCxHQU5ZOztBQVFiYSxxQkFBbUIsNkJBQU07QUFDdkIsV0FBTyxDQUFDLENBQUN6RCxPQUFPMEQsU0FBaEI7QUFDRCxHQVZZOztBQVliQyxlQUFhLHVCQUFNO0FBQ2pCLFFBQUlDLEtBQUtDLFNBQVNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBVDtBQUNBLFdBQU9GLEdBQUdHLFdBQUgsQ0FBZSwrQkFBZixFQUFnRDFELE1BQWhELEdBQXlELENBQXpELElBQ0x1RCxHQUFHRyxXQUFILENBQWUsdUJBQWYsRUFBd0MxRCxNQUF4QyxHQUFpRCxDQUQ1QyxJQUVMdUQsR0FBR0csV0FBSCxDQUFlLGVBQWYsRUFBZ0MxRCxNQUFoQyxHQUF5QyxDQUZwQyxJQUdMdUQsR0FBR0csV0FBSCxDQUFlLGlCQUFmLEVBQWtDMUQsTUFBbEMsR0FBMkMsQ0FIN0M7QUFJRCxHQWxCWTs7QUFvQmIyRCx3QkFBc0IsOEJBQUN0RCxPQUFELEVBQThCO0FBQUEsUUFBcEJ1RCxTQUFvQix1RUFBUixHQUFROztBQUNsRCxXQUFPeEQsZUFBZSxDQUFmLEtBQXFCQyxRQUFRVyxLQUFSLENBQWM0QyxTQUFkLEVBQXlCLENBQXpCLENBQTVCO0FBQ0QsR0F0Qlk7O0FBd0JiQyxrQkFBZ0Isd0JBQUNDLEVBQUQsRUFBUTtBQUN0QixRQUFJO0FBQ0YsVUFBTVAsS0FBS0MsU0FBU08sY0FBVCxDQUF3QkQsRUFBeEIsQ0FBWDtBQUNBLFVBQUksQ0FBQ1AsRUFBTCxFQUFTO0FBQ1AsY0FBTSxxREFBMkNPLEVBQTNDLDJCQUFOO0FBQ0Q7QUFDRCxhQUFPUCxFQUFQO0FBQ0QsS0FORCxDQU1FLE9BQU9wRCxDQUFQLEVBQVU7QUFDVixZQUFNLHdFQUE4RDJELEVBQTlELFdBQXNFM0QsRUFBRTNDLE9BQXhFLENBQU47QUFDRDtBQUNGLEdBbENZOztBQW9DYndHLG1CQUFpQix5QkFBQ0MsR0FBRCxFQUFTO0FBQ3hCLFdBQU8sSUFBSXRFLE9BQU8wRCxTQUFYLENBQXFCWSxHQUFyQixDQUFQO0FBQ0QsR0F0Q1k7O0FBd0NiQyxrQkFBZ0Isd0JBQUNDLFlBQUQsRUFBZUMsV0FBZixFQUFpRDtBQUFBLFFBQXJCQyxRQUFxQix1RUFBVixLQUFVOztBQUMvRCxRQUFJLGVBQWVGLFlBQW5CLEVBQWlDO0FBQy9CQSxtQkFBYUcsU0FBYixHQUF5QkYsV0FBekI7QUFDRCxLQUZELE1BR0ssSUFBSTdCLEtBQUosRUFBVztBQUNkNEIsbUJBQWEsY0FBYixJQUErQkMsV0FBL0I7QUFDRCxLQUZJLE1BR0E7QUFDSEQsbUJBQWFJLEdBQWIsR0FBbUI1RSxPQUFPNkUsR0FBUCxDQUFXQyxlQUFYLENBQTJCTCxXQUEzQixDQUFuQjtBQUNEO0FBQ0QsUUFBSUMsUUFBSixFQUFjO0FBQ1pGLG1CQUFhTyxJQUFiO0FBQ0QsS0FGRCxNQUdLO0FBQ0gsVUFBSTtBQUNGUCxxQkFBYVEsWUFBYixDQUEwQixVQUExQixFQUFzQyxLQUF0QztBQUNBUixxQkFBYVMsS0FBYjtBQUNELE9BSEQsQ0FJQSxPQUFPekUsQ0FBUCxFQUFVO0FBQ1I7QUFDRDtBQUNGO0FBQ0YsR0E5RFk7O0FBZ0ViMEUsZ0JBQWMsc0JBQUNaLEdBQUQsRUFBUztBQUNyQixRQUFJYSxNQUFNLDhCQUFWO0FBQ0EsUUFBSUMsU0FBU3ZCLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtBQUNBc0IsV0FBT3RHLElBQVAsR0FBYyxpQkFBZDtBQUNBc0csV0FBT0MsTUFBUCxHQUFnQixZQUFNO0FBQ3BCRixVQUFJRyxPQUFKO0FBQ0QsS0FGRDtBQUdBRixXQUFPRyxrQkFBUCxHQUE0QixZQUFZO0FBQ3RDLFVBQUlILE9BQU9JLFVBQVAsS0FBc0IsUUFBdEIsSUFBa0NKLE9BQU9JLFVBQVAsS0FBc0IsVUFBNUQsRUFBd0U7QUFDdEVKLGVBQU9HLGtCQUFQLEdBQTRCLElBQTVCO0FBQ0FKLFlBQUlHLE9BQUo7QUFDRDtBQUNGLEtBTEQ7QUFNQUYsV0FBT1IsR0FBUCxHQUFhTixHQUFiO0FBQ0FULGFBQVM0QixvQkFBVCxDQUE4QixNQUE5QixFQUFzQyxDQUF0QyxFQUF5Q0MsV0FBekMsQ0FBcUROLE1BQXJEO0FBQ0EsV0FBT0QsSUFBSVEsT0FBWDtBQUNELEdBaEZZOztBQWtGYkMsT0FBSyxhQUFDQyxXQUFELEVBQWlCO0FBQ3BCLFdBQU8sQ0FBQzlFLFVBQVVpQyxZQUFWLElBQTBCakMsU0FBM0IsRUFBc0NnQyxZQUF0QyxDQUFtRDhDLFdBQW5ELENBQVA7QUFDRCxHQXBGWTs7QUFzRmJDLGFBQVcsbUJBQUNDLElBQUQsRUFBT0MsS0FBUCxFQUFpQjtBQUMxQmhHLFdBQU8rRixJQUFQLElBQWVDLEtBQWY7QUFDRCxHQXhGWTs7QUEwRmJDLGdCQUFjLHdCQUFNO0FBQ2xCLFdBQU9qRyxPQUFPa0csU0FBZDtBQUNELEdBNUZZOztBQThGYkMsa0JBQWdCLHdCQUFDaEMsRUFBRCxFQUFRO0FBQ3RCLFdBQU9OLFNBQVNPLGNBQVQsQ0FBd0JELEVBQXhCLENBQVA7QUFDRCxHQWhHWTs7QUFrR2JpQyxnQkFBYyxzQkFBQ3hDLEVBQUQsRUFBUTtBQUNwQixXQUFPQSxHQUFHeUMsWUFBSCxDQUFnQixJQUFoQixDQUFQO0FBQ0QsR0FwR1k7O0FBc0diQyxtQkFBaUIseUJBQUNDLE9BQUQsRUFBK0I7QUFBQSxRQUFyQkMsV0FBcUIsdUVBQVAsQ0FBQyxDQUFNOztBQUM5QzVHLGtCQUFjNkcsS0FBZCxDQUFvQkQsZ0JBQWdCLENBQUMsQ0FBakIsR0FBcUI1RyxjQUFjUyxNQUFuQyxHQUE0Q21HLFdBQWhFLEVBQTZFLENBQTdFLEVBQWdGRCxPQUFoRjtBQUNBLFFBQUl2RyxPQUFPMEcsY0FBUCxLQUEwQm5HLGFBQTlCLEVBQTZDO0FBQzNDUCxhQUFPMEcsY0FBUCxHQUF3Qm5HLGFBQXhCO0FBQ0FQLGFBQU8yRyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQ3BHLGFBQWxDO0FBQ0Q7QUFDRixHQTVHWTs7QUE4R2JxRyxzQkFBb0IsNEJBQUNMLE9BQUQsRUFBYTtBQUMvQixRQUFJbkcsSUFBSVIsY0FBY1MsTUFBdEI7QUFDQSxXQUFPLEVBQUVELENBQUYsR0FBTSxDQUFDLENBQWQsRUFBaUI7QUFDZixVQUFJUixjQUFjUSxDQUFkLE1BQXFCbUcsT0FBekIsRUFBa0M7QUFDaEMzRyxzQkFBYzZHLEtBQWQsQ0FBb0JyRyxDQUFwQixFQUF1QixDQUF2QjtBQUNBO0FBQ0Q7QUFDRjtBQUNGLEdBdEhZOztBQXdIYnlHLFVBQVEsZ0JBQUNDLFVBQUQsRUFBYUMsSUFBYixFQUFzQjtBQUM1QixRQUFJL0csT0FBT2dILGNBQVAsQ0FBc0JGLFVBQXRCLENBQUosRUFBdUM7QUFDckM5RyxhQUFPOEcsVUFBUCxFQUFtQkcsSUFBbkIsQ0FBd0JqSCxNQUF4QixFQUFnQytHLElBQWhDO0FBQ0Q7QUFDRixHQTVIWTs7QUE4SGI7QUFDQUcsb0JBQWtCLDBCQUFDbkYsT0FBRCxFQUFhO0FBQzdCLFFBQUkvQixPQUFPQyxVQUFQLElBQXFCRCxPQUFPQyxVQUFQLENBQWtCQyxPQUEzQyxFQUFvRDtBQUNsREYsYUFBT0MsVUFBUCxDQUFrQmtILE1BQWxCLENBQXlCcEYsT0FBekI7QUFDRDtBQUNGLEdBbklZOztBQXFJYnFGLDJCQUF5QixpQ0FBQ0MsRUFBRCxFQUFRO0FBQy9CeEgsdUJBQW1CakIsSUFBbkIsQ0FBd0J5SSxFQUF4QjtBQUNBdEgsNEJBQXdCQyxPQUFPQyxVQUEvQjtBQUNELEdBeElZOztBQTBJYnFILDREQTFJYTs7QUE0SWJDLG9CQUFrQiwwQkFBQ3hGLE9BQUQsRUFBVWlFLEtBQVYsRUFBb0I7QUFDcEMsUUFBSTVGLFVBQUo7QUFBQSxRQUFPQyxTQUFTK0MsT0FBTy9DLE1BQXZCO0FBQ0EyRixZQUFRQSxRQUFRLEdBQWhCO0FBQ0EsUUFBTXdCLGVBQWVsRSxxQkFBcUIwQyxNQUFNeUIsUUFBTixFQUFyQixDQUFyQjtBQUNBLFNBQUlySCxJQUFJLENBQVIsRUFBV0EsSUFBSUMsTUFBZixFQUF1QkQsR0FBdkIsRUFBNEI7QUFDMUIyQixjQUFRSSxLQUFSLENBQWNnQixPQUFPL0MsQ0FBUCxDQUFkLElBQTJCb0gsYUFBYXJFLE1BQXhDO0FBQ0FwQixjQUFRSSxLQUFSLENBQWNpQixPQUFPaEQsQ0FBUCxDQUFkLElBQTJCb0gsYUFBYWpFLFNBQXhDO0FBQ0F4QixjQUFRSSxLQUFSLENBQWNrQixXQUFXakQsQ0FBWCxDQUFkLElBQStCLHVCQUEvQjtBQUNEO0FBQ0QsUUFBSTRGLFFBQVEsR0FBUixLQUFnQixDQUFwQixFQUF1QjtBQUNyQmpFLGNBQVFJLEtBQVIsQ0FBY3VGLEtBQWQsR0FBc0IsU0FBdEI7QUFDQSxVQUFNekYsU0FBU0YsUUFBUUcsVUFBdkI7QUFDQSxVQUFNeUYsVUFBVTFGLE9BQU9PLFlBQXZCO0FBQ0EsVUFBTW9GLFFBQVFELFVBQVU1RixRQUFRTSxXQUFoQztBQUNBTixjQUFRSSxLQUFSLENBQWN1RixLQUFkLEdBQXVCM0YsUUFBUU0sV0FBUixHQUFzQnVGLEtBQXZCLEdBQWdDLElBQXREO0FBQ0EsVUFBSS9ELFNBQVNnRSxXQUFiLEVBQTBCO0FBQ3hCNUYsZUFBTzRGLFdBQVAsQ0FBbUIsUUFBbkIsRUFBNkIvRixZQUFZQyxPQUFaLENBQTdCO0FBQ0QsT0FGRCxNQUdLO0FBQ0hELG9CQUFZQyxPQUFaLEVBQXFCVCxZQUFyQjtBQUNEO0FBQ0Y7QUFDRixHQWxLWTs7QUFvS2J3Ryx1QkFBcUIsNkJBQUNDLElBQUQsRUFBT0MsU0FBUCxFQUFxQjtBQUN4QyxRQUFNQyxNQUFNRixLQUFLMUIsWUFBTCxDQUFrQjJCLFNBQWxCLENBQVo7QUFDQSxXQUFRQyxRQUFRLElBQVIsSUFBZ0IsUUFBT0EsR0FBUCx5Q0FBT0EsR0FBUCxPQUFldkosU0FBaEMsSUFDQSxPQUFPdUosR0FBUCxLQUFlLFFBQWYsS0FBNEJBLFFBQVEsRUFBUixJQUFjQSxRQUFRLE1BQWxELENBRFA7QUFFRCxHQXhLWTs7QUEwS2JDLG1CQUFpQix5QkFBQ0gsSUFBRCxFQUFPSSxTQUFQLEVBQXFCO0FBQ3BDLFdBQU9KLEtBQUtLLFNBQUwsQ0FBZUMsUUFBZixDQUF3QkYsU0FBeEIsQ0FBUDtBQUNELEdBNUtZOztBQThLYnJFLGlCQUFlLHVCQUFDd0UsT0FBRCxFQUFVQyxJQUFWLEVBQW1CO0FBQ2hDLFFBQUlELFlBQVksTUFBaEIsRUFBd0I7QUFDdEIsYUFBT3pFLFNBQVMyRSxjQUFULENBQXdCRCxLQUFLZCxRQUFMLEVBQXhCLENBQVA7QUFDRDtBQUNELFdBQU81RCxTQUFTQyxhQUFULENBQXVCd0UsT0FBdkIsRUFBZ0NDLElBQWhDLENBQVA7QUFDRCxHQW5MWTs7QUFxTGJFLG9DQUFrQywwQ0FBQzdHLEVBQUQsRUFBUTtBQUN4Q2pDLDhCQUEwQmYsSUFBMUIsQ0FBK0JnRCxFQUEvQjtBQUNBLFFBQUk1QixPQUFPMEksZUFBUCxLQUEyQmhLLFNBQS9CLEVBQTBDO0FBQ3hDc0IsYUFBTzBJLGVBQVAsR0FBeUIsVUFBQ3ZFLEVBQUQsRUFBUTtBQUMvQnhFLGtDQUEwQmdKLEtBQTFCLEdBQWtDeEUsRUFBbEM7QUFDRCxPQUZEO0FBR0Q7QUFDRixHQTVMWTs7QUE4TGJ5RSxzQkFBb0IsNEJBQUNDLEtBQUQsRUFBVztBQUM3QixRQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNWQSxjQUFRN0ksT0FBTzZJLEtBQWY7QUFDRDs7QUFFRCxRQUFJQSxNQUFNQyxLQUFWLEVBQWlCO0FBQ2YsYUFBT0QsTUFBTUMsS0FBYjtBQUNELEtBRkQsTUFHSyxJQUFJRCxNQUFNRSxPQUFWLEVBQW1CO0FBQ3RCLGFBQU9GLE1BQU1FLE9BQU4sR0FBZ0JsRixTQUFTbUYsSUFBVCxDQUFjQyxVQUE5QixHQUEyQ3BGLFNBQVNxRixlQUFULENBQXlCRCxVQUEzRTtBQUNEOztBQUVELFdBQU8sQ0FBUDtBQUNELEdBM01ZOztBQTZNYkUsY0FBWSxzQkFBTTtBQUNoQixXQUFRbkosT0FBT29KLFdBQVAsS0FBdUIxSyxTQUF4QixHQUNHc0IsT0FBT29KLFdBRFYsR0FFRyxDQUFDdkYsU0FBU3FGLGVBQVQsSUFBNEJyRixTQUFTbUYsSUFBVCxDQUFjOUcsVUFBMUMsSUFBd0QyQixTQUFTbUYsSUFBbEUsRUFBd0VDLFVBRmxGO0FBR0QsR0FqTlk7O0FBbU5iSSxhQUFXO0FBQUEsV0FBTXJKLE1BQU47QUFBQTs7QUFuTkUsQzs7Ozs7OztBQ3RJZjs7Ozs7Ozs7SUFFTXNKLGdCLEdBQ0osNEJBQWU7QUFBQTs7QUFBQTs7QUFDYixPQUFLaEUsT0FBTCxHQUFlNUcsU0FBZjtBQUNBLE9BQUs2SyxNQUFMLEdBQWM3SyxTQUFkO0FBQ0EsT0FBS2lILE9BQUwsR0FBZSxJQUFJNkQsT0FBSixDQUFZLFVBQUNsRSxPQUFELEVBQVVpRSxNQUFWLEVBQXFCO0FBQzlDLFVBQUtqRSxPQUFMLEdBQWVBLE9BQWY7QUFDQSxVQUFLaUUsTUFBTCxHQUFjQSxNQUFkO0FBQ0QsR0FIYyxDQUFmO0FBSUQsQzs7QUFHSCxJQUFNRSxVQUFVO0FBQ2RDLG9CQUFrQiwwQkFBQ0MsZUFBRCxFQUFxQjtBQUNyQyxRQUFJQyxJQUFJRCxlQUFSO0FBQ0EsUUFBSSxDQUFDQyxDQUFMLEVBQVE7QUFDTkEsVUFBSSxJQUFJTixnQkFBSixFQUFKO0FBQ0Q7QUFDRCxXQUFPTSxDQUFQO0FBQ0Q7QUFQYSxDQUFoQjs7QUFVTyxJQUFNQyw0Q0FBa0JQLGdCQUF4QjtBQUNBLElBQU1RLDBCQUFTTCxPQUFmLEM7Ozs7OztBQ3hCUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxFOzs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQ0pBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsRTs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEU7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsRTs7Ozs7O0FDL0JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFOzs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTEEsSUFBTU0sV0FBVyxHQUFqQjtBQUNBLElBQU1DLGVBQWUsU0FBckI7O0lBRU1DLFk7QUFFSiwwQkFBZTtBQUFBOztBQUNiLFNBQUtDLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLQSxVQUFMLENBQWdCRixZQUFoQixJQUFnQyxFQUFoQztBQUNEOzs7OzRCQUVRRyxTLEVBQVd0QixLLEVBQU87QUFDdkIsVUFBSXpJLFVBQUo7QUFBQSxVQUFPQyxTQUFTOEosVUFBVTlKLE1BQTFCO0FBQ0EsV0FBSUQsSUFBSSxDQUFSLEVBQVdBLElBQUlDLE1BQWYsRUFBdUJELEdBQXZCLEVBQTRCO0FBQzFCK0osa0JBQVUvSixDQUFWLEVBQWF5SSxLQUFiO0FBQ0Q7QUFDSjs7O3VCQUVHL0osSSxFQUFNOEMsRSxFQUFJO0FBQ1osVUFBSSxPQUFPQSxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDNUI7QUFDRDs7QUFFRCxVQUFJOUMsU0FBU2lMLFFBQWIsRUFBdUI7QUFDckIsYUFBS0csVUFBTCxDQUFnQkYsWUFBaEIsRUFBOEJwTCxJQUE5QixDQUFtQ2dELEVBQW5DO0FBQ0E7QUFDRDs7QUFFRCxVQUFJLEtBQUtzSSxVQUFMLENBQWdCcEwsSUFBaEIsTUFBMEJKLFNBQTlCLEVBQXlDO0FBQ3ZDLGFBQUt3TCxVQUFMLENBQWdCcEwsSUFBaEIsSUFBd0IsRUFBeEI7QUFDRDs7QUFFRCxVQUFJLEtBQUtvTCxVQUFMLENBQWdCcEwsSUFBaEIsRUFBc0JzTCxPQUF0QixDQUE4QnhJLEVBQTlCLE1BQXNDLENBQUMsQ0FBM0MsRUFBOEM7QUFDNUMsYUFBS3NJLFVBQUwsQ0FBZ0JwTCxJQUFoQixFQUFzQkYsSUFBdEIsQ0FBMkJnRCxFQUEzQjtBQUNEO0FBQ0Y7Ozt3QkFFSTlDLEksRUFBTThDLEUsRUFBSTtBQUNiLFVBQUk1QyxNQUFNLEtBQUtrTCxVQUFMLENBQWdCcEwsSUFBaEIsQ0FBVjtBQUNBLFVBQUlBLFNBQVNpTCxRQUFiLEVBQXVCO0FBQ3JCL0ssY0FBTSxLQUFLa0wsVUFBTCxDQUFnQkYsWUFBaEIsQ0FBTjtBQUNEO0FBQ0QsVUFBSWhMLEdBQUosRUFBUztBQUNQLFlBQU1xTCxRQUFRckwsSUFBSW9MLE9BQUosQ0FBWXhJLEVBQVosQ0FBZDtBQUNBLFlBQUl5SSxVQUFVLENBQUMsQ0FBZixFQUFrQjtBQUNoQnJMLGNBQUlzTCxNQUFKLENBQVdELEtBQVgsRUFBa0IsQ0FBbEI7QUFDRDtBQUNGO0FBQ0Y7Ozs0QkFFUXhCLEssRUFBTztBQUNkLFVBQU0vSixPQUFPK0osTUFBTS9KLElBQW5CO0FBQ0EsVUFBSSxLQUFLb0wsVUFBTCxDQUFnQnBMLElBQWhCLENBQUosRUFBMkI7QUFDekIsYUFBS3lMLE9BQUwsQ0FBYSxLQUFLTCxVQUFMLENBQWdCcEwsSUFBaEIsQ0FBYixFQUFvQytKLEtBQXBDO0FBQ0Q7QUFDRCxXQUFLMEIsT0FBTCxDQUFhLEtBQUtMLFVBQUwsQ0FBZ0JGLFlBQWhCLENBQWIsRUFBNENuQixLQUE1QztBQUNEOzs7Ozs7a0JBSVlvQixZOzs7Ozs7QUMzRGY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVTtBQUNiO0FBQ0EsRTs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEU7Ozs7OztBQ1pBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLEU7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDSkE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxHQUFHO0FBQ0gsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJDc0RTTyxNOzs7Ozs7MkJBQ0FDLEc7Ozs7OzsyQkFDQUMsSTs7Ozs7OzJCQUNBQyxROzs7Ozs7Ozs7NEJBQ0FILE07Ozs7Ozs0QkFDQUMsRzs7Ozs7OzRCQUNBQyxJOzs7Ozs7NEJBQ0FDLFE7Ozs7Ozs7Ozs4QkFDQUgsTTs7Ozs7Ozs7OztJQXBFSEksSztBQUVKLGlCQUFhOUwsSUFBYixFQUFxQztBQUFBLFFBQWxCaUksSUFBa0IsdUVBQVhySSxTQUFXOztBQUFBOztBQUNuQyxTQUFLbU0sS0FBTCxHQUFhL0wsSUFBYjtBQUNBLFNBQUtnTSxLQUFMLEdBQWEvRCxJQUFiO0FBQ0Q7Ozs7d0JBRVc7QUFDVixhQUFPLEtBQUs4RCxLQUFaO0FBQ0Q7Ozt3QkFFVztBQUNWLGFBQU8sS0FBS0MsS0FBWjtBQUNEOzs7Ozs7SUFJR0MsYzs7O0FBRUosMEJBQWFqTSxJQUFiLEVBQW1Ca00sU0FBbkIsRUFBOEJqRSxJQUE5QixFQUFvQztBQUFBOztBQUFBLGdJQUM1QmpJLElBRDRCLEVBQ3RCaUksSUFEc0I7O0FBRWxDLFVBQUtrRSxVQUFMLEdBQWtCRCxTQUFsQjtBQUZrQztBQUduQzs7Ozt3QkFFZ0I7QUFDZixhQUFPLEtBQUtDLFVBQVo7QUFDRDs7OztFQVQwQkwsSzs7SUFhdkJNLGU7OztBQUVKLDJCQUFhcE0sSUFBYixFQUFtQnFNLFVBQW5CLEVBQStCcEUsSUFBL0IsRUFBcUM7QUFBQTs7QUFBQSxtSUFDN0JqSSxJQUQ2QixFQUN2QmlJLElBRHVCOztBQUVuQyxXQUFLcUUsV0FBTCxHQUFtQkQsVUFBbkI7QUFGbUM7QUFHcEM7Ozs7d0JBRWlCO0FBQ2hCLGFBQU8sS0FBS0MsV0FBWjtBQUNEOzs7O0VBVDJCUixLOztJQWF4QlMsaUI7OztBQUVKLDZCQUFhdk0sSUFBYixFQUFtQndNLGdCQUFuQixFQUFxQ3ZFLElBQXJDLEVBQTJDO0FBQUE7O0FBQUEsdUlBQ25DakksSUFEbUMsRUFDN0JpSSxJQUQ2Qjs7QUFFekMsV0FBS3dFLEtBQUwsR0FBYUQsZ0JBQWI7QUFGeUM7QUFHMUM7Ozs7d0JBRVc7QUFDVixhQUFPLEtBQUtDLEtBQVo7QUFDRDs7OztFQVQ2QlgsSzs7UUFhZEEsSyxHQUFUQSxLO1FBQ2tCRyxjLEdBQWxCQSxjO1FBQ21CRyxlLEdBQW5CQSxlO1FBQ3FCRyxpQixHQUFyQkEsaUI7Ozs7OztBQzNEVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsU0FBUywrQkFBK0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsbURBQW1ELE9BQU8sRUFBRTtBQUM1RCxFOzs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDWEEsNkJBQTZCO0FBQzdCLHFDQUFxQyxnQzs7Ozs7O0FDRHJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0IsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw0QkFBNEI7QUFDNUIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCLDBCQUEwQixHQUFHO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0NBQWdDO0FBQ3hGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0RUFBNEUsWUFBWTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCw2Q0FBNkMsRUFBRTs7QUFFdEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRDtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTCxzRUFBc0U7QUFDdEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw0REFBNEQ7QUFDNUQ7QUFDQSxLQUFLO0FBQ0wsc0VBQXNFO0FBQ3RFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxzQkFBc0Isc0JBQXNCLEVBQUUsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNoQkEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQSxFOzs7Ozs7QUNYQTtBQUNBLG1GOzs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBLE9BQU8sVUFBVTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sV0FBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0IsdUJBQXVCLEdBQUc7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EscUJBQXFCO0FBQ3JCLEdBQUc7QUFDSCx5QkFBeUI7QUFDekIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlCQUFpQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxzQkFBc0I7QUFDaEYsZ0ZBQWdGLHNCQUFzQjtBQUN0RyxFOzs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYztBQUNkLGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEI7Ozs7Ozs7QUNqQ0E7Ozs7O0FBRU8sSUFBTUMsd0NBQWdCeEosT0FBT0MsTUFBUCxDQUFjO0FBQ3pDNEksT0FBSyxLQURvQztBQUV6Q0QsUUFBTSxNQUZtQztBQUd6Q2EsT0FBSztBQUhvQyxDQUFkLENBQXRCOztBQU1BLElBQU1DLHNEQUF1QjFKLE9BQU9DLE1BQVAsQ0FBYztBQUNoRDBKLFFBQU0sTUFEMEM7QUFFaERDLFFBQU0sTUFGMEM7QUFHaERDLFFBQU0sTUFIMEM7QUFJaERDLFNBQU8sT0FKeUM7QUFLaERDLFFBQU07QUFMMEMsQ0FBZCxDQUE3Qjs7QUFRQSxJQUFNQyxzREFBdUJoSyxPQUFPQyxNQUFQLENBQWM7QUFDaERnSyxPQUFLLEtBRDJDO0FBRWhEQyxRQUFNLE1BRjBDO0FBR2hESCxRQUFNO0FBSDBDLENBQWQsQ0FBN0IsQzs7Ozs7OztBQ2hCUDs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFFTyxJQUFNSSxrREFBcUIsU0FBckJBLGtCQUFxQixDQUFDQyxhQUFELEVBQWdCQyxZQUFoQixFQUFpQztBQUNqRSxNQUFJM1EsTUFBTSw4QkFBVjtBQUNBLE1BQU00TyxZQUFZOEIsY0FBYzFSLEVBQWhDO0FBQ0EsTUFBSTBSLGNBQWNFLFFBQWQsQ0FBdUJDLFdBQXZCLE9BQXlDLE9BQTdDLEVBQXNEO0FBQ3BELFFBQUlDLE1BQU0sa0JBQVluUyxhQUFaLENBQTBCLEtBQTFCLENBQVY7QUFDQW1TLFFBQUk5UixFQUFKLEdBQVM0UCxZQUFZLE9BQXJCO0FBQ0ErQixpQkFBYXBRLFdBQWIsQ0FBeUJ1USxHQUF6QjtBQUNBLFFBQUlKLGNBQWNLLGFBQWxCLEVBQWlDO0FBQy9CTCxvQkFBY0ssYUFBZCxDQUE0QkMsV0FBNUIsQ0FBd0NOLGFBQXhDO0FBQ0Q7QUFDRDFRLFFBQUlHLE9BQUosQ0FBWTJRLElBQUk5UixFQUFoQjtBQUNELEdBUkQsTUFRTztBQUNMZ0IsUUFBSUcsT0FBSixDQUFZeU8sU0FBWjtBQUNEO0FBQ0QsU0FBTzVPLElBQUlRLE9BQVg7QUFDRCxDQWZNOztBQWlCQSxJQUFNeVEsMENBQWlCLFNBQWpCQSxjQUFpQixDQUFDQyxNQUFELEVBQVM1SCxPQUFULEVBQWtCNkgsU0FBbEIsRUFBNkJwUSxTQUE3QixFQUF3QzZOLFNBQXhDLEVBQXNEO0FBQ2xGLE1BQUk1TyxNQUFNLDhCQUFWO0FBQ0EsTUFBSW9SLFNBQVM7QUFDWEMsYUFBUyxNQURFO0FBRVhDLFdBQU8sUUFGSTtBQUdYQyxhQUFTakksUUFBUWtJLGVBQVIsSUFBMkIsTUFIekI7QUFJWEMsdUJBQW1CLFFBSlI7QUFLWEMscUJBQWlCLE1BTE47QUFNWEMscUJBQWlCO0FBTk4sR0FBYjtBQVFBLE1BQUlDLGFBQWE7QUFDZjVTLFFBQUlrUyxNQURXO0FBRWZsWCxVQUFNa1gsTUFGUztBQUdmVyxXQUFPO0FBSFEsR0FBakI7QUFLQSxNQUFJOVEsVUFBVStRLHFCQUFWLENBQWdDeEksUUFBUXlJLGVBQXhDLENBQUosRUFBOEQ7QUFDNURoUixjQUFVaVIsUUFBVixDQUNFMUksUUFBUTJJLEdBRFYsRUFFRXJELFNBRkYsRUFHRXRGLFFBQVE0SSxVQUFSLElBQXNCLEdBSHhCLEVBSUU1SSxRQUFRNkksV0FBUixJQUF1QixHQUp6QixFQUtFN0ksUUFBUXlJLGVBTFYsRUFNRXpJLFFBQVE4SSxpQkFOVixFQU9FakIsU0FQRixFQVFFQyxNQVJGLEVBU0VRLFVBVEYsRUFVRTVSLElBQUlHLE9BVk47QUFXRCxHQVpELE1BWU87QUFDTEgsUUFBSW9FLE1BQUosQ0FBVyx3Q0FBWDtBQUNEO0FBQ0QsU0FBT3BFLElBQUlRLE9BQVg7QUFDRCxDQS9CTSxDOzs7Ozs7Ozs7Ozs7QUN0QkEsSUFBTTZFLDBCQUFTaUIsT0FBT0MsTUFBUCxDQUFjO0FBQ2xDaUosbUJBQWlCLGlCQURpQjtBQUVsQ0MsbUJBQWlCLGlCQUZpQjtBQUdsQzRDLGlCQUFlLGVBSG1CO0FBSWxDQyxnQkFBYyxjQUpvQjtBQUtsQ0Msd0JBQXNCLHFCQUxZO0FBTWxDQyxxQkFBbUIsbUJBTmU7QUFPbENDLG9CQUFrQixrQkFQZ0I7QUFRbENDLHFCQUFtQiw2QkFSZTtBQVNsQ0Msb0JBQWtCO0FBVGdCLENBQWQsQ0FBZjs7QUFZQSxJQUFNbk4sOEJBQVdjLE9BQU9DLE1BQVAsQ0FBYztBQUNwQ3FNLG9CQUFrQixrQkFEa0I7QUFFcENDLG9CQUFrQjtBQUZrQixDQUFkLENBQWpCOztBQUtBLElBQU12TixvQkFBTWdCLE9BQU9DLE1BQVAsQ0FBYztBQUMvQnVNLDBCQUF3Qiw4QkFETztBQUUvQkMsNkJBQTJCLGlDQUZJO0FBRy9CQyxlQUFhLG9CQUhrQjtBQUkvQkMsYUFBVyxrQkFKb0I7QUFLL0JDLHdCQUFzQjtBQUxTLENBQWQsQ0FBWjs7QUFRQSxJQUFNM04sc0JBQU9lLE9BQU9DLE1BQVAsQ0FBYztBQUNoQzRNLGlCQUFlLDJCQURpQjtBQUVoQ0MsaUJBQWU7QUFGaUIsQ0FBZCxDQUFiLEM7Ozs7Ozs7Ozs7OztBQ3pCQSxJQUFNL04sMEJBQVNpQixPQUFPQyxNQUFQLENBQWM7QUFDbENpSixtQkFBaUIsaUJBRGlCO0FBRWxDQyxtQkFBaUIsaUJBRmlCO0FBR2xDNEQsbUJBQWlCLGlCQUhpQjtBQUlsQ0Msa0JBQWdCLGdCQUprQjtBQUtsQ0Msa0JBQWdCLGdCQUxrQjtBQU1sQ0MsMEJBQXdCLHVCQU5VO0FBT2xDQyxzQkFBb0Isb0JBUGM7QUFRbENDLHlCQUF1Qix1QkFSVztBQVNsQ0Msa0JBQWdCLDBCQVRrQjtBQVVsQ2pCLHFCQUFtQiw2QkFWZTtBQVdsQ2tCLHNCQUFvQiw4QkFYYztBQVlsQ0MsaUJBQWUseUJBWm1CO0FBYWxDQyx3QkFBc0IsdUJBYlk7QUFjbENDLHlCQUF1QiwyQkFkVztBQWVsQ0MsNEJBQTBCO0FBZlEsQ0FBZCxDQUFmOztBQWtCQSxJQUFNeE8sOEJBQVdjLE9BQU9DLE1BQVAsQ0FBYztBQUNwQzBOLHFCQUFtQixtQkFEaUI7QUFFcENDLHFCQUFtQjtBQUZpQixDQUFkLENBQWpCOztBQUtBLElBQU01TyxvQkFBTWdCLE9BQU9DLE1BQVAsQ0FBYztBQUMvQndNLDZCQUEyQixpQ0FESTtBQUUvQkMsZUFBYSxvQkFGa0I7QUFHL0JDLGFBQVcsa0JBSG9CO0FBSS9Ca0IsZ0JBQWMscUJBSmlCO0FBSy9CQyxjQUFZLG1CQUxtQjtBQU0vQkMsbUJBQWlCLHdCQU5jO0FBTy9CQyxpQkFBZSxzQkFQZ0I7QUFRL0JwQix3QkFBc0I7QUFSUyxDQUFkLENBQVo7O0FBV0EsSUFBTTNOLHNCQUFPZSxPQUFPQyxNQUFQLENBQWM7QUFDaEM0TSxpQkFBZSwyQkFEaUI7QUFFaENDLGlCQUFlO0FBRmlCLENBQWQsQ0FBYixDOzs7Ozs7O0FDbENQOzs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQU1sSixPQUFPLDhCQUFiOztJQUVNcUssdUI7QUFFSixxQ0FBZTtBQUFBOztBQUNiLFNBQUtDLFFBQUwsR0FBZ0JqYixTQUFoQjtBQUNBLFNBQUtrYixpQkFBTCxHQUF5QixFQUF6QjtBQUNEOzs7O3VDQUVtQnJULE8sRUFBUztBQUMzQixXQUFLcVQsaUJBQUwsQ0FBdUJoYixJQUF2QixDQUE0QjJILE9BQTVCO0FBQ0Q7OzswQ0FFc0JBLE8sRUFBUztBQUM5QixVQUFJbkcsSUFBSSxLQUFLd1osaUJBQUwsQ0FBdUJ2WixNQUEvQjtBQUNBLFVBQUl3WixpQkFBSjtBQUNBLGFBQU0sRUFBRXpaLENBQUYsR0FBTSxDQUFDLENBQWIsRUFBZ0I7QUFDZHlaLG1CQUFXLEtBQUtELGlCQUFMLENBQXVCeFosQ0FBdkIsQ0FBWDtBQUNBLFlBQUl5WixhQUFhdFQsT0FBakIsRUFBMEI7QUFDeEIsZUFBS3FULGlCQUFMLENBQXVCdFAsTUFBdkIsQ0FBOEJsSyxDQUE5QixFQUFpQyxDQUFqQztBQUNBO0FBQ0Q7QUFDRjtBQUNGOzs7NENBRXdCeUksSyxFQUFPO0FBQzlCLHNCQUFNd0csSUFBTixFQUFZLHNCQUFaO0FBQ0EsVUFBSWpQLFVBQUo7QUFDQSxVQUFJQyxTQUFTLEtBQUt1WixpQkFBTCxDQUF1QnZaLE1BQXBDO0FBQ0EsVUFBSWtHLGdCQUFKO0FBQ0EsV0FBS25HLElBQUksQ0FBVCxFQUFZQSxJQUFJQyxNQUFoQixFQUF3QkQsR0FBeEIsRUFBNkI7QUFDM0JtRyxrQkFBVSxLQUFLcVQsaUJBQUwsQ0FBdUJ4WixDQUF2QixDQUFWO0FBQ0EsWUFBSW1HLFFBQVF1VCxPQUFSLENBQWdCbk0sS0FBS29NLEtBQUwsQ0FBV2xSLEtBQVgsQ0FBaEIsQ0FBSixFQUF3QztBQUN0QztBQUNEO0FBQ0Y7QUFDRjs7O2dEQUU0QjFKLEksRUFBTXlFLEUsRUFBSTtBQUNyQyxVQUFNb1csMkJBQTJCLEtBQUtDLHVCQUFMLENBQTZCekosSUFBN0IsQ0FBa0MsSUFBbEMsQ0FBakM7QUFDQSxVQUFNMEosT0FBT3RXLEdBQUdPLEVBQUgsQ0FBTTlDLEtBQU4sQ0FBWSxHQUFaLEVBQWlCMFIsSUFBakIsQ0FBc0IsR0FBdEIsQ0FBYjtBQUNBLFVBQU1vSCxjQUFjLENBQUMseUJBQUQsRUFBNEJELElBQTVCLEVBQWtDbkgsSUFBbEMsQ0FBdUMsR0FBdkMsQ0FBcEI7QUFDQSxzQkFBTTFELElBQU4sMENBQWtENkssSUFBbEQ7QUFDQSxzQkFBTTdLLElBQU4sa0NBQTBDOEssV0FBMUM7QUFDQXZXLFNBQUd3Vyx3QkFBSCxDQUE0QmpiLElBQTVCLEVBQWtDZ2IsV0FBbEM7QUFDQSx3QkFBWXJVLFNBQVosQ0FBc0JxVSxXQUF0QixFQUFtQ0gsd0JBQW5DO0FBQ0Q7Ozs0QkFFUUssSyxFQUFPO0FBQ2QsV0FBS1YsUUFBTCxHQUFnQixrQkFBWXhULGNBQVosQ0FBMkJrVSxLQUEzQixDQUFoQjtBQUNBLFVBQUksQ0FBQyxLQUFLVixRQUFWLEVBQW9CO0FBQ2xCLDJFQUF1RFUsS0FBdkQ7QUFDRDtBQUNGOzs7aUNBRWE7QUFDWixhQUFPLEtBQUtULGlCQUFMLENBQXVCdlosTUFBdkIsR0FBZ0MsQ0FBdkMsRUFBMEM7QUFDeEMsYUFBS3VaLGlCQUFMLENBQXVCalIsS0FBdkI7QUFDRDtBQUNGOzs7dUNBRW1CeEosSSxFQUFNbWIsUSxFQUFVemMsTyxFQUFTO0FBQzNDLHNCQUFNd1IsSUFBTixFQUFZLHNCQUFaO0FBQ0EsVUFBSTtBQUNGLGFBQUtzSyxRQUFMLENBQWNZLGdCQUFkLENBQStCcGIsSUFBL0IsRUFBcUNtYixRQUFyQyxFQUErQyxPQUFPemMsT0FBUCxLQUFtQixRQUFuQixHQUE4QkEsT0FBOUIsR0FBd0M4UCxLQUFLQyxTQUFMLENBQWUvUCxPQUFmLENBQXZGO0FBQ0QsT0FGRCxDQUdBLE9BQU8yQyxDQUFQLEVBQVU7QUFDUix1QkFBSyxzQ0FBc0NyQixJQUF0QyxHQUE2QyxZQUE3QyxHQUE0RHFCLEVBQUUzQyxPQUFuRTtBQUNEO0FBQ0Y7OzsrQ0FFMkJzQixJLEVBQU1xYixHLEVBQUt4VSxLLEVBQU87QUFDNUMsc0JBQU1xSixJQUFOLEVBQVksOEJBQVo7QUFDQSxVQUFJO0FBQ0YsYUFBS3NLLFFBQUwsQ0FBY2Msd0JBQWQsQ0FBdUN0YixJQUF2QyxFQUE2Q3FiLEdBQTdDLEVBQWtEeFUsS0FBbEQ7QUFDRCxPQUZELENBR0EsT0FBT3hGLENBQVAsRUFBVTtBQUNSLHVCQUFLLHNDQUFzQ3JCLElBQXRDLEdBQTZDLFlBQTdDLEdBQTREcUIsRUFBRTNDLE9BQW5FO0FBQ0Q7QUFDRjs7OzBDQUVzQnlOLGdCLEVBQWtCO0FBQ3ZDLHNCQUFNK0QsSUFBTixFQUFZLHlCQUFaO0FBQ0EsVUFBSTtBQUNGLGFBQUtxTCwyQkFBTCxDQUFpQ3BQLGdCQUFqQyxFQUFtRCxLQUFLcU8sUUFBeEQ7QUFDQSxhQUFLQSxRQUFMLENBQWNnQixxQkFBZCxDQUFvQ3JQLGdCQUFwQztBQUNELE9BSEQsQ0FJQSxPQUFPOUssQ0FBUCxFQUFVO0FBQ1IsdUJBQUsseUNBQXlDckIsSUFBekMsR0FBZ0QsWUFBaEQsR0FBK0RxQixFQUFFM0MsT0FBdEU7QUFDRDtBQUNGOzs7MENBRXNCeU4sZ0IsRUFBa0I7QUFDdkMsc0JBQU0rRCxJQUFOLEVBQVkseUJBQVo7QUFDQSxVQUFJO0FBQ0YsYUFBS3NLLFFBQUwsQ0FBY2lCLHFCQUFkLENBQW9DdFAsZ0JBQXBDO0FBQ0QsT0FGRCxDQUdBLE9BQU85SyxDQUFQLEVBQVU7QUFDUix1QkFBSyx5Q0FBeUNyQixJQUF6QyxHQUFnRCxZQUFoRCxHQUErRHFCLEVBQUUzQyxPQUF0RTtBQUNEO0FBQ0Y7OztzQ0FFa0J5TixnQixFQUFrQjtBQUNuQyxzQkFBTStELElBQU4sRUFBWSw0QkFBWjtBQUNBLFVBQUk7QUFDRixhQUFLc0ssUUFBTCxDQUFja0IsMEJBQWQsQ0FBeUN2UCxnQkFBekM7QUFDRCxPQUZELENBR0EsT0FBTzlLLENBQVAsRUFBVTtBQUNSLHVCQUFLLDRDQUE0Q3JCLElBQTVDLEdBQW1ELFlBQW5ELEdBQWtFcUIsRUFBRTNDLE9BQXpFO0FBQ0Q7QUFDRjs7Ozs7O2tCQUlZNmIsdUI7Ozs7Ozs7QUN2SGY7Ozs7Ozs7O0FBQ0E7O0lBQVlvQixTOztBQUNaOzs7O0FBQ0E7Ozs7Ozs7O0lBRU1DLFk7QUFFSix3QkFBYUMsU0FBYixFQUF3QjdiLElBQXhCLEVBQThCO0FBQUE7O0FBQzVCLFNBQUs4YixVQUFMLEdBQWtCRCxTQUFsQjtBQUNBLFNBQUtFLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQnpjLFNBQWxCO0FBQ0EsU0FBSzBjLGtCQUFMLEdBQTBCMWMsU0FBMUI7QUFDQSxTQUFLNk0sS0FBTCxHQUFhcE0sSUFBYjtBQUNBLFNBQUt5YSxpQkFBTCxHQUF5QixFQUF6QjtBQUNBLFNBQUt5QixhQUFMLEdBQXFCLEtBQXJCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixLQUFLQyxRQUFMLENBQWMvSyxJQUFkLENBQW1CLElBQW5CLENBQWhCO0FBQ0Q7Ozs7MENBRXNCZ0wsRSxFQUFJO0FBQ3pCQSxTQUFHQyxNQUFILEdBQVkvYyxTQUFaO0FBQ0E4YyxTQUFHRSxTQUFILEdBQWVoZCxTQUFmO0FBQ0E4YyxTQUFHRyxPQUFILEdBQWFqZCxTQUFiO0FBQ0E4YyxTQUFHSSxPQUFILEdBQWFsZCxTQUFiO0FBQ0Q7Ozt1Q0FFbUI4YyxFLEVBQUk3VixPLEVBQVM7QUFBQTs7QUFFL0I2VixTQUFHQyxNQUFILEdBQVksWUFBTTtBQUNoQix1QkFBSyxNQUFLbFEsS0FBVixFQUFpQixpQkFBakI7QUFDQSxlQUFPLE1BQUsyUCxvQkFBTCxDQUEwQjdhLE1BQTFCLEdBQW1DLENBQTFDLEVBQTZDO0FBQzNDLGdCQUFLd2IsSUFBTCxDQUFVLE1BQUtYLG9CQUFMLENBQTBCdlMsS0FBMUIsRUFBVjtBQUNEO0FBQ0YsT0FMRDs7QUFPQTZTLFNBQUdHLE9BQUgsR0FBYSxVQUFDbGMsS0FBRCxFQUFXO0FBQ3RCLGNBQUs4YixRQUFMO0FBQ0EsdUJBQUssTUFBS2hRLEtBQVYsK0NBQTREOUwsTUFBTVgsSUFBbEU7QUFDQTZHLGdCQUFRNEQsTUFBUixDQUFlOUosS0FBZjtBQUNELE9BSkQ7O0FBTUErYixTQUFHRSxTQUFILEdBQWUsVUFBQzdkLE9BQUQsRUFBYTtBQUMxQixjQUFLaWMsT0FBTCxDQUFhamMsT0FBYjtBQUNELE9BRkQ7O0FBSUEyZCxTQUFHSSxPQUFILEdBQWEsVUFBQy9TLEtBQUQsRUFBVztBQUN0Qix1QkFBSyxNQUFLMEMsS0FBVix5QkFBc0MxQyxNQUFNaVQsSUFBNUM7QUFDQSxZQUFJLE1BQUtiLFVBQVQsRUFBcUI7QUFDbkIsZ0JBQUtBLFVBQUwsQ0FBZ0JjLGFBQWhCLENBQThCbFQsS0FBOUI7QUFDRDtBQUNELGNBQUswUyxRQUFMO0FBQ0QsT0FORDtBQVFEOzs7NENBRXdCOWIsSyxFQUFPO0FBQzlCLFVBQUksS0FBS3diLFVBQVQsRUFBcUI7QUFDbkIsYUFBS0EsVUFBTCxDQUFnQmMsYUFBaEIsQ0FBOEJ0YyxLQUE5QjtBQUNEO0FBQ0QscUJBQUssS0FBSzhMLEtBQVYsMERBQXVFOUwsTUFBTVgsSUFBN0UsVUFBc0ZXLE1BQU11YyxNQUE1RjtBQUNBLFdBQUtULFFBQUw7QUFDRDs7OzBCQUVNalgsRyxFQUFLMlgsWSxFQUFjO0FBQ3hCLFdBQUtWLFFBQUw7QUFDQSxXQUFLRixhQUFMLEdBQXFCLEtBQXJCO0FBQ0EsV0FBS0Qsa0JBQUwsR0FBMEJhLFlBQTFCO0FBQ0Esd0JBQVkzVixlQUFaLENBQTRCLEtBQUtnVixRQUFqQztBQUNBLFdBQUtILFVBQUwsR0FBa0JMLFVBQVUzRyxNQUFWLENBQWlCN1AsR0FBakIsQ0FBbEI7QUFDQSxXQUFLNFgsa0JBQUwsQ0FBd0IsS0FBS2YsVUFBN0IsRUFBeUMsS0FBS0Msa0JBQTlDO0FBQ0Q7OzsrQkFFVztBQUNWLFdBQUtGLG9CQUFMLENBQTBCN2EsTUFBMUIsR0FBbUMsQ0FBbkM7QUFDQSxVQUFJLE9BQU8sS0FBSzhhLFVBQVosS0FBMkIsV0FBL0IsRUFBNEM7QUFDMUMsYUFBS2dCLHFCQUFMLENBQTJCLEtBQUtoQixVQUFoQztBQUNBLGFBQUtBLFVBQUwsQ0FBZ0JpQixLQUFoQjtBQUNEO0FBQ0QsV0FBS2pCLFVBQUwsR0FBa0J6YyxTQUFsQjtBQUNBLFdBQUsyYyxhQUFMLEdBQXFCLElBQXJCO0FBQ0EsYUFBTSxLQUFLekIsaUJBQUwsQ0FBdUJ2WixNQUF2QixHQUFnQyxDQUF0QyxFQUF5QztBQUN2QyxhQUFLdVosaUJBQUwsQ0FBdUJqUixLQUF2QjtBQUNEO0FBQ0Qsd0JBQVkvQixrQkFBWixDQUErQixLQUFLMFUsUUFBcEM7QUFDRDs7OzZDQUV5QnpkLE8sRUFBUztBQUNqQyxVQUFJO0FBQ0YsZUFBTyxPQUFPQSxRQUFRa0osSUFBZixLQUF3QixRQUF4QixHQUFtQzRHLEtBQUtvTSxLQUFMLENBQVdsYyxRQUFRa0osSUFBbkIsQ0FBbkMsR0FBOERsSixRQUFRa0osSUFBN0U7QUFDRCxPQUZELENBR0EsT0FBT3ZHLENBQVAsRUFBVTtBQUNSLHVCQUFLLEtBQUsrSyxLQUFWLEVBQWlCLCtDQUErQzFOLFFBQVFrSixJQUF2RCxHQUE4RCxXQUE5RCxHQUE0RXZHLEVBQUUzQyxPQUEvRjtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7OzttREFFK0IwSSxPLEVBQVM7QUFDdkMsV0FBS3FULGlCQUFMLENBQXVCaGIsSUFBdkIsQ0FBNEIySCxPQUE1QjtBQUNEOzs7c0RBRWtDQSxPLEVBQVM7QUFDMUMsVUFBSW5HLElBQUksS0FBS3daLGlCQUFMLENBQXVCdlosTUFBL0I7QUFDQSxVQUFJd1osaUJBQUo7QUFDQSxhQUFNLEVBQUV6WixDQUFGLEdBQU0sQ0FBQyxDQUFiLEVBQWdCO0FBQ2R5WixtQkFBVyxLQUFLRCxpQkFBTCxDQUF1QnhaLENBQXZCLENBQVg7QUFDQSxZQUFJeVosYUFBYXRULE9BQWpCLEVBQTBCO0FBQ3hCLGVBQUtxVCxpQkFBTCxDQUF1QnRQLE1BQXZCLENBQThCbEssQ0FBOUIsRUFBaUMsQ0FBakM7QUFDQTtBQUNEO0FBQ0Y7QUFDRjs7OzBDQUVzQnZDLE8sRUFBUztBQUM5QixVQUFJdUMsVUFBSjtBQUFBLFVBQU9tRyxnQkFBUDtBQUNBLFVBQUlsRyxTQUFTLEtBQUt1WixpQkFBTCxDQUF1QnZaLE1BQXBDO0FBQ0EsV0FBS0QsSUFBSSxDQUFULEVBQVlBLElBQUlDLE1BQWhCLEVBQXdCRCxHQUF4QixFQUE2QjtBQUMzQm1HLGtCQUFVLEtBQUtxVCxpQkFBTCxDQUF1QnhaLENBQXZCLENBQVY7QUFDQSxZQUFJbUcsUUFBUXVULE9BQVIsQ0FBZ0JqYyxPQUFoQixDQUFKLEVBQThCO0FBQzVCLGlCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7Ozt5QkFFS3dlLFcsRUFBYTtBQUNqQixVQUFJLEtBQUtsQixVQUFMLEtBQW9CemMsU0FBcEIsSUFBaUMsS0FBS3ljLFVBQUwsQ0FBZ0IzVixVQUFoQixLQUErQixDQUFwRSxDQUFzRSxvQkFBdEUsRUFBNEY7QUFDMUYsY0FBSTtBQUNGLDRCQUFNLEtBQUsrRixLQUFYLEVBQWtCLHVCQUF1Qm9DLEtBQUtDLFNBQUwsQ0FBZXlPLFdBQWYsRUFBNEIsSUFBNUIsRUFBa0MsQ0FBbEMsQ0FBekM7QUFDQSxpQkFBS2xCLFVBQUwsQ0FBZ0JtQixJQUFoQixDQUFxQjNPLEtBQUtDLFNBQUwsQ0FBZXlPLFdBQWYsQ0FBckI7QUFDQSxtQkFBTyxJQUFQO0FBQ0QsV0FKRCxDQUtBLE9BQU83YixDQUFQLEVBQVU7QUFDUiw0QkFBTSxLQUFLK0ssS0FBWCwrQkFBNkM4USxXQUE3QyxVQUE2RDdiLENBQTdEO0FBQ0EsbUJBQU8sS0FBUDtBQUNEO0FBQ0YsU0FWRCxNQVdLLElBQUksS0FBSzJhLFVBQUwsS0FBb0J6YyxTQUFwQixLQUNKLEtBQUt5YyxVQUFMLENBQWdCM1YsVUFBaEIsS0FBK0IsQ0FBL0IsSUFBb0MsS0FBSzJWLFVBQUwsQ0FBZ0IzVixVQUFoQixLQUErQixDQUQvRCxDQUFKLEVBQ3VFLGtDQUFtQztBQUM3RyxpQkFBTyxLQUFQO0FBQ0QsU0FISSxNQUlBLElBQUksS0FBSzZWLGFBQVQsRUFBd0I7QUFDM0IsZUFBTyxLQUFQO0FBQ0QsT0FGSSxNQUdBO0FBQ0gsYUFBS0gsb0JBQUwsQ0FBMEJ0YyxJQUExQixDQUErQnlkLFdBQS9CO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRjs7OzRCQUVReGUsTyxFQUFTO0FBQUU7QUFDbEIsVUFBSTBlLFVBQVUsS0FBS0MscUJBQUwsQ0FBMkIzZSxPQUEzQixDQUFkO0FBQ0EsVUFBSSxDQUFDMGUsT0FBRCxJQUFZMWUsUUFBUWtKLElBQXhCLEVBQThCO0FBQzVCLFlBQUkwVixPQUFPLEtBQUtDLHdCQUFMLENBQThCN2UsT0FBOUIsQ0FBWDtBQUNBLFlBQUk0ZSxTQUFTLElBQWIsRUFBbUI7QUFDakIseUJBQUssS0FBS2xSLEtBQVYsRUFBaUIsK0VBQWpCO0FBQ0EsaUJBQU8sSUFBUDtBQUNEO0FBQ0Qsd0JBQU0sS0FBS0EsS0FBWCxFQUFrQiwyQkFBMkJvQyxLQUFLQyxTQUFMLENBQWU2TyxJQUFmLEVBQXFCLElBQXJCLEVBQTJCLENBQTNCLENBQTdDO0FBQ0EsWUFBSUEsS0FBS0UsV0FBTCxLQUFxQmplLFNBQXpCLEVBQW9DO0FBQ2xDLGNBQUksT0FBTytkLEtBQUtFLFdBQVosS0FBNEIsU0FBNUIsSUFBeUNGLEtBQUtFLFdBQWxELEVBQStEO0FBQzdELGlCQUFLMUIsVUFBTCxDQUFnQjJCLGlCQUFoQixDQUFrQ0gsSUFBbEM7QUFDQSxtQkFBTyxJQUFQO0FBQ0QsV0FIRCxNQUdPO0FBQ0wsaUJBQUt4QixVQUFMLENBQWdCNEIsbUJBQWhCLENBQW9DSixJQUFwQztBQUNBLG1CQUFPLElBQVA7QUFDRDtBQUNGLFNBUkQsTUFRTyxJQUFJQSxLQUFLMVYsSUFBTCxLQUFjckksU0FBbEIsRUFBNkI7QUFDbEMsY0FBSStkLEtBQUsxVixJQUFMLENBQVVsSixPQUFWLEtBQXNCYSxTQUExQixFQUFxQztBQUNuQyxnQkFBSStkLEtBQUsxVixJQUFMLENBQVVqSSxJQUFWLEtBQW1CLE9BQXZCLEVBQWdDO0FBQzlCLG1CQUFLbWMsVUFBTCxDQUFnQjZCLG9CQUFoQixDQUFxQ0wsS0FBSzFWLElBQUwsQ0FBVWxKLE9BQS9DLEVBQXdENGUsS0FBSzFWLElBQUwsQ0FBVWlWLE1BQWxFO0FBQ0EscUJBQU8sSUFBUDtBQUNEO0FBQ0YsV0FMRCxNQU1LLElBQUlTLEtBQUsxVixJQUFMLENBQVVqSSxJQUFWLEtBQW1CLFFBQXZCLEVBQWlDO0FBQ3BDLGdCQUFJMmQsS0FBSzFWLElBQUwsQ0FBVStVLElBQVYsS0FBbUIsK0JBQXZCLEVBQXdEO0FBQ3RELG1CQUFLWCxVQUFMLENBQWdCUSxPQUFoQixHQUEwQixLQUFLb0IsdUJBQUwsQ0FBNkJ2TSxJQUE3QixDQUFrQyxJQUFsQyxDQUExQjtBQUNBLG1CQUFLNEssa0JBQUwsQ0FBd0I5VixPQUF4QjtBQUNBLHFCQUFPLElBQVA7QUFDRCxhQUpELE1BS0ssSUFBSW1YLEtBQUsxVixJQUFMLENBQVUrVSxJQUFWLEtBQW1CLGdDQUF2QixFQUF5RDtBQUM1RCxtQkFBS1Ysa0JBQUwsQ0FBd0I3UixNQUF4QixDQUErQixnQ0FBL0I7QUFDQSxxQkFBTyxJQUFQO0FBQ0Q7QUFDRixXQVZJLE1BV0EsSUFBSWtULEtBQUsxVixJQUFMLENBQVVqSSxJQUFWLEtBQW1CLE9BQXZCLEVBQWdDO0FBQ25DLGdCQUFJMmQsS0FBSzFWLElBQUwsQ0FBVStVLElBQVYsS0FBbUIsZ0NBQXZCLEVBQXlEO0FBQ3ZELG1CQUFLVixrQkFBTCxDQUF3QjdSLE1BQXhCLENBQStCLGdDQUEvQjtBQUNBLHFCQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNELGFBQU9nVCxPQUFQO0FBQ0Q7OzswQ0FFc0JwZCxJLEVBQU07QUFDM0IsV0FBSzBjLElBQUwsQ0FBVTtBQUNSbUIsK0JBQXVCO0FBQ3JCN2QsZ0JBQU1BO0FBRGU7QUFEZixPQUFWO0FBS0Q7OzswQ0FFc0JBLEksRUFBTTtBQUMzQixXQUFLMGMsSUFBTCxDQUFVO0FBQ1JvQiw2QkFBcUI7QUFDbkI5ZCxnQkFBTUE7QUFEYTtBQURiLE9BQVY7QUFLRDs7O3VDQUVtQkEsSSxFQUFNbWIsUSxFQUFVdlQsSSxFQUFNO0FBQ3hDLFdBQUs4VSxJQUFMLENBQVU7QUFDUnRCLDBCQUFrQjtBQUNoQnBiLGdCQUFNQSxJQURVO0FBRWhCOEgsZ0JBQU1xVCxRQUZVO0FBR2hCL0Qsa0JBQVEsQ0FBQ3hQLElBQUQ7QUFIUTtBQURWLE9BQVY7QUFPRDs7OytDQUUyQjVILEksRUFBTXFiLEcsRUFBS3hVLEssRUFBTztBQUM1QyxXQUFLNlYsSUFBTCxDQUFVO0FBQ1JxQixpQ0FBeUI7QUFDdkIvZCxnQkFBTUEsSUFEaUI7QUFFdkJxYixlQUFLQSxHQUZrQjtBQUd2QnhVLGlCQUFPQTtBQUhnQjtBQURqQixPQUFWO0FBT0Q7OztzQ0FFa0I3RyxJLEVBQU07QUFDdkIsV0FBSzBjLElBQUwsQ0FBVTtBQUNSc0IsMkJBQW1CO0FBQ2pCaGUsZ0JBQU1BO0FBRFc7QUFEWCxPQUFWO0FBS0Q7Ozs7OztrQkFJWTRiLFk7Ozs7Ozs7QUNoUGY7Ozs7Ozs7O0FBRUEsSUFBTXFDLFVBQVUsU0FBVkEsT0FBVSxDQUFDQyxHQUFELEVBQU10WCxJQUFOLEVBQVlDLEtBQVosRUFBc0I7QUFDcEN5RixTQUFPNlIsY0FBUCxDQUFzQkQsR0FBdEIsRUFBMkJ0WCxJQUEzQixFQUFpQztBQUMvQkMsV0FBT0EsS0FEd0I7QUFFL0J1WCxjQUFVLElBRnFCO0FBRy9CQyxnQkFBWTtBQUhtQixHQUFqQztBQUtELENBTkQ7O0lBUU1DLHVCLEdBRUosbUNBQWU7QUFBQTs7QUFDYkwsVUFBUSxJQUFSLEVBQWMsT0FBZCxFQUF1QjtBQUNyQi9RLFdBQU87QUFEYyxHQUF2QjtBQUdBK1EsVUFBUSxJQUFSLEVBQWMsUUFBZCxFQUF3QjtBQUN0Qi9RLFdBQU87QUFEZSxHQUF4QjtBQUdELEM7O0lBSUdxUix3QixHQUVKLG9DQUFlO0FBQUE7O0FBQ2JOLFVBQVEsSUFBUixFQUFjLE9BQWQsRUFBdUIsR0FBdkI7QUFDQUEsVUFBUSxJQUFSLEVBQWMsUUFBZCxFQUF3QixHQUF4QjtBQUNBQSxVQUFRLElBQVIsRUFBYyxPQUFkLEVBQXVCLEtBQXZCO0FBQ0FBLFVBQVEsSUFBUixFQUFjLFdBQWQsRUFBMkIsRUFBM0I7QUFDQUEsVUFBUSxJQUFSLEVBQWMsV0FBZCxFQUEyQixLQUEzQjtBQUNBQSxVQUFRLElBQVIsRUFBYyxTQUFkLEVBQXlCLEVBQXpCO0FBQ0FBLFVBQVEsSUFBUixFQUFjLFNBQWQsRUFBeUIsVUFBekI7QUFDQUEsVUFBUSxJQUFSLEVBQWMsT0FBZCxFQUF1QixHQUF2QjtBQUNELEM7O0lBSUdPLGtCLEdBRUosOEJBQThDO0FBQUEsTUFBakNoUCxLQUFpQyx1RUFBekIsSUFBeUI7QUFBQSxNQUFuQnhDLEtBQW1CLHVFQUFYek4sU0FBVzs7QUFBQTs7QUFDNUMwZSxVQUFRLElBQVIsRUFBYyxPQUFkLEVBQXVCek8sS0FBdkI7QUFDQXlPLFVBQVEsSUFBUixFQUFjLE9BQWQsRUFBdUJqUixTQUFTLElBQUlzUix1QkFBSixFQUFoQztBQUNELEM7O0lBR0dHLG1CLEdBRUosK0JBQThDO0FBQUEsTUFBakNqUCxLQUFpQyx1RUFBekIsSUFBeUI7QUFBQSxNQUFuQnhDLEtBQW1CLHVFQUFYek4sU0FBVzs7QUFBQTs7QUFDNUMwZSxVQUFRLElBQVIsRUFBYyxPQUFkLEVBQXVCek8sS0FBdkI7QUFDQXlPLFVBQVEsSUFBUixFQUFjLE9BQWQsRUFBdUJqUixTQUFTLElBQUl1Uix3QkFBSixFQUFoQztBQUNELEM7O1FBR01DLGtCLEdBQUFBLGtCO1FBQW9CQyxtQixHQUFBQSxtQjs7Ozs7OztBQ3REN0I7Ozs7Ozs7OztBQUVBOzs7Ozs7OztJQUVNQyxXOzs7QUFFSix1QkFBYS9lLElBQWIsRUFBbUJnZixPQUFuQixFQUE0Qi9XLElBQTVCLEVBQWtDO0FBQUE7O0FBQUEsMEhBQzFCakksSUFEMEIsRUFDcEJpSSxJQURvQjs7QUFFaEMsVUFBS2dYLFFBQUwsR0FBZ0JELE9BQWhCO0FBRmdDO0FBR2pDOzs7O3dCQUVjO0FBQ2IsYUFBTyxLQUFLQyxRQUFaO0FBQ0Q7Ozs7OztBQUlILElBQU1DLG1CQUFtQnZTLE9BQU9DLE1BQVAsQ0FBYztBQUNyQzJHLGdCQUFjLGFBRHVCO0FBRXJDSixVQUFRLFFBRjZCO0FBR3JDTSxtQkFBaUI7QUFIb0IsQ0FBZCxDQUF6Qjs7UUFNd0JzTCxXLEdBQWZBLFc7UUFDb0JHLGdCLEdBQXBCQSxnQjs7Ozs7OztBQ3hCVDs7Ozs7Ozs7Ozs7QUFFQTs7OztBQUVBLElBQU1oZixNQUFNLElBQUlpZixPQUFKLEVBQVo7O0FBRUEsSUFBTUMsTUFBTSxTQUFOQSxHQUFNLENBQUNDLEdBQUQsRUFBUztBQUNuQixNQUFJLENBQUNuZixJQUFJb2YsR0FBSixDQUFRRCxHQUFSLENBQUwsRUFBbUI7QUFDakJuZixRQUFJcWYsR0FBSixDQUFRRixHQUFSLEVBQWEsRUFBYjtBQUNEOztBQUVELFNBQU9uZixJQUFJc2YsR0FBSixDQUFRSCxHQUFSLENBQVA7QUFDRCxDQU5EOztJQVFhSSxnQixXQUFBQSxnQjtBQUVYLDhCQUFlO0FBQUE7O0FBQUE7O0FBQ2IsU0FBS0MsU0FBTCxHQUFrQixZQUFZO0FBQzVCLHFDQUFPLFNBQVdBLFNBQVgsQ0FBc0J6ZixJQUF0QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQ0VBLEtBQUtzQixNQUFMLEdBQWMsQ0FEaEI7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSx1QkFFR3RCLEtBQUs0SixLQUFMLEVBRkg7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFXNlYsU0FBWDtBQUFBLE9BQVA7QUFLRCxLQU5pQixFQUFsQjs7QUFRQU4sUUFBSSxJQUFKLEVBQVVPLElBQVYsR0FBaUIsVUFBQ0MsUUFBRCxFQUFXMWYsR0FBWCxFQUFnQnlQLE9BQWhCLEVBQXlCOUksT0FBekIsRUFBc0U7QUFBQSxVQUFwQ2daLE1BQW9DLHVFQUEzQixJQUEyQjtBQUFBLFVBQXJCQyxTQUFxQix1RUFBVCxJQUFTOztBQUFBLHNCQUNoRVYsV0FBVVcsSUFBVixDQUFlSCxRQUFmLEVBQXlCMWYsR0FBekIsQ0FEZ0U7QUFBQTtBQUFBLFVBQzlFRixJQUQ4RTtBQUFBLFVBQ3hFZ2dCLElBRHdFOztBQUVyRixVQUFJLENBQUNBLElBQUwsRUFBVztBQUNUblosZ0JBQVE0RCxNQUFSLENBQWVxVixTQUFmO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBSXRSLFVBQUo7QUFDQSxZQUFJMUksTUFBTTZKLFFBQVEzUCxJQUFSLENBQVY7QUFDQThGLGNBQU1BLE9BQU82SixPQUFiO0FBQ0EsWUFBSWtRLE1BQUosRUFBWTtBQUNWclIsY0FBSSxJQUFJd1IsSUFBSixHQUFXSCxNQUFYLEVBQW1CL1osR0FBbkIsQ0FBSjtBQUNELFNBRkQsTUFFTztBQUNMMEksY0FBSSxJQUFJd1IsSUFBSixDQUFTbGEsR0FBVCxDQUFKO0FBQ0Q7QUFDRDBJLFVBQUVFLElBQUYsQ0FBTyxVQUFDdVIsUUFBRCxFQUFjO0FBQ25CcFosa0JBQVFMLE9BQVIsQ0FBZ0J5WixRQUFoQjtBQUNELFNBRkQsRUFHQ3JSLEtBSEQsQ0FHTyxpQkFBUztBQUFFO0FBQ2hCa1Isc0JBQVluZixLQUFaO0FBQ0F5ZSxxQkFBVU8sSUFBVixDQUFlQyxRQUFmLEVBQXlCMWYsR0FBekIsRUFBOEJ5UCxPQUE5QixFQUF1QzlJLE9BQXZDLEVBQWdEZ1osTUFBaEQsRUFBd0RDLFNBQXhEO0FBQ0QsU0FORDtBQU9EO0FBQ0YsS0FyQkQ7O0FBdUJBVixRQUFJLElBQUosRUFBVVcsSUFBVixHQUFpQixVQUFDRyxLQUFELEVBQVFoZ0IsR0FBUixFQUFnQjtBQUMvQixVQUFJOGYsYUFBSjtBQUNBLFVBQUl0RSxZQUFKO0FBQ0EsVUFBTXFFLE9BQU9HLE1BQU1ILElBQU4sRUFBYjtBQUNBLFVBQUksQ0FBQ0EsS0FBS0ksSUFBVixFQUFnQjtBQUNkekUsY0FBTXFFLEtBQUs3WSxLQUFYO0FBQ0E4WSxlQUFPOWYsSUFBSXNmLEdBQUosQ0FBUTlELEdBQVIsQ0FBUDtBQUNEO0FBQ0QsYUFBTyxDQUFDQSxHQUFELEVBQU1zRSxJQUFOLENBQVA7QUFDRCxLQVREO0FBVUQ7Ozs7MkJBRU9FLEssRUFBT2hnQixHLEVBQUt5UCxPLEVBQXdCO0FBQUEsVUFBZmtRLE1BQWUsdUVBQU4sSUFBTTs7QUFDMUMsVUFBTWhaLFVBQVUsOEJBQWhCO0FBQ0F1WSxVQUFJLElBQUosRUFBVU8sSUFBVixDQUFlLEtBQUtELFNBQUwsQ0FBZVEsTUFBTXZZLEtBQU4sRUFBZixDQUFmLEVBQThDekgsR0FBOUMsRUFBbUR5UCxPQUFuRCxFQUE0RDlJLE9BQTVELEVBQXFFZ1osTUFBckU7QUFDQSxhQUFPaFosUUFBUUEsT0FBZjtBQUNEOzs7Ozs7a0JBSVk0WSxnQjs7Ozs7OztBQ3BFZjs7QUFFQTs7Ozs7QUFDTyxJQUFNVyx3QkFBUSxTQUFSQSxLQUFRLENBQUNDLEVBQUQsRUFBUTtBQUMzQixNQUFJQyxRQUFRRCxHQUFHOWUsTUFBZjtBQUNBLFNBQU8sU0FBU2dmLEVBQVQsR0FBYztBQUNuQixRQUFNQyxPQUFPQyxNQUFNQyxTQUFOLENBQWdCL1ksS0FBaEIsQ0FBc0JRLElBQXRCLENBQTJCd1ksU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBYjtBQUNBLFFBQUlILEtBQUtqZixNQUFMLElBQWUrZSxLQUFuQixFQUEwQjtBQUN4QixhQUFPRCxHQUFHTyxLQUFILENBQVMsSUFBVCxFQUFlSixJQUFmLENBQVA7QUFDRCxLQUZELE1BR0s7QUFDSCxhQUFPLFNBQVNLLEVBQVQsR0FBYztBQUNuQixZQUFNQyxRQUFRTCxNQUFNQyxTQUFOLENBQWdCL1ksS0FBaEIsQ0FBc0JRLElBQXRCLENBQTJCd1ksU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBZDtBQUNBLGVBQU9KLEdBQUdLLEtBQUgsQ0FBUyxJQUFULEVBQWVKLEtBQUtwZ0IsTUFBTCxDQUFZMGdCLEtBQVosQ0FBZixDQUFQO0FBQ0QsT0FIRDtBQUlEO0FBQ0YsR0FYRDtBQVlELENBZE07O0FBZ0JBLElBQU1DLDBCQUFTWCxNQUFNLFVBQUN0ZCxFQUFELEVBQUs3QyxJQUFMLEVBQWM7QUFDeEMsTUFBSStnQixNQUFNLENBQVY7QUFDQSxNQUFJQyxNQUFNaGhCLEtBQUtzQixNQUFmO0FBQ0EsTUFBSTJmLFNBQVMsRUFBYjs7QUFFQSxTQUFPRixNQUFNQyxHQUFiLEVBQWtCO0FBQ2hCLFFBQUluZSxHQUFHN0MsS0FBSytnQixHQUFMLENBQUgsQ0FBSixFQUFtQjtBQUNqQkUsYUFBT0EsT0FBTzNmLE1BQWQsSUFBd0J0QixLQUFLK2dCLEdBQUwsQ0FBeEI7QUFDRDtBQUNEQSxXQUFPLENBQVA7QUFDRDtBQUNELFNBQU9FLE1BQVA7QUFDRCxDQVpxQixDQUFmOztBQWNBLElBQU1DLHdCQUFRLFNBQVJBLEtBQVEsQ0FBQ2phLEtBQUQsRUFBVztBQUM5QixNQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBT0EsTUFBTTRNLFFBQU4sQ0FBZSxFQUFmLENBQVA7QUFDRCxHQUZELE1BR0s7QUFDSCxXQUFPTSxLQUFLZ04sS0FBTCxDQUFXbGEsS0FBWCxDQUFQO0FBQ0Q7QUFDRixDQVBNOztBQVNBLElBQU1tYSxnQ0FBWSxTQUFaQSxTQUFZLENBQUNuYSxLQUFELEVBQVFvYSxZQUFSLEVBQXlCO0FBQ2hELFNBQU9wYSxTQUFTb2EsWUFBaEI7QUFDRCxDQUZNOztBQUlBLElBQU1DLHNDQUFlLFNBQWZBLFlBQWUsQ0FBQ3JhLEtBQUQsRUFBUW9hLFlBQVIsRUFBeUI7QUFDbkQsU0FBTyxDQUFDRSxNQUFNTCxNQUFNamEsS0FBTixDQUFOLENBQUQsR0FBdUJpYSxNQUFNamEsS0FBTixDQUF2QixHQUFzQ29hLFlBQTdDO0FBQ0QsQ0FGTSxDOzs7Ozs7O0FDOUNQOztBQUVBOzs7Ozs7O0FBR08sSUFBTUcsa0NBQWEsU0FBYkEsVUFBYSxDQUFDQyxNQUFELEVBQVNDLEtBQVQsRUFBZ0J6YSxLQUFoQixFQUEwQjtBQUNsRCxNQUFJNUYsSUFBSSxDQUFSO0FBQ0EsTUFBSXNnQixPQUFPRixNQUFYO0FBQ0EsTUFBTXphLE9BQU8wYSxNQUFNRSxHQUFOLEVBQWI7QUFDQSxNQUFNdGdCLFNBQVNvZ0IsTUFBTXBnQixNQUFyQjtBQUNBLE9BQUtELENBQUwsRUFBUUEsSUFBSUMsTUFBWixFQUFvQkQsR0FBcEIsRUFBeUI7QUFDdkIsUUFBSXdnQixPQUFPSCxNQUFNcmdCLENBQU4sQ0FBWDtBQUNBc2dCLFNBQUtFLElBQUwsSUFBYUYsS0FBS0UsSUFBTCxLQUFjLEVBQTNCO0FBQ0FGLFdBQU9BLEtBQUtFLElBQUwsQ0FBUDtBQUNEO0FBQ0RGLE9BQUszYSxJQUFMLElBQWFDLEtBQWI7QUFDRCxDQVhNOztBQWFBLElBQU02YSw4QkFBVyxTQUFYQSxRQUFXLENBQUN4RCxHQUFELEVBQVM7QUFDL0IsTUFBTXlELE1BQU1uVCxLQUFLQyxTQUFMLENBQWV5UCxHQUFmLENBQVo7QUFDQSxTQUFPMVAsS0FBS29NLEtBQUwsQ0FBVytHLEdBQVgsQ0FBUDtBQUNELENBSE0sQzs7Ozs7OztBQ2xCUDs7Ozs7Ozs7QUFFTyxJQUFNQyxzRUFBK0IsU0FBL0JBLDRCQUErQixDQUFDdFMsT0FBRCxFQUFpQztBQUFBLE1BQXZCOEgsTUFBdUIsdUVBQWQ3WCxTQUFjOztBQUMzRSxNQUFNc2lCLFdBQVd2UyxRQUFRd1MsVUFBUixJQUFzQnhTLFFBQVF1UyxRQUEvQztBQUNBLE1BQU1FLE9BQU96UyxRQUFRMFMsTUFBUixJQUFrQjFTLFFBQVF5UyxJQUF2QztBQUNBLE1BQU1FLGNBQWMzUyxRQUFRNFMsT0FBUixHQUFrQixDQUFDNVMsUUFBUTZTLEdBQVQsRUFBYzdTLFFBQVE0UyxPQUF0QixFQUErQnRPLElBQS9CLENBQW9DLEdBQXBDLENBQWxCLEdBQTZEdEUsUUFBUTZTLEdBQXpGO0FBQ0EsTUFBSUMsV0FBY1AsUUFBZCxXQUE0QnZTLFFBQVErUyxJQUFwQyxTQUE0Q04sSUFBNUMsU0FBb0RFLFdBQXhEO0FBQ0EsTUFBSSxPQUFPM1MsUUFBUWdULGdCQUFmLEtBQW9DLFdBQXhDLEVBQXFEO0FBQ25EbEwsYUFBUyxTQUFjQSxNQUFkLEVBQXNCOUgsUUFBUWdULGdCQUE5QixDQUFUO0FBQ0Q7QUFDRCxNQUFJLE9BQU9sTCxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0FBQ2pDLFFBQUltTCxLQUFLLEVBQVQ7QUFDQWpXLFdBQU9rVyxJQUFQLENBQVlwTCxNQUFaLEVBQW9CcUwsT0FBcEIsQ0FBNEIsVUFBQ3BILEdBQUQsRUFBTW5RLEtBQU4sRUFBZ0I7QUFBRTtBQUM1Q3FYLFNBQUc5aUIsSUFBSCxDQUFRLENBQUM0YixHQUFELEVBQU1qRSxPQUFPaUUsR0FBUCxDQUFOLEVBQW1CekgsSUFBbkIsQ0FBd0IsR0FBeEIsQ0FBUjtBQUNELEtBRkQ7QUFHQSxRQUFJMk8sR0FBR3JoQixNQUFILEdBQVksQ0FBaEIsRUFBbUI7QUFDakJraEIsa0JBQVksTUFBT0csR0FBRzNPLElBQUgsQ0FBUSxHQUFSLENBQW5CO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPd08sUUFBUDtBQUNELENBbkJNLEM7Ozs7Ozs7QUNGUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNyQkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDbEJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDVEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUMzQkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7O0FDdEJELGlDOzs7Ozs7QUNBQTtBQUNBOztBQUVBLDRCQUE0QixnQkFBZ0IsNkJBQTZCLEdBQUcsRTs7Ozs7OztBQ0g1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LENBQUMsRTs7Ozs7O0FDSkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7OztBQ0pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNKRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7O0FDSkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7OztBQ0pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNKRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7O0FDSkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFE7Ozs7Ozs7QUNKRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbUVBQW1FO0FBQy9GLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUI7Ozs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsb0M7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7O0FDWEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNSRDtBQUNBOztBQUVBLHVDQUF1Qyx3Q0FBZ0QsRTs7Ozs7O0FDSHZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7OztBQ1ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNmRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNWRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ2ZEO0FBQ0E7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QUU1QyxzQzs7Ozs7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBLEVBQUUsRTs7Ozs7O0FDUEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEU7Ozs7OztBQ2RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBLEVBQUUsRTs7Ozs7O0FDbEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0EsRUFBRSxFOzs7Ozs7QUNoQkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0EsRUFBRSxFOzs7Ozs7QUNQRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEVBQUUsRTs7Ozs7O0FDUkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0EsRUFBRSxFOzs7Ozs7QUNmRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEVBQUUsRTs7Ozs7O0FDUkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEU7Ozs7OztBQ2RGO0FBQ0E7O0FBRUEsdUNBQXVDLHdDQUFnRCxFOzs7Ozs7O0FDSHZGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUM3QkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNURDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZTs7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYTs7Ozs7O0FDTkQseUM7Ozs7OztBQ0FBLHNDOzs7Ozs7QUNBQTtBQUNBOztBQUVBLDhCQUE4QiwrQkFBNkIsRTs7Ozs7O0FDSDNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3R0FBd0csT0FBTztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUNMRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7OztBQ25CRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDIiwiZmlsZSI6InJlZDVwcm8tc2RrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicmVkNXByb3Nka1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJyZWQ1cHJvc2RrXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzQ0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA5ODE1OWEyNjQ4NjliMGZkNGNiOSIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KVxuICAgICwga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmKHRhcmdldClyZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KWV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICdicm93c2VyLWJ1bnlhbidcbmltcG9ydCB7IFJhd1N0cmVhbSB9IGZyb20gJy4vYnVueWFuLXdyaXRlcidcblxubGV0IGxvZ2dlclxuY29uc3QgZm9ybWF0TWVzc2FnZSA9IChkaXNwYXRjaGVyKSA9PiB7XG4gIHJldHVybiBtZXNzYWdlID0+IHtcbiAgICByZXR1cm4gYCgke2Rpc3BhdGNoZXJ9KSAke21lc3NhZ2V9YFxuICB9XG59XG5jb25zdCBkZWNvcmF0ZSA9IChsZXZlbCkgPT4ge1xuICByZXR1cm4gKHNvdXJjZSwgbWVzc2FnZSkgPT4ge1xuICAgIGxvZ2dlcltsZXZlbF0oZm9ybWF0TWVzc2FnZShzb3VyY2UpKG1lc3NhZ2UpKVxuICB9XG59XG5leHBvcnQgY29uc3QgTEVWRUxTID0ge1xuICBUUkFDRTogJ3RyYWNlJyxcbiAgSU5GTzogJ2luZm8nLFxuICBERUJVRzogJ2RlYnVnJyxcbiAgV0FSTjogJ3dhcm4nLFxuICBFUlJPUjogJ2Vycm9yJyxcbiAgRkFUQUw6ICdmYXRhbCdcbn1cblxuXG5leHBvcnQgY29uc3QgZXN0YWJsaXNoTG9nZ2VyID0gKGxldmVsLCBzdHJlYW1MaXN0ID0gdW5kZWZpbmVkKSA9PiB7XG4gIGxldCBzdHJlYW1zID0gW11cbiAgc3RyZWFtcy5wdXNoKHtcbiAgICBsZXZlbDogbGV2ZWwsXG4gICAgc3RyZWFtOiBuZXcgUmF3U3RyZWFtKCksXG4gICAgdHlwZTogJ3JhdydcbiAgfSlcbiAgaWYgKHN0cmVhbUxpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gc3RyZWFtTGlzdC5tYXAoaXRlbSA9PiB7XG4gICAgICBpdGVtLmxldmVsID0gbGV2ZWxcbiAgICB9KVxuICAgIHN0cmVhbXMgPSBzdHJlYW1zLmNvbmNhdChsaXN0KVxuICB9XG4gIGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgbGV2ZWw6IGxldmVsLFxuICAgIG5hbWU6ICdyZWQ1cHJvLXNkaycsXG4gICAgc3RyZWFtczogc3RyZWFtc1xuICB9KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICByZXR1cm4gbG9nZ2VyXG59XG5cbmV4cG9ydCBjb25zdCB0cmFjZSA9IGRlY29yYXRlKExFVkVMUy5UUkFDRSlcbmV4cG9ydCBjb25zdCBpbmZvID0gZGVjb3JhdGUoTEVWRUxTLklORk8pXG5leHBvcnQgY29uc3QgZGVidWcgPSBkZWNvcmF0ZShMRVZFTFMuREVCVUcpXG5leHBvcnQgY29uc3Qgd2FybiA9IGRlY29yYXRlKExFVkVMUy5XQVJOKVxuZXhwb3J0IGNvbnN0IGVycm9yID0gZGVjb3JhdGUoTEVWRUxTLkVSUk9SKVxuZXhwb3J0IGNvbnN0IGZhdGFsID0gZGVjb3JhdGUoTEVWRUxTLkZBVEFMKVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbG9nL2luZGV4LmpzIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBOb0VsZW1lbnRGb3VuZEVycm9yIH0gZnJvbSAnLi4vZXhjZXB0aW9uL2Vycm9ycydcbmltcG9ydCB7IG9uT3JpZW50YXRpb25NZXRhZGF0YSB9IGZyb20gJy4vbWV0YWRhdGEtdXRpbCdcblxubGV0IHJ0bXBTdWJzY3JpYmVyQXNzaWdubWVudHMgPSBbXVxubGV0IGNsb3NlSGFuZGxlcnMgPSBbXVxubGV0IGZ1bGxzY3JlZW5IYW5kbGVycyA9IFtdXG5sZXQgc2NyZWVuZnVsbEhhbmRsZXJBc3NpZ25lZCA9IGZhbHNlXG5mdW5jdGlvbiBlbmFibGVTY3JlZW5mdWxsSGFuZGxlciAoKSB7XG4gIGlmICghc2NyZWVuZnVsbEhhbmRsZXJBc3NpZ25lZCAmJiB3aW5kb3cuc2NyZWVuZnVsbCAmJiB3aW5kb3cuc2NyZWVuZnVsbC5lbmFibGVkKSB7XG4gICAgICBzY3JlZW5mdWxsSGFuZGxlckFzc2lnbmVkID0gdHJ1ZVxuICAgICAgd2luZG93LnNjcmVlbmZ1bGwub25jaGFuZ2UoKCkgPT4ge1xuICAgICAgICBsZXQgaSwgbGVuZ3RoID0gZnVsbHNjcmVlbkhhbmRsZXJzLmxlbmd0aFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmdWxsc2NyZWVuSGFuZGxlcnNbaV0od2luZG93LnNjcmVlbmZ1bGwuaXNGdWxsc2NyZWVuKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9ud2luZG93Y2xvc2UgKGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAvLyAgY2xvc2VIYW5kbGVycy5mb3JFYWNoKGggPT4gaCgpKVxuICBsZXQgaSwgbGVuZ3RoID0gY2xvc2VIYW5kbGVycy5sZW5ndGhcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2xvc2VIYW5kbGVyc1tpXSgpXG4gIH1cbiAgLy8gUmV0dXJuaW5nIGEgc3RyaW5nIHZhbHVlIGZvcmNlcyBhIGxlYXZpbmcgY29uZmlybWF0aW9uIHBvcHVwIG9uIHRoZSBicm93c2VyLlxuICAvLyAgZS5yZXR1cm5WYWx1ZSA9ICdnb29kYnllJ1xuICAvLyAgcmV0dXJuICdnb29kYnllJ1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iL21hc3Rlci9zcmMvanMvdGVjaC9mbGFzaC5qcyNMNDc2XG5jb25zdCBmbGFzaFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCB2ZXJzaW9uID0gJzAsMCwwJ1xuICAvLyBJRVxuICB0cnkge1xuICAgIHZlcnNpb24gPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykuR2V0VmFyaWFibGUoJyR2ZXJzaW9uJykucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV1cblxuICAvLyBvdGhlciBicm93c2Vyc1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddLmVuYWJsZWRQbHVnaW4pIHtcbiAgICAgICAgdmVyc2lvbiA9IChuYXZpZ2F0b3IucGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoIDIuMCddIHx8IG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2gnXSkuZGVzY3JpcHRpb24ucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG5hZGFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZlcnNpb24uc3BsaXQoJywnKVxufVxuXG5jb25zdCByZXF1ZXN0RnJhbWUgPSAoKHRpbWUpID0+IHtcbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZSlcbiAgICAgICAgIH1cbn0pKDEwMDApO1xuXG5jb25zdCB0cmFja1Jlc2l6ZSA9IChlbGVtZW50LCByYWYpID0+IHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGVcbiAgICBwYXJlbnQuc3R5bGUuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRXaWR0aCArICdweCdcbiAgICBjb25zdCBwd2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGhcbiAgICBjb25zdCBld2lkdGggPSBlbGVtZW50LmNsaWVudEhlaWdodFxuICAgIGNvbnN0IG1hcmdpbiA9IChwd2lkdGggLSBld2lkdGgpICogMC41XG4gICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSdcbiAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBtYXJnaW4gKyAncHgnXG4gICAgcmFmKHRyYWNrUmVzaXplKGVsZW1lbnQsIHJhZikpXG4gIH1cbn1cblxuY29uc3QgaXNNb3ogPSAhIW5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWFcbi8vIElmIGRldmVsb3BlciBoYXMgbm90IHVzZWQgYWRhcHRlci5qc1xuaWYgKCF3aW5kb3cuYWRhcHRlcikge1xuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHx8IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYVxufVxuXG5jb25zdCBvcmlnaW4gPSBbXG4gICd3ZWJraXRUcmFuc2Zvcm1PcmlnaW4nLFxuICAnbW96VHJhbnNmb3JtT3JpZ2luJyxcbiAgJ21zVHJhbnNmb3JtT3JpZ2luJyxcbiAgJ29UcmFuc2Zvcm1PcmlnaW4nLFxuICAndHJhbnNmb3JtT3JpZ2luJ1xuXVxuY29uc3Qgc3R5bGVzID0gW1xuICAnd2Via2l0VHJhbnNmb3JtJyxcbiAgJ21velRyYW5zZm9ybScsXG4gICdtc1RyYW5zZm9ybScsXG4gICdvVHJhbnNmb3JtJyxcbiAgJ3RyYW5zZm9ybSdcbl1cbmNvbnN0IHRyYW5zaXRpb24gPSBbXG4gICd3ZWJraXRUcmFuc2l0aW9uJyxcbiAgJ21velRyYW5zaXRpb24nLFxuICAnbXNUcmFuc2l0aW9uJyxcbiAgJ29UcmFuc2l0aW9uJyxcbiAgJ3RyYW5zaXRpb24nXG5dXG5jb25zdCByb3RhdGlvblRyYW5zbGF0aW9ucyA9IHtcbiAgJzAnOiB7XG4gICAgb3JpZ2luOiAnY2VudGVyIGNlbnRlcicsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKDBkZWcpJ1xuICB9LFxuICAnOTAnOiB7XG4gICAgb3JpZ2luOiAnbGVmdCB0b3AnLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSg5MGRlZykgdHJhbnNsYXRlWSgtMTAwJSknXG4gIH0sXG4gICcxODAnOiB7XG4gICAgb3JpZ2luOiAnY2VudGVyIGNlbnRlcicsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKDE4MGRlZyknXG4gIH0sXG4gICcyNzAnOiB7XG4gICAgb3JpZ2luOiAndG9wIGxlZnQnLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgyNzBkZWcpIHRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoMCUpJ1xuICB9LFxuICAnLTkwJzoge1xuICAgIG9yaWdpbjogJ2xlZnQgdG9wJyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTkwZGVnKSB0cmFuc2xhdGVYKC0xMDAlKSdcbiAgfSxcbiAgJy0xODAnOiB7XG4gICAgb3JpZ2luOiAnY2VudGVyIGNlbnRlcicsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC0xODBkZWcpJ1xuICB9LFxuICAnLTI3MCc6IHtcbiAgICBvcmlnaW46ICd0b3AgbGVmdCcsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC0yNzBkZWcpIHRyYW5zbGF0ZVkoLTEwMCUpJ1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICByZXF1ZXN0RnJhbWU6IHJlcXVlc3RGcmFtZSxcblxuICBnZXRJc01vejogKCkgPT4ge1xuICAgIHJldHVybiBpc01velxuICB9LFxuXG4gIHN1cHBvcnRzV2ViU29ja2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuICEhd2luZG93LldlYlNvY2tldFxuICB9LFxuXG4gIHN1cHBvcnRzSExTOiAoKSA9PiB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgIHJldHVybiBlbC5jYW5QbGF5VHlwZSgnYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWdVUkwnKS5sZW5ndGggPiAwIHx8XG4gICAgICBlbC5jYW5QbGF5VHlwZSgnYXBwbGljYXRpb24veC1tcGVnVVJMJykubGVuZ3RoID4gMCB8fFxuICAgICAgZWwuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWd1cmwnKS5sZW5ndGggPiAwIHx8XG4gICAgICBlbC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tcGVndXJsJykubGVuZ3RoID4gMFxuICB9LFxuXG4gIHN1cHBvcnRzRmxhc2hWZXJzaW9uOiAodmVyc2lvbiwgZGVsaW1pdGVyID0gJy4nKSA9PiB7XG4gICAgcmV0dXJuIGZsYXNoVmVyc2lvbigpWzBdID49IHZlcnNpb24uc3BsaXQoZGVsaW1pdGVyKVswXVxuICB9LFxuXG4gIHJlc29sdmVFbGVtZW50OiAoaWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vRWxlbWVudEZvdW5kRXJyb3IoYEVsZW1lbnQgd2l0aCBpZCgke2lkfSkgY291bGQgbm90IGJlIGZvdW5kLmApXG4gICAgICB9XG4gICAgICByZXR1cm4gZWxcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgTm9FbGVtZW50Rm91bmRFcnJvcihgRXJyb3IgaW4gYWNjZXNzaW5nIGVsZW1lbnQgd2l0aCBpZCgke2lkfSkuICR7ZS5tZXNzYWdlfWApXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVdlYlNvY2tldDogKHVybCkgPT4ge1xuICAgIHJldHVybiBuZXcgd2luZG93LldlYlNvY2tldCh1cmwpXG4gIH0sXG5cbiAgc2V0VmlkZW9Tb3VyY2U6ICh2aWRlb0VsZW1lbnQsIG1lZGlhU3RyZWFtLCBhdXRvcGxheSA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKCdzcmNPYmplY3QnIGluIHZpZGVvRWxlbWVudCkge1xuICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc01veikge1xuICAgICAgdmlkZW9FbGVtZW50Wydtb3pTcmNPYmplY3QnXSA9IG1lZGlhU3RyZWFtXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmlkZW9FbGVtZW50LnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG1lZGlhU3RyZWFtKVxuICAgIH1cbiAgICBpZiAoYXV0b3BsYXkpIHtcbiAgICAgIHZpZGVvRWxlbWVudC5wbGF5KClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIGZhbHNlKVxuICAgICAgICB2aWRlb0VsZW1lbnQucGF1c2UoKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbmFkYS5cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW5qZWN0U2NyaXB0OiAodXJsKSA9PiB7XG4gICAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICBzY3JpcHQub25sb2FkID0gKCkgPT4ge1xuICAgICAgZGZkLnJlc29sdmUoKVxuICAgIH1cbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjcmlwdC5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fCBzY3JpcHQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICBkZmQucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfVxuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICByZXR1cm4gZGZkLnByb21pc2VcbiAgfSxcblxuICBnVU06IChjb25zdHJhaW50cykgPT4ge1xuICAgIHJldHVybiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyB8fCBuYXZpZ2F0b3IpLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgfSxcblxuICBzZXRHbG9iYWw6IChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgIHdpbmRvd1twcm9wXSA9IHZhbHVlXG4gIH0sXG5cbiAgZ2V0U3dmT2JqZWN0OiAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy5zd2ZvYmplY3RcbiAgfSxcblxuICBnZXRFbWJlZE9iamVjdDogKGlkKSA9PiB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuICB9LFxuXG4gIGdldEVsZW1lbnRJZDogKGVsKSA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgfSxcblxuICBhZGRDbG9zZUhhbmRsZXI6IChoYW5kbGVyLCBpbnNlcnRWYWx1ZSA9IC0xKSA9PiB7XG4gICAgY2xvc2VIYW5kbGVycy5zbGljZShpbnNlcnRWYWx1ZSA9PT0gLTEgPyBjbG9zZUhhbmRsZXJzLmxlbmd0aCA6IGluc2VydFZhbHVlLCAwLCBoYW5kbGVyKVxuICAgIGlmICh3aW5kb3cub25iZWZvcmV1bmxvYWQgIT09IG9ud2luZG93Y2xvc2UpIHtcbiAgICAgIHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IG9ud2luZG93Y2xvc2VcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBvbndpbmRvd2Nsb3NlKVxuICAgIH1cbiAgfSxcblxuICByZW1vdmVDbG9zZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IGkgPSBjbG9zZUhhbmRsZXJzLmxlbmd0aFxuICAgIHdoaWxlKCAtLWkgPiAtMSkge1xuICAgICAgaWYgKGNsb3NlSGFuZGxlcnNbaV0gPT09IGhhbmRsZXIpIHtcbiAgICAgICAgY2xvc2VIYW5kbGVycy5zbGljZShpLCAxKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpbnZva2U6IChtZXRob2ROYW1lLCBkYXRhKSA9PiB7XG4gICAgaWYgKHdpbmRvdy5oYXNPd25Qcm9wZXJ0eShtZXRob2ROYW1lKSkge1xuICAgICAgd2luZG93W21ldGhvZE5hbWVdLmNhbGwod2luZG93LCBkYXRhKVxuICAgIH1cbiAgfSxcblxuICAvLyByZXF1aXJlcyA8c2NyaXB0IHNyYz1cImxpYi9zY3JlZW5mdWxsL3NjcmVlbmZ1bGwubWluLmpzXCI+PC9zY3JpcHQ+XG4gIHRvZ2dsZUZ1bGxTY3JlZW46IChlbGVtZW50KSA9PiB7XG4gICAgaWYgKHdpbmRvdy5zY3JlZW5mdWxsICYmIHdpbmRvdy5zY3JlZW5mdWxsLmVuYWJsZWQpIHtcbiAgICAgIHdpbmRvdy5zY3JlZW5mdWxsLnRvZ2dsZShlbGVtZW50KVxuICAgIH1cbiAgfSxcblxuICBvbkZ1bGxTY3JlZW5TdGF0ZUNoYW5nZTogKGNiKSA9PiB7XG4gICAgZnVsbHNjcmVlbkhhbmRsZXJzLnB1c2goY2IpXG4gICAgZW5hYmxlU2NyZWVuZnVsbEhhbmRsZXIod2luZG93LnNjcmVlbmZ1bGwpXG4gIH0sXG5cbiAgb25PcmllbnRhdGlvbk1ldGFkYXRhOiBvbk9yaWVudGF0aW9uTWV0YWRhdGEsXG5cbiAgYXBwbHlPcmllbnRhdGlvbjogKGVsZW1lbnQsIHZhbHVlKSA9PiB7XG4gICAgbGV0IGksIGxlbmd0aCA9IHN0eWxlcy5sZW5ndGhcbiAgICB2YWx1ZSA9IHZhbHVlICUgMzYwXG4gICAgY29uc3QgdHJhbnNsYXRpb25zID0gcm90YXRpb25UcmFuc2xhdGlvbnNbdmFsdWUudG9TdHJpbmcoKV1cbiAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgZWxlbWVudC5zdHlsZVtvcmlnaW5baV1dID0gdHJhbnNsYXRpb25zLm9yaWdpblxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZXNbaV1dID0gdHJhbnNsYXRpb25zLnRyYW5zZm9ybVxuICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uW2ldXSA9ICd0cmFuc2Zvcm0gMC4wcyBsaW5lYXInXG4gICAgfVxuICAgIGlmICh2YWx1ZSAlIDE4MCAhPT0gMCkge1xuICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9ICdpbmhlcml0J1xuICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlXG4gICAgICBjb25zdCBwaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodFxuICAgICAgY29uc3Qgc2NhbGUgPSBwaGVpZ2h0IC8gZWxlbWVudC5jbGllbnRXaWR0aFxuICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IChlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUpICsgJ3B4J1xuICAgICAgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIHBhcmVudC5hdHRhY2hFdmVudCgncmVzaXplJywgdHJhY2tSZXNpemUoZWxlbWVudCkpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdHJhY2tSZXNpemUoZWxlbWVudCwgcmVxdWVzdEZyYW1lKSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGhhc0F0dHJpYnV0ZURlZmluZWQ6IChlbGVtLCBhdHRyaWJ1dGUpID0+IHtcbiAgICBjb25zdCBhdHQgPSBlbGVtLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpXG4gICAgcmV0dXJuIChhdHQgIT09IG51bGwgJiYgdHlwZW9mIGF0dCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICh0eXBlb2YgYXR0ID09PSAnc3RyaW5nJyAmJiAoYXR0ID09PSAnJyB8fCBhdHQgPT09ICd0cnVlJykpXG4gIH0sXG5cbiAgaGFzQ2xhc3NEZWZpbmVkOiAoZWxlbSwgY2xhc3NOYW1lKSA9PiB7XG4gICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgfSxcblxuICBjcmVhdGVFbGVtZW50OiAodGFnTmFtZSwgb3B0cykgPT4ge1xuICAgIGlmICh0YWdOYW1lID09PSAndGV4dCcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvcHRzLnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIG9wdHMpXG4gIH0sXG5cbiAgYWRkU3Vic2NyaXB0aW9uQXNzaWdubWVudEhhbmRsZXI6IChmbikgPT4ge1xuICAgIHJ0bXBTdWJzY3JpYmVyQXNzaWdubWVudHMucHVzaChmbilcbiAgICBpZiAod2luZG93LnNldFN1YnNjcmliZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB3aW5kb3cuc2V0U3Vic2NyaWJlcklkID0gKGlkKSA9PiB7XG4gICAgICAgIHJ0bXBTdWJzY3JpYmVyQXNzaWdubWVudHMuc2hpZnQoKShpZClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0TW91c2VYRnJvbUV2ZW50OiAoZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICBldmVudCA9IHdpbmRvdy5ldmVudFxuICAgIH1cblxuICAgIGlmIChldmVudC5wYWdlWCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnBhZ2VYXG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFgpIHtcbiAgICAgIHJldHVybiBldmVudC5jbGllbnRYICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGdldFNjcm9sbFg6ICgpID0+IHtcbiAgICByZXR1cm4gKHdpbmRvdy5wYWdlWE9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgPyB3aW5kb3cucGFnZVhPZmZzZXRcbiAgICAgICAgICAgIDogKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsTGVmdFxuICB9LFxuXG4gIGdldEdsb2JhbDogKCkgPT4gd2luZG93XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9lbnYvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBfRGVmZXJyZWRQcm9taXNlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzb2x2ZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVqZWN0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3RcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IF9GdXR1cmUgPSB7XG4gIGNyZWF0ZUlmTm90RXhpc3Q6IChkZWZlcnJlZElmRXhpc3QpID0+IHtcbiAgICBsZXQgZiA9IGRlZmVycmVkSWZFeGlzdFxuICAgIGlmICghZikge1xuICAgICAgZiA9IG5ldyBfRGVmZXJyZWRQcm9taXNlKClcbiAgICB9XG4gICAgcmV0dXJuIGZcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRGVmZXJyZWRQcm9taXNlID0gX0RlZmVycmVkUHJvbWlzZVxuZXhwb3J0IGNvbnN0IEZ1dHVyZSA9IF9GdXR1cmVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy91dGlsL3Byb21pc2UuanMiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgcXVvdCAgICA9IC9cIi9nO1xuLy8gQi4yLjMuMi4xIENyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpXG52YXIgY3JlYXRlSFRNTCA9IGZ1bmN0aW9uKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTICA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpXG4gICAgLCBwMSA9ICc8JyArIHRhZztcbiAgaWYoYXR0cmlidXRlICE9PSAnJylwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuICByZXR1cm4gcDEgKyAnPicgKyBTICsgJzwvJyArIHRhZyArICc+Jztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIGV4ZWMpe1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IFdJTERDQVJEID0gJyonXG5jb25zdCBXSUxEQ0FSRF9LRVkgPSAnUkVENVBSTydcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge31cbiAgICB0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXSA9IFtdXG4gIH1cblxuICBfbm90aWZ5IChjYWxsYmFja3MsIGV2ZW50KSB7XG4gICAgICBsZXQgaSwgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aFxuICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKGV2ZW50KVxuICAgICAgfVxuICB9XG5cbiAgb24gKHR5cGUsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXS5wdXNoKGZuKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV0gPSBbXVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbdHlwZV0uaW5kZXhPZihmbikgPT09IC0xKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV0ucHVzaChmbilcbiAgICB9XG4gIH1cblxuICBvZmYgKHR5cGUsIGZuKSB7XG4gICAgbGV0IG1hcCA9IHRoaXMuX2NhbGxiYWNrc1t0eXBlXVxuICAgIGlmICh0eXBlID09PSBXSUxEQ0FSRCkge1xuICAgICAgbWFwID0gdGhpcy5fY2FsbGJhY2tzW1dJTERDQVJEX0tFWV1cbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgY29uc3QgaW5kZXggPSBtYXAuaW5kZXhPZihmbilcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbWFwLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0cmlnZ2VyIChldmVudCkge1xuICAgIGNvbnN0IHR5cGUgPSBldmVudC50eXBlXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1t0eXBlXSkge1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2NhbGxiYWNrc1t0eXBlXSwgZXZlbnQpXG4gICAgfVxuICAgIHRoaXMuX25vdGlmeSh0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXSwgZXZlbnQpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2NvcmUvZXZlbnQtZW1pdHRlci5qcyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCBhcmcpe1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbigpe30sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjbGFzcyBFdmVudCB7XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGRhdGEgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl90eXBlID0gdHlwZVxuICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVcbiAgfVxuXG4gIGdldCBkYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG5cbn1cblxuY2xhc3MgUHVibGlzaGVyRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIHB1Ymxpc2hlciwgZGF0YSkge1xuICAgIHN1cGVyKHR5cGUsIGRhdGEpXG4gICAgdGhpcy5fcHVibGlzaGVyID0gcHVibGlzaGVyXG4gIH1cblxuICBnZXQgcHVibGlzaGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGlzaGVyXG4gIH1cblxufVxuXG5jbGFzcyBTdWJzY3JpYmVyRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIHN1YnNjcmliZXIsIGRhdGEpIHtcbiAgICBzdXBlcih0eXBlLCBkYXRhKVxuICAgIHRoaXMuX3N1YnNjcmliZXIgPSBzdWJzY3JpYmVyXG4gIH1cblxuICBnZXQgc3Vic2NyaWJlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZXJcbiAgfVxuXG59XG5cbmNsYXNzIFNoYXJlZE9iamVjdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBzaGFyZWRPYmplY3ROYW1lLCBkYXRhKSB7XG4gICAgc3VwZXIodHlwZSwgZGF0YSlcbiAgICB0aGlzLl9uYW1lID0gc2hhcmVkT2JqZWN0TmFtZVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lXG4gIH1cblxufVxuXG5leHBvcnQgeyBFdmVudCBhcyBFdmVudCB9XG5leHBvcnQgeyBQdWJsaXNoZXJFdmVudCBhcyBQdWJsaXNoZXJFdmVudCB9XG5leHBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgYXMgU3Vic2NyaWJlckV2ZW50IH1cbmV4cG9ydCB7IFNoYXJlZE9iamVjdEV2ZW50IGFzIFNoYXJlZE9iamVjdEV2ZW50IH1cbmV4cG9ydCB7IGNvbW1vbiBhcyBQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgcnRtcCBhcyBSVE1QUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgZmFpbG92ZXIgYXMgRmFpbG92ZXJQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBjb21tb24gYXMgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBydG1wIGFzIFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IGZhaWxvdmVyIGFzIEZhaWxvdmVyU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBjb21tb24gYXMgU2hhcmVkT2JqZWN0RXZlbnRUeXBlcyB9IGZyb20gJy4vc2hhcmVkb2JqZWN0LWV2ZW50J1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZXZlbnQvaW5kZXguanMiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIE1hcCAgICAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKVxuICAsICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNoYXJlZCAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKVxuICAsIHN0b3JlICAgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpe1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYoIXRhcmdldE1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYoIWtleU1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKXtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpXG4gICAgLCBrZXlzICAgICAgICA9IFtdO1xuICBpZihtZXRhZGF0YU1hcCltZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uKF8sIGtleSl7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbihPKXtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpe1xuICB2YXIgTElCUkFSWSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAgICwgZ2xvYmFsICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICAgLCBmYWlscyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAgICwgJGV4cG9ydCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICAgLCAkdHlwZWQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAgICwgJGJ1ZmZlciAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpXG4gICAgLCBjdHggICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgICAsIGFuSW5zdGFuY2UgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICAgLCBwcm9wZXJ0eURlc2MgICAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICAgLCBoaWRlICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICAgLCByZWRlZmluZUFsbCAgICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgICAsIHRvSW50ZWdlciAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgICAsIHRvTGVuZ3RoICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAgICwgdG9JbmRleCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgICAsIHRvUHJpbWl0aXZlICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAgICwgaGFzICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICAgLCBzYW1lICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpXG4gICAgLCBjbGFzc29mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICAgLCBpc09iamVjdCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgICAsIHRvT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAgICwgaXNBcnJheUl0ZXIgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAgICwgY3JlYXRlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAgICwgZ2V0UHJvdG90eXBlT2YgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAgICwgZ09QTiAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAgICwgZ2V0SXRlckZuICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgICAsIHVpZCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAgICwgd2tzICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICAgLCBjcmVhdGVBcnJheU1ldGhvZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpXG4gICAgLCBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKVxuICAgICwgc3BlY2llc0NvbnN0cnVjdG9yICA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAgICwgQXJyYXlJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJylcbiAgICAsIEl0ZXJhdG9ycyAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAgICwgJGl0ZXJEZXRlY3QgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgICAsIHNldFNwZWNpZXMgICAgICAgICAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICAgLCBhcnJheUZpbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpXG4gICAgLCBhcnJheUNvcHlXaXRoaW4gICAgID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKVxuICAgICwgJERQICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICAgLCAkR09QRCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAgICwgZFAgICAgICAgICAgICAgICAgICA9ICREUC5mXG4gICAgLCBnT1BEICAgICAgICAgICAgICAgID0gJEdPUEQuZlxuICAgICwgUmFuZ2VFcnJvciAgICAgICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXG4gICAgLCBUeXBlRXJyb3IgICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAgICwgVWludDhBcnJheSAgICAgICAgICA9IGdsb2JhbC5VaW50OEFycmF5XG4gICAgLCBBUlJBWV9CVUZGRVIgICAgICAgID0gJ0FycmF5QnVmZmVyJ1xuICAgICwgU0hBUkVEX0JVRkZFUiAgICAgICA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSXG4gICAgLCBCWVRFU19QRVJfRUxFTUVOVCAgID0gJ0JZVEVTX1BFUl9FTEVNRU5UJ1xuICAgICwgUFJPVE9UWVBFICAgICAgICAgICA9ICdwcm90b3R5cGUnXG4gICAgLCBBcnJheVByb3RvICAgICAgICAgID0gQXJyYXlbUFJPVE9UWVBFXVxuICAgICwgJEFycmF5QnVmZmVyICAgICAgICA9ICRidWZmZXIuQXJyYXlCdWZmZXJcbiAgICAsICREYXRhVmlldyAgICAgICAgICAgPSAkYnVmZmVyLkRhdGFWaWV3XG4gICAgLCBhcnJheUZvckVhY2ggICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMClcbiAgICAsIGFycmF5RmlsdGVyICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgyKVxuICAgICwgYXJyYXlTb21lICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpXG4gICAgLCBhcnJheUV2ZXJ5ICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNClcbiAgICAsIGFycmF5RmluZCAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAgICwgYXJyYXlGaW5kSW5kZXggICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpXG4gICAgLCBhcnJheUluY2x1ZGVzICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKVxuICAgICwgYXJyYXlJbmRleE9mICAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpXG4gICAgLCBhcnJheVZhbHVlcyAgICAgICAgID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzXG4gICAgLCBhcnJheUtleXMgICAgICAgICAgID0gQXJyYXlJdGVyYXRvcnMua2V5c1xuICAgICwgYXJyYXlFbnRyaWVzICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXNcbiAgICAsIGFycmF5TGFzdEluZGV4T2YgICAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mXG4gICAgLCBhcnJheVJlZHVjZSAgICAgICAgID0gQXJyYXlQcm90by5yZWR1Y2VcbiAgICAsIGFycmF5UmVkdWNlUmlnaHQgICAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0XG4gICAgLCBhcnJheUpvaW4gICAgICAgICAgID0gQXJyYXlQcm90by5qb2luXG4gICAgLCBhcnJheVNvcnQgICAgICAgICAgID0gQXJyYXlQcm90by5zb3J0XG4gICAgLCBhcnJheVNsaWNlICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZVxuICAgICwgYXJyYXlUb1N0cmluZyAgICAgICA9IEFycmF5UHJvdG8udG9TdHJpbmdcbiAgICAsIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nXG4gICAgLCBJVEVSQVRPUiAgICAgICAgICAgID0gd2tzKCdpdGVyYXRvcicpXG4gICAgLCBUQUcgICAgICAgICAgICAgICAgID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICAgLCBUWVBFRF9DT05TVFJVQ1RPUiAgID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpXG4gICAgLCBERUZfQ09OU1RSVUNUT1IgICAgID0gdWlkKCdkZWZfY29uc3RydWN0b3InKVxuICAgICwgQUxMX0NPTlNUUlVDVE9SUyAgICA9ICR0eXBlZC5DT05TVFJcbiAgICAsIFRZUEVEX0FSUkFZICAgICAgICAgPSAkdHlwZWQuVFlQRURcbiAgICAsIFZJRVcgICAgICAgICAgICAgICAgPSAkdHlwZWQuVklFV1xuICAgICwgV1JPTkdfTEVOR1RIICAgICAgICA9ICdXcm9uZyBsZW5ndGghJztcblxuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uKE8sIGxlbmd0aCl7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciBzdHJpY3RUb0xlbmd0aCA9IGZ1bmN0aW9uKGl0LCBTQU1FKXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHZhciBudW1iZXIgPSAraXRcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoaXQpO1xuICAgIGlmKFNBTUUgJiYgIXNhbWUobnVtYmVyLCBsZW5ndGgpKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9O1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uKGl0LCBCWVRFUyl7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUyl0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbihpdCl7XG4gICAgaWYoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KXJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uKEMsIGxlbmd0aCl7XG4gICAgaWYoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH0gcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uKE8sIGxpc3Qpe1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24oQywgbGlzdCl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gbGlzdC5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihpdCwga2V5LCBpbnRlcm5hbCl7XG4gICAgZFAoaXQsIGtleSwge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdOyB9fSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyosIG1hcGZuLCB0aGlzQXJnICovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KHNvdXJjZSlcbiAgICAgICwgYUxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKyl7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfSBPID0gdmFsdWVzO1xuICAgIH1cbiAgICBpZihtYXBwaW5nICYmIGFMZW4gPiAyKW1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvcihpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspe1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyouLi5pdGVtcyovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTsgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCl7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qLCBlbmQgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQsIGVuZCAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCl7XG4gICAgICB2YXIgdGhhdCAgID0gdGhpc1xuICAgICAgICAsIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aFxuICAgICAgICAsIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMilcbiAgICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAgICwgdmFsdWU7XG4gICAgICB3aGlsZShpbmRleCA8IG1pZGRsZSl7XG4gICAgICAgIHZhbHVlICAgICAgICAgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKXtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKXtcbiAgICAgIHZhciBPICAgICAgPSB2YWxpZGF0ZSh0aGlzKVxuICAgICAgICAsIGxlbmd0aCA9IE8ubGVuZ3RoXG4gICAgICAgICwgJGJlZ2luID0gdG9JbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKXtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiwgb2Zmc2V0ICovKXtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKVxuICAgICAgLCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgICAgLCBzcmMgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDA7XG4gICAgaWYobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB3aGlsZShpbmRleCA8IGxlbil0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCl7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpe1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCl7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2Mpe1xuICAgIGlmKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApe1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2UgcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZighQUxMX0NPTlNUUlVDVE9SUyl7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mICAgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogICAgICAgICAgICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmKGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKXtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogICAgICAgICAgJHNsaWNlLFxuICAgIHNldDogICAgICAgICAgICAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiAgICBmdW5jdGlvbigpeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6ICAgICAgIGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpe1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgICAgICAgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSdcbiAgICAgICwgSVNOVF9VSU5UOCA9IE5BTUUgIT0gJ1VpbnQ4QXJyYXknXG4gICAgICAsIEdFVFRFUiAgICAgPSAnZ2V0JyArIEtFWVxuICAgICAgLCBTRVRURVIgICAgID0gJ3NldCcgKyBLRVlcbiAgICAgICwgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXVxuICAgICAgLCBCYXNlICAgICAgID0gVHlwZWRBcnJheSB8fCB7fVxuICAgICAgLCBUQUMgICAgICAgID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KVxuICAgICAgLCBGT1JDRUQgICAgID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlZcbiAgICAgICwgTyAgICAgICAgICA9IHt9XG4gICAgICAsIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4LCB2YWx1ZSl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZihDTEFNUEVEKXZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZihGT1JDRUQpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAgICAgLCBvZmZzZXQgPSAwXG4gICAgICAgICAgLCBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSl7XG4gICAgICAgICAgbGVuZ3RoICAgICA9IHN0cmljdFRvTGVuZ3RoKGRhdGEsIHRydWUpXG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciAgICAgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUil7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKCRsZW4gJSBCWVRFUyl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggPCAwKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbil0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpe1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUoaW5kZXggPCBsZW5ndGgpYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYoISRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpe1xuICAgICAgLy8gVjggd29ya3Mgd2l0aCBpdGVyYXRvcnMsIGJ1dCBmYWlscyBpbiBtYW55IG90aGVyIGNhc2VzXG4gICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDU1MlxuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzO1xuICAgICAgICAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpcmV0dXJuIG5ldyBCYXNlKHN0cmljdFRvTGVuZ3RoKGRhdGEsIElTTlRfVUlOVDgpKTtcbiAgICAgICAgaWYoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUil7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighKGtleSBpbiBUeXBlZEFycmF5KSloaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmKCFMSUJSQVJZKVR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yICAgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXVxuICAgICAgLCBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpXG4gICAgICAsICRpdGVyYXRvciAgICAgICAgID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZihDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpe1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTLFxuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZighKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKWhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7c2V0OiAkc2V0fSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpLCBOQU1FLCB7dG9TdHJpbmc6IGFycmF5VG9TdHJpbmd9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHtzbGljZTogJHNsaWNlfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKVxuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7dG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ30pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKWhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL191aWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpXG4gICwgQXJyYXlQcm90byAgPSBBcnJheS5wcm90b3R5cGU7XG5pZihBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNwYWNlcyAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24oS0VZLCBleGVjLCBBTElBUyl7XG4gIHZhciBleHAgICA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgUGxheWJhY2tTdGF0ZSA9IE9iamVjdC5mcmVlemUoe1xuICBVTkFWQUlMQUJMRTogMTAwMCxcbiAgQVZBSUxBQkxFOiAwLFxuICBJRExFOiAxLFxuICBQTEFZSU5HOiAyLFxuICBQQVVTRUQ6IDNcbn0pXG5cbmV4cG9ydCBjb25zdCBQbGF5YmFja1N0YXRlUmVhZGFibGUgPSBPYmplY3QuZnJlZXplKHtcbiAgMTAwMDogJ1BsYXliYWNrLlVOQVZBSUxBQkxFJyxcbiAgMDogJ1BsYXliYWNrLkFWQUlMQUJMRScsXG4gIDE6ICdQbGF5YmFjay5JRExFJyxcbiAgMjogJ1BsYXliYWNrLlBMQVlJTkcnLFxuICAzOiAnUGxheWJhY2suUEFVU0VEJ1xufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9zdWJzY3JpYmVyL2NvbnRyb2xzL3N0YXRlLmpzIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgY3VycnksIGZpbHRlciB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgeyBkZWVwQ29weSB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2cnXG4vLyBpbXBvcnQgeyBOb1N1cHBvcnRlZENhbWVyYVJlc29sdXRpb25zRXJyb3IgfSBmcm9tICcuLi9leGNlcHRpb24vZXJyb3JzJ1xuXG4vLyBSZXNvbHV0aW9ucyBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9XZWJSVEMtQ2FtZXJhLVJlc29sdXRpb24vYmxvYi9tYXN0ZXIvanMvcmVzb2x1dGlvblNjYW4uanNcbmNvbnN0IGZvcm1hdHMgPSBbXG4gIHtcbiAgICBcImxhYmVsXCI6IFwiNEsoVUhEKVwiLFxuICAgIFwid2lkdGhcIiA6IDM4NDAsXG4gICAgXCJoZWlnaHRcIjogMjE2MFxuICB9LFxuICB7XG4gICAgXCJsYWJlbFwiOiBcIjEwODBwKEZIRClcIixcbiAgICBcIndpZHRoXCI6IDE5MjAsXG4gICAgXCJoZWlnaHRcIjogMTA4MFxuICB9LFxuICB7XG4gICAgXCJsYWJlbFwiOiBcIlVYR0FcIixcbiAgICBcIndpZHRoXCI6IDE2MDAsXG4gICAgXCJoZWlnaHRcIjogMTIwMFxuICB9LFxuICB7XG4gICAgXCJsYWJlbFwiOiBcIjcyMHAoSEQpXCIsXG4gICAgXCJ3aWR0aFwiOiAxMjgwLFxuICAgIFwiaGVpZ2h0XCI6IDcyMFxuICB9LFxuICB7XG4gICAgXCJsYWJlbFwiOiBcIlNWR0FcIixcbiAgICBcIndpZHRoXCI6IDgwMCxcbiAgICBcImhlaWdodFwiOiA2MDBcbiAgfSxcbiAge1xuICAgIFwibGFiZWxcIjogXCJWR0FcIixcbiAgICBcIndpZHRoXCI6IDY0MCxcbiAgICBcImhlaWdodFwiOiA0ODBcbiAgfSxcbiAge1xuICAgIFwibGFiZWxcIjogXCIzNjBwKG5IRClcIixcbiAgICBcIndpZHRoXCI6IDY0MCxcbiAgICBcImhlaWdodFwiOiAzNjBcbiAgfSxcbiAge1xuICAgIFwibGFiZWxcIjogXCJDSUZcIixcbiAgICBcIndpZHRoXCI6IDM1MixcbiAgICBcImhlaWdodFwiOiAyODhcbiAgfSxcbiAge1xuICAgIFwibGFiZWxcIjogXCJRVkdBXCIsXG4gICAgXCJ3aWR0aFwiOiAzMjAsXG4gICAgXCJoZWlnaHRcIjogMjQwXG4gIH0sXG4gIHtcbiAgICBcImxhYmVsXCI6IFwiUUNJRlwiLFxuICAgIFwid2lkdGhcIjogMTc2LFxuICAgIFwiaGVpZ2h0XCI6IDE0NFxuICB9LFxuICB7XG4gICAgXCJsYWJlbFwiOiBcIlFRVkdBXCIsXG4gICAgXCJ3aWR0aFwiOiAxNjAsXG4gICAgXCJoZWlnaHRcIjogMTIwXG4gIH1cblxuXTtcblxuY29uc3QgaGFzUmVzb2x1dGlvbnNEZWZpbmVkID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gIHJldHVybiBjb25zdHJhaW50cy5oYXNPd25Qcm9wZXJ0eSgndmlkZW8nKSAmJlxuICAgICAgICAgIChjb25zdHJhaW50cy52aWRlby5oYXNPd25Qcm9wZXJ0eSgnd2lkdGgnKSB8fCBjb25zdHJhaW50cy52aWRlby5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpXG59XG5cbmNvbnN0IGdldFZhbHVlRnJvbUNvbnN0cmFpbnRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlKSA9PiB7XG4gIHJldHVybiBhdHRyaWJ1dGUuZXhhY3QgfHwgYXR0cmlidXRlLmlkZWFsIHx8IGF0dHJpYnV0ZS5tYXggfHwgYXR0cmlidXRlLm1pbiB8fCBhdHRyaWJ1dGVcbn1cblxuY29uc3QgaXNFeGFjdCA9IGN1cnJ5KChjb25zdHJhaW50cywgZm9ybWF0KSA9PiB7XG4gIGlmICh0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgY29uc3QgdyA9IGNvbnN0cmFpbnRzLnZpZGVvLmhhc093blByb3BlcnR5KCd3aWR0aCcpID8gZ2V0VmFsdWVGcm9tQ29uc3RyYWludEF0dHJpYnV0ZShjb25zdHJhaW50cy52aWRlby53aWR0aCkgOiAwXG4gIGNvbnN0IGggPSBjb25zdHJhaW50cy52aWRlby5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykgPyBnZXRWYWx1ZUZyb21Db25zdHJhaW50QXR0cmlidXRlKGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodCkgOiAwXG4gIHJldHVybiAodyA9PT0gZm9ybWF0LndpZHRoKSAmJiAoaCA9PT0gZm9ybWF0LmhlaWdodClcbn0pXG5cbmNvbnN0IGlzTG93ZXIgPSBjdXJyeSgoY29uc3RyYWludHMsIGZvcm1hdCkgPT4ge1xuICBjb25zdCB3ID0gY29uc3RyYWludHMudmlkZW8uaGFzT3duUHJvcGVydHkoJ3dpZHRoJykgPyBnZXRWYWx1ZUZyb21Db25zdHJhaW50QXR0cmlidXRlKGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoKSA6IDBcbiAgY29uc3QgaCA9IGNvbnN0cmFpbnRzLnZpZGVvLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSA/IGdldFZhbHVlRnJvbUNvbnN0cmFpbnRBdHRyaWJ1dGUoY29uc3RyYWludHMudmlkZW8uaGVpZ2h0KSA6IDBcbiAgY29uc3QgZGVzaXJlZCA9IHcgKiBoXG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBmb3JtYXQud2lkdGggKiBmb3JtYXQuaGVpZ2h0XG4gIHJldHVybiBkaW1lbnNpb25zIDwgZGVzaXJlZFxufSlcblxuY29uc3QgaGFzTWF0Y2hpbmdGb3JtYXQgPSBjdXJyeSgoZm9ybWF0c0xpc3QsIGNvbnN0cmFpbnRzKSA9PiB7XG4gIHJldHVybiBmaWx0ZXIoaXNFeGFjdChjb25zdHJhaW50cykpKGZvcm1hdHNMaXN0KS5sZW5ndGggPiAwXG59KVxuXG5jb25zdCBmaW5kTG93ZXJSZXNvbHV0aW9ucyA9IGN1cnJ5KChmb3JtYXRzTGlzdCwgY29uc3RyYWludHMpID0+IHtcbiAgbGV0IHJlc0lzTG93ZXIgPSBpc0xvd2VyKGNvbnN0cmFpbnRzKVxuICByZXR1cm4gZmlsdGVyKHJlc0lzTG93ZXIpKGZvcm1hdHNMaXN0KVxufSlcblxuY29uc3QgZmluZE5leHRTZWxlY3Rpb24gPSAoZGF0YSwgc2VsZWN0aW9ucywgcCkgPT4ge1xuICBpZiAoc2VsZWN0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gaWYgd2UgZ290IGhlcmUsIHRoZXJlIGlzIG5vIHN1cHBvcnQuXG4gICAgcC5yZWplY3QoJ0NvdWxkIG5vdCBmaW5kIHByb3BlciBjYW1lcmEgZm9yIHByb3ZpZGVkIGNvbnN0cmFpbnRzLicpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gc2VsZWN0aW9ucy5zaGlmdCgpXG4gIGRhdGEudmlkZW8ud2lkdGggPSB7ZXhhY3Q6IHNlbGVjdGlvbi53aWR0aH1cbiAgZGF0YS52aWRlby5oZWlnaHQgPSB7ZXhhY3Q6IHNlbGVjdGlvbi5oZWlnaHR9XG4gIGVudmlyb25tZW50LmdVTShkYXRhKVxuICAgIC50aGVuKG1lZGlhID0+IHtcbiAgICAgIHAucmVzb2x2ZSh7XG4gICAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgICAgY29uc3RyYWludHM6IGRhdGFcbiAgICAgIH0pXG4gICAgfSlcbiAgICAuY2F0Y2goZXJyID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgZGVidWcoJ1tnVU06ZmluZGZvcm1hdF0nLCBgQ29uc3RyYWludHMgZGVjbGluZWQgYnkgYnJvd3NlcjogJHtKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKX1gKVxuICAgICAgZmluZE5leHRTZWxlY3Rpb24oZGF0YSwgc2VsZWN0aW9ucywgcClcbiAgICB9KVxufVxuXG5leHBvcnQgY29uc3QgcXVpY2tSZXNvbHV0aW9uU3VwcG9ydCA9IChjb25zdHJhaW50cykgPT4ge1xuICBsZXQgZGF0YSA9IGRlZXBDb3B5KGNvbnN0cmFpbnRzKVxuICAvLyBpZiB2aWRlbzogYHRydWVgLCByZXR1cm5lZCB1bnNjYXRoZWQuXG4gIGlmICh0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBkYXRhXG4gIH1cbiAgLy8gZWxzZSwgZGVmaW5lIGV4YWN0LlxuICBpZiAoY29uc3RyYWludHMudmlkZW8ud2lkdGgpIHtcbiAgICBkYXRhLnZpZGVvLndpZHRoID0ge2V4YWN0OiBnZXRWYWx1ZUZyb21Db25zdHJhaW50QXR0cmlidXRlKGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoKX1cbiAgfVxuICBpZiAoY29uc3RyYWludHMudmlkZW8uaGVpZ2h0KSB7XG4gICAgZGF0YS52aWRlby5oZWlnaHQgPSB7ZXhhY3Q6IGdldFZhbHVlRnJvbUNvbnN0cmFpbnRBdHRyaWJ1dGUoY29uc3RyYWludHMudmlkZW8uaGVpZ2h0KX1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgY29uc3QgZGV0ZXJtaW5lU3VwcG9ydGVkUmVzb2x1dGlvbiA9IChjb25zdHJhaW50cykgPT4ge1xuICBsZXQgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgbGV0IHNlbGVjdGlvbnMgPSBmaW5kTG93ZXJSZXNvbHV0aW9ucyhmb3JtYXRzKShjb25zdHJhaW50cylcbiAgbGV0IGRhdGEgPSBkZWVwQ29weShjb25zdHJhaW50cylcbiAgZmluZE5leHRTZWxlY3Rpb24oZGF0YSwgc2VsZWN0aW9ucywgZGVmZXJyZWQpXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG59XG5cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZCA9ICgpID0+IHtcbiAgcmV0dXJuIF9SVENQZWVyQ29ubmVjdGlvbiAmJiBfUlRDSWNlQ2FuZGlkYXRlICYmIF9SVENTZXNzaW9uRGVzY3JpcHRpb25cbn1cblxuZXhwb3J0IGNvbnN0IGdldFVzZXJNZWRpYSA9IChjb25zdHJhaW50cykgPT4ge1xuICAvLyBXcmFwcGluZyBgZ2V0VXNlck1lZGlhYCByZXF1ZXN0cyBpbiBhbm90aGVyIGRlZmVycmVkIHByb21pc2Ugc28gd2UgY2FuIHJldHVybiB0aGUgc2VsZWN0ZWQgcmVzb2x1dGlvbnMgaWYgc3VjY2Vzc2Z1bC5cbiAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICBsZXQgaXNBdmFpbGFibGVJbkZvcm1hdHMgPSBoYXNNYXRjaGluZ0Zvcm1hdChmb3JtYXRzKVxuICBjb25zdCBmYWlsb3ZlciA9ICgpID0+IHtcbiAgICBkZXRlcm1pbmVTdXBwb3J0ZWRSZXNvbHV0aW9uKGNvbnN0cmFpbnRzKVxuICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgZGZkLnJlc29sdmUoe1xuICAgICAgICAgIG1lZGlhOiByZXMubWVkaWEsXG4gICAgICAgICAgY29uc3RyYWludHM6IHJlcy5jb25zdHJhaW50c1xuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGRmZC5yZWplY3Qoe1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICBjb25zdHJhaW50czogY29uc3RyYWludHNcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cbiAgaWYgKCFoYXNSZXNvbHV0aW9uc0RlZmluZWQoY29uc3RyYWludHMpKSB7XG4gICAgZW52aXJvbm1lbnQuZ1VNKGNvbnN0cmFpbnRzKVxuICAgICAgLnRoZW4obWVkaWEgPT4ge1xuICAgICAgICBkZmQucmVzb2x2ZSh7XG4gICAgICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50c1xuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChmYWlsb3ZlcilcbiAgfVxuICBlbHNlIGlmIChpc0F2YWlsYWJsZUluRm9ybWF0cyhjb25zdHJhaW50cykpIHtcbiAgICAvLyBUcnkgcXVpY2sgc2V0dGluZyBvZiBgZXhhY3RgIHJlc29sdXRpb24uLi5cbiAgICBsZXQgYXZhaWxhYmxlID0gcXVpY2tSZXNvbHV0aW9uU3VwcG9ydChjb25zdHJhaW50cylcbiAgICBlbnZpcm9ubWVudC5nVU0oYXZhaWxhYmxlKVxuICAgICAgLnRoZW4obWVkaWEgPT4ge1xuICAgICAgICBkZmQucmVzb2x2ZSh7XG4gICAgICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgICAgIGNvbnN0cmFpbnRzOiBhdmFpbGFibGVcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZmFpbG92ZXIpXG4gIH1cbiAgZWxzZSB7XG4gICAgZmFpbG92ZXIoKVxuICB9XG4gIHJldHVybiBkZmQucHJvbWlzZVxufVxuXG5leHBvcnQgY29uc3QgZm9yY2VVc2VyTWVkaWEgPSAoY29uc3RyYWludHMpID0+IHtcbiAgcmV0dXJuIGVudmlyb25tZW50LmdVTShjb25zdHJhaW50cylcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL211YXota2hhbi9XZWJSVEMtRXhwZXJpbWVudC9ibG9iL21hc3Rlci9SVENQZWVyQ29ubmVjdGlvbi9SVENQZWVyQ29ubmVjdGlvbi12MS42LmpzI0wxNThcbi8vIE11YXogS2hhbiAgICAgLSBnaXRodWIuY29tL211YXota2hhblxuLy8gTUlUIExpY2Vuc2UgICAtIHd3dy5XZWJSVEMtRXhwZXJpbWVudC5jb20vbGljZW5jZVxuLy8gRG9jdW1lbnRhdGlvbiAtIGdpdGh1Yi5jb20vbXVhei1raGFuL1dlYlJUQy1FeHBlcmltZW50L3RyZWUvbWFzdGVyL1JUQ1BlZXJDb25uZWN0aW9uXG5leHBvcnQgY29uc3QgdXBkYXRlQmFuZHdpZHRoID0gKG9wdGlvbnMsIHNkcCkgPT4ge1xuICBpZiAoZW52aXJvbm1lbnQuZ2V0SXNNb3ooKSkge1xuICAgIHJldHVybiBzZHBcbiAgfVxuICBzZHAgPSBzZHAucmVwbGFjZSgvYj1BUyhbXlxcclxcbl0rXFxyXFxuKS9nLCAnJylcbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICBzZHAgPSBzZHAucmVwbGFjZSgvYT1taWQ6YXVkaW9cXHJcXG4vZywgJ2E9bWlkOmF1ZGlvXFxyXFxuYj1BUzonICsgb3B0aW9ucy5hdWRpbyArICdcXHJcXG4nKVxuICB9XG4gIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgc2RwID0gc2RwLnJlcGxhY2UoL2E9bWlkOnZpZGVvXFxyXFxuL2csICdhPW1pZDp2aWRlb1xcclxcbmI9QVM6JyArIG9wdGlvbnMudmlkZW8gKyAnXFxyXFxuJylcbiAgfVxuICByZXR1cm4gc2RwXG59XG5cbi8qKiAtLSBoYW5kbGVkIGJ5IGFkYXB0ZXIuanMgLS0gKi9cbmNvbnN0IF9SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCAod2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbilcbmNvbnN0IF9SVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8ICh3aW5kb3cubW96UlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy53ZWJraXRSVENJY2VDYW5kaWRhdGUpXG5jb25zdCBfUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCAod2luZG93Lm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uKVxuXG5leHBvcnQgY29uc3QgUlRDUGVlckNvbm5lY3Rpb24gPSBfUlRDUGVlckNvbm5lY3Rpb25cbmV4cG9ydCBjb25zdCBSVENJY2VDYW5kaWRhdGUgPSBfUlRDSWNlQ2FuZGlkYXRlXG5leHBvcnQgY29uc3QgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gX1JUQ1Nlc3Npb25EZXNjcmlwdGlvblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvYWRhcHRlci93ZWJydGMuanMiLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uLy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IENvbnRyb2xTbGlkZXIgZnJvbSAnLi9zbGlkZXInXG5pbXBvcnQgeyBTbGlkZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudCdcbmltcG9ydCB7IFBsYXliYWNrU3RhdGUsIFBsYXliYWNrU3RhdGVSZWFkYWJsZSB9IGZyb20gJy4vc3RhdGUnXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdQbGF5YmFja0NvbnRyb2xzJ1xuXG4vLyBKdXN0IHRvIHNob3cgdGhlIEFQSSBjb250cmFjdFxuY2xhc3MgX1BsYXliYWNrQ29udHJvbHMge1xuXG4gIGNvbnN0cnVjdG9yICgpIHt9XG5cbiAgZ2V0Vm9sdW1lICgpIHt9XG5cbiAgc2V0Vm9sdW1lICh2YWx1ZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIHNldFNlZWtUaW1lICh2YWx1ZSwgbGVuZ3RoID0gMCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIHNldFBsYXliYWNrRHVyYXRpb24gKHZhbHVlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZ2V0U3RhdGUgKCkge31cblxuICBzZXRTdGF0ZSAoc3RhdGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBzZXRBc1ZPRCAodmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxufVxuXG5jbGFzcyBfUGxheWJhY2tDb250cm9sc0ltcGwgZXh0ZW5kcyBfUGxheWJhY2tDb250cm9scyB7XG5cbiAgY29uc3RydWN0b3IgKHBsYXllciwgY29udGFpbmVyKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucGxheWVyID0gcGxheWVyXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLl9wbGF5UGF1c2VCdXR0b24gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9tdXRlQnV0dG9uID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdm9sdW1lRmllbGQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zZWVrVGltZUZpZWxkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdGltZUZpZWxkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fZnVsbFNjcmVlbkJ1dHRvbiA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3N0YXRlID0gUGxheWJhY2tTdGF0ZS5JRExFXG4gICAgdGhpcy5fbXV0ZWRTdGF0ZSA9IGZhbHNlXG4gICAgdGhpcy5fcmVzdW1lQWZ0ZXJTZWVrID0gZmFsc2VcbiAgICB0aGlzLl9wbGF5YmFja0R1cmF0aW9uID0gMFxuICAgIHRoaXMuX3ZvbHVtZVZhbHVlID0gMVxuICAgIHRoaXMuX29uUGxheVBhdXNlQ2xpY2tCb3VuZCA9IHRoaXMuX29uUGxheVBhdXNlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuZGVjb3JhdGUodGhpcy5jb250YWluZXIpXG4gIH1cblxuICBkZWNvcmF0ZSAoY29udGFpbmVyKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tkZWNvcmF0ZV0nKVxuICAgIGxldCBjb250cm9sYmFyID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBjb250cm9sYmFyLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1iYXInKVxuICAgIHRoaXMuX3BsYXlQYXVzZUJ1dHRvbiA9IHRoaXMuX2NyZWF0ZVBsYXlQYXVzZUJ1dHRvbigpXG4gICAgdGhpcy5fbXV0ZUJ1dHRvbiA9IHRoaXMuX2NyZWF0ZU11dGVCdXR0b24oKVxuICAgIHRoaXMuX3ZvbHVtZUZpZWxkID0gdGhpcy5fY3JlYXRlVm9sdW1lQ29udHJvbCgpXG4gICAgdGhpcy5fc2Vla1RpbWVGaWVsZCA9IHRoaXMuX2NyZWF0ZVNlZWtDb250cm9sKClcbiAgICB0aGlzLl90aW1lRmllbGQgPSB0aGlzLl9jcmVhdGVQbGF5YmFja1RpbWUoKVxuICAgIHRoaXMuX2Z1bGxTY3JlZW5CdXR0b24gPSB0aGlzLl9jcmVhdGVGdWxsU2NyZWVuVG9nZ2xlKClcbiAgICBjb250cm9sYmFyLmFwcGVuZENoaWxkKHRoaXMuX3BsYXlQYXVzZUJ1dHRvbilcbiAgICBjb250cm9sYmFyLmFwcGVuZENoaWxkKHRoaXMuX3RpbWVGaWVsZClcbiAgICBjb250cm9sYmFyLmFwcGVuZENoaWxkKHRoaXMuX3NlZWtUaW1lRmllbGQudmlldylcbiAgICBjb250cm9sYmFyLmFwcGVuZENoaWxkKHRoaXMuX211dGVCdXR0b24pXG4gICAgY29udHJvbGJhci5hcHBlbmRDaGlsZCh0aGlzLl92b2x1bWVGaWVsZC52aWV3KVxuICAgIGNvbnRyb2xiYXIuYXBwZW5kQ2hpbGQodGhpcy5fZnVsbFNjcmVlbkJ1dHRvbilcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbGJhcilcblxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsICgpID0+IHtcbiAgICAgIGNvbnRyb2xiYXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250cm9sLWJhci1zaG93JylcbiAgICB9KVxuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgKCkgPT4ge1xuICAgICAgY29udHJvbGJhci5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtYmFyLXNob3cnKVxuICAgIH0pXG5cbiAgICB0aGlzLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuSURMRSlcbiAgICAgIC5vbkZ1bGxTY3JlZW5DaGFuZ2UoZmFsc2UpXG4gICAgICAuc2V0U2Vla1RpbWUoMClcbiAgICAgIC5lbmFibGVQbGF5UGF1c2UoZmFsc2UpXG4gIH1cblxuICBfb25QbGF5UGF1c2VDbGljayAoKSB7XG4gICAgaWYgKHRoaXMuZ2V0U3RhdGUoKSA9PT0gUGxheWJhY2tTdGF0ZS5QTEFZSU5HKSB7XG4gICAgICB0aGlzLnBsYXllci5wYXVzZSgpXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZ2V0U3RhdGUoKSA9PT0gUGxheWJhY2tTdGF0ZS5QQVVTRUQpIHtcbiAgICAgIHRoaXMucGxheWVyLnJlc3VtZSgpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXIucGxheSgpXG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZVBsYXlQYXVzZUJ1dHRvbiAoKSB7XG4gICAgbGV0IGJ1dHRvbiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdUb2dnbGUgUGxheWJhY2snKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtZWxlbWVudCcpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtZWxlbWVudC1idXR0b24nKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXBsYXlwYXVzZS1idXR0b24nKVxuICAgIHJldHVybiBidXR0b25cbiAgfVxuXG4gIF9jcmVhdGVNdXRlQnV0dG9uICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGxldCBidXR0b24gPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnVG9nZ2xlIE11dGUgQXVkaW8nKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtZWxlbWVudCcpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtZWxlbWVudC1idXR0b24nKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLW11dGV1bm11dGUtYnV0dG9uJylcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBpZiAoc2VsZi5nZXRNdXRlZFN0YXRlKCkpIHtcbiAgICAgICAgc2VsZi5wbGF5ZXIudW5tdXRlKClcbiAgICAgICAgc2VsZi5zZXRNdXRlZFN0YXRlKGZhbHNlKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYucGxheWVyLm11dGUoKVxuICAgICAgICBzZWxmLnNldE11dGVkU3RhdGUodHJ1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBidXR0b25cbiAgfVxuXG4gIF9jcmVhdGVWb2x1bWVDb250cm9sICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGxldCBzbGlkZXIgPSBuZXcgQ29udHJvbFNsaWRlcigndm9sdW1lJylcbiAgICBzbGlkZXIudmlldy5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtZWxlbWVudCcpXG4gICAgc2xpZGVyLnZpZXcuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS12b2x1bWUtc2xpZGVyJylcbiAgICBzbGlkZXIudmlldy5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXNsaWRlcicpXG4gICAgc2xpZGVyLm9uKFNsaWRlckV2ZW50VHlwZXMuQ0hBTkdFLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBOdW1iZXIoZXZlbnQuZGF0YSlcbiAgICAgIHNlbGYucGxheWVyLnNldFZvbHVtZShwZXJjZW50YWdlKVxuICAgIH0pXG4gICAgcmV0dXJuIHNsaWRlclxuICB9XG5cbiAgX2NyZWF0ZVNlZWtDb250cm9sICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGxldCBzbGlkZXIgPSBuZXcgQ29udHJvbFNsaWRlcignc2VlaycpXG4gICAgc2xpZGVyLnZpZXcuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250cm9sLWVsZW1lbnQnKVxuICAgIHNsaWRlci52aWV3LmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtc2Vla3RpbWUtc2xpZGVyJylcbiAgICBzbGlkZXIudmlldy5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXNsaWRlcicpXG4gICAgc2xpZGVyLm9uKFNsaWRlckV2ZW50VHlwZXMuQ0hBTkdFX1NUQVJULCAoKSA9PiB7XG4gICAgICBpZiAoc2VsZi5nZXRTdGF0ZSgpID09PSBQbGF5YmFja1N0YXRlLlBMQVlJTkcpIHtcbiAgICAgICAgc2VsZi5fcmVzdW1lQWZ0ZXJTZWVrID0gdHJ1ZVxuICAgICAgICBzZWxmLnBsYXllci5wYXVzZSgpXG4gICAgICB9XG4gICAgfSlcbiAgICBzbGlkZXIub24oU2xpZGVyRXZlbnRUeXBlcy5DSEFOR0UsIChldmVudCkgPT4ge1xuICAgICAgY29uc3QgcGVyY2VudGFnZSA9IE51bWJlcihldmVudC5kYXRhKVxuICAgICAgc2VsZi5wbGF5ZXIuc2Vla1RvKHBlcmNlbnRhZ2UsIHNlbGYuX3BsYXliYWNrRHVyYXRpb24gPT09IDAgPyB1bmRlZmluZWQ6IHNlbGYuX3BsYXliYWNrRHVyYXRpb24pXG4gICAgICBzZWxmLnNldFNlZWtUaW1lKHBlcmNlbnRhZ2UgKiBzZWxmLl9wbGF5YmFja0R1cmF0aW9uLCBzZWxmLl9wbGF5YmFja0R1cmF0aW9uKVxuICAgIH0pXG4gICAgc2xpZGVyLm9uKFNsaWRlckV2ZW50VHlwZXMuQ0hBTkdFX0NPTVBMRVRFLCAoKSA9PiB7XG4gICAgICBpZiAoc2VsZi5fcmVzdW1lQWZ0ZXJTZWVrICYmIHNlbGYuZ2V0U3RhdGUoKSA9PT0gUGxheWJhY2tTdGF0ZS5QQVVTRUQpIHtcbiAgICAgICAgc2VsZi5fcmVzdW1lQWZ0ZXJTZWVrID0gZmFsc2VcbiAgICAgICAgc2VsZi5wbGF5ZXIucmVzdW1lKClcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBzbGlkZXJcbiAgfVxuXG4gIF9jcmVhdGVQbGF5YmFja1RpbWUgKCkge1xuICAgIGxldCBzcGFuID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgbGV0IHRleHQgPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0JywgJ2hlbGxvIScpXG4gICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRyb2wtZWxlbWVudCcpXG4gICAgc3Bhbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXRpbWUtZmllbGQnKVxuICAgIHNwYW4uYXBwZW5kQ2hpbGQodGV4dClcbiAgICByZXR1cm4gc3BhblxuICB9XG5cbiAgX2NyZWF0ZUZ1bGxTY3JlZW5Ub2dnbGUgKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgbGV0IGJ1dHRvbiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdUb2dnbGUgRnVsbHNjcmVlbicpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udHJvbC1lbGVtZW50JylcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1lbGVtZW50LWJ1dHRvbicpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtZnVsbHNjcmVlbi1idXR0b24nKVxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHNlbGYucGxheWVyLnRvZ2dsZUZ1bGxTY3JlZW4oKVxuICAgIH0pXG4gICAgcmV0dXJuIGJ1dHRvblxuICB9XG5cbiAgZm9ybWF0VGltZSAodmFsdWUpIHtcbiAgICBsZXQgaHJzID0gMFxuICAgIGxldCBtaW5zID0gdmFsdWUgPT09IDAgPyAwIDogcGFyc2VJbnQodmFsdWUgLyA2MClcbiAgICBsZXQgc2VjcyA9IDBcbiAgICBpZiAobWlucyA+PSA2MCkge1xuICAgICAgaHJzID0gcGFyc2VJbnQobWlucyAvIDYwKVxuICAgICAgbWlucyA9IG1pbnMgJSA2MFxuICAgIH1cbiAgICBzZWNzID0gdmFsdWUgPT09IDAgPyAwIDogcGFyc2VJbnQodmFsdWUgJSA2MClcblxuICAgIGxldCBmb3JtYXR0ZWRBcnIgPSAoaHJzIDwgMTApID8gWycwJyArIGhyc10gOiBbaHJzXVxuICAgIGZvcm1hdHRlZEFyci5wdXNoKChtaW5zIDwgMTApID8gWycwJyArIG1pbnNdIDogW21pbnNdKVxuICAgIGZvcm1hdHRlZEFyci5wdXNoKChzZWNzIDwgMTApID8gWycwJyArIHNlY3NdIDogW3NlY3NdKVxuICAgIHJldHVybiBmb3JtYXR0ZWRBcnIuam9pbignOicpXG4gIH1cblxuICBnZXRWb2x1bWUgKCkge1xuICAgIHJldHVybiB0aGlzLl92b2x1bWVWYWx1ZVxuICB9XG5cbiAgc2V0Vm9sdW1lICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZvbHVtZUZpZWxkLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl92b2x1bWVWYWx1ZSA9IHZhbHVlXG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLnNldE11dGVkU3RhdGUodHJ1ZSlcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5nZXRNdXRlZFN0YXRlKCkpIHtcbiAgICAgIHRoaXMuc2V0TXV0ZWRTdGF0ZShmYWxzZSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldFNlZWtUaW1lICh2YWx1ZSwgbGVuZ3RoID0gMCkge1xuICAgIHRoaXMuX3NlZWtUaW1lRmllbGQudmFsdWUgPSBsZW5ndGggPT09IDAgPyAwIDogKHZhbHVlL2xlbmd0aClcbiAgICBpZiAodGhpcy5fcGxheWJhY2tEdXJhdGlvbiAhPT0gMCAmJiBwYXJzZUludCh0aGlzLl9wbGF5YmFja0R1cmF0aW9uKSA8PSBwYXJzZUludCh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX3NlZWtUaW1lRmllbGQudmFsdWUgPSAxXG4gICAgfVxuICAgIHRoaXMuX3RpbWVGaWVsZC5pbm5lclRleHQgPSB0aGlzLmZvcm1hdFRpbWUoTWF0aC5mbG9vcih2YWx1ZSkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldFBsYXliYWNrRHVyYXRpb24gKHZhbHVlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZXRwbGF5YmFja2R1cmF0aW9uXTogJyArIHZhbHVlKVxuICAgIHRoaXMuX3BsYXliYWNrRHVyYXRpb24gPSB2YWx1ZVxuICB9XG5cbiAgZW5hYmxlUGxheVBhdXNlICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtZWxlbWVudC1idXR0b24tZGlzYWJsZWQnKVxuICAgICAgdGhpcy5fcGxheVBhdXNlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25QbGF5UGF1c2VDbGlja0JvdW5kKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3BsYXlQYXVzZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWVsZW1lbnQtYnV0dG9uLWRpc2FibGVkJylcbiAgICAgIHRoaXMuX3BsYXlQYXVzZUJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uUGxheVBhdXNlQ2xpY2tCb3VuZClcbiAgICB9XG4gIH1cblxuICBnZXRTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlXG4gIH1cblxuICBzZXRTdGF0ZSAoc3RhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldFN0YXRlXTogJyArIFBsYXliYWNrU3RhdGVSZWFkYWJsZVtzdGF0ZV0pXG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZVxuICAgIHRoaXMub25TdGF0ZUNoYW5nZSh0aGlzLl9zdGF0ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0TXV0ZWRTdGF0ZSAoKSB7XG4gICAgcmV0dXJuICgnbXV0ZWQnIGluIHRoaXMucGxheWVyKSA/IHRoaXMucGxheWVyLm11dGVkIDogdGhpcy5fbXV0ZWRTdGF0ZVxuICB9XG5cbiAgc2V0TXV0ZWRTdGF0ZSAoc3RhdGUpIHtcbiAgICB0aGlzLl9tdXRlZFN0YXRlID0gc3RhdGVcbiAgICB0aGlzLm9uTXV0ZWRTdGF0ZUNoYW5nZSh0aGlzLl9tdXRlZFN0YXRlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvblN0YXRlQ2hhbmdlIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gUGxheWJhY2tTdGF0ZS5QTEFZSU5HKSB7XG4gICAgICB0aGlzLl9wbGF5UGF1c2VCdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1wbGF5LWJ1dHRvbicpXG4gICAgICB0aGlzLl9wbGF5UGF1c2VCdXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1wYXVzZS1idXR0b24nKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3BsYXlQYXVzZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLXBsYXktYnV0dG9uJylcbiAgICAgIHRoaXMuX3BsYXlQYXVzZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLXBhdXNlLWJ1dHRvbicpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvbk11dGVkU3RhdGVDaGFuZ2UgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0aGlzLl9tdXRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtbXV0ZS1idXR0b24nKVxuICAgICAgdGhpcy5fbXV0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLXVubXV0ZS1idXR0b24nKVxuICAgICAgdGhpcy5fdm9sdW1lRmllbGQudmFsdWUgPSAwXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fbXV0ZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLW11dGUtYnV0dG9uJylcbiAgICAgIHRoaXMuX211dGVCdXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS11bm11dGUtYnV0dG9uJylcbiAgICAgIHRoaXMuX3ZvbHVtZUZpZWxkLnZhbHVlID0gdGhpcy5fdm9sdW1lVmFsdWVcbiAgICB9XG4gIH1cblxuICBvbkZ1bGxTY3JlZW5DaGFuZ2UgKGlzRnVsbFNjcmVlbikge1xuICAgIGlmIChpc0Z1bGxTY3JlZW4pIHtcbiAgICAgIHRoaXMuX2Z1bGxTY3JlZW5CdXR0b24uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1leGl0LWZ1bGxzY3JlZW4tYnV0dG9uJylcbiAgICAgIHRoaXMuX2Z1bGxTY3JlZW5CdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1mdWxsc2NyZWVuLWJ1dHRvbicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFNjcmVlbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWV4aXQtZnVsbHNjcmVlbi1idXR0b24nKVxuICAgICAgdGhpcy5fZnVsbFNjcmVlbkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWZ1bGxzY3JlZW4tYnV0dG9uJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldEFzVk9EIChpc1ZPRCkge1xuICAgIGRlYnVnKE5BTUUsICdbc2V0QXNWT0RdOiAnICsgaXNWT0QpXG4gICAgaWYgKCFpc1ZPRCkge1xuICAgICAgdGhpcy5fc2Vla1RpbWVGaWVsZC52YWx1ZT0gMFxuICAgICAgdGhpcy5fc2Vla1RpbWVGaWVsZC5kaXNhYmxlZCA9IHRydWVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zZWVrVGltZUZpZWxkLmRpc2FibGVkID0gZmFsc2VcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgY29uc3QgUGxheWJhY2tDb250cm9scyA9IF9QbGF5YmFja0NvbnRyb2xzXG5leHBvcnQgY29uc3QgUGxheWJhY2tDb250cm9sc0ltcGwgPSBfUGxheWJhY2tDb250cm9sc0ltcGxcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3N1YnNjcmliZXIvY29udHJvbHMvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4sIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUGxheWJhY2tWaWV3J1xuY29uc3QgcGxheWJhY2tJZCA9ICdyZWQ1cHJvLXN1YnNjcmliZXInXG5cbmV4cG9ydCBjbGFzcyBQbGF5YmFja1ZpZXcge1xuXG4gIGNvbnN0cnVjdG9yIChlbGVtZW50SWQgPSBwbGF5YmFja0lkKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRhcmdldCB2aWRlbyBlbGVtZW50LlxuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudCA9IGVudmlyb25tZW50LnJlc29sdmVFbGVtZW50KGVsZW1lbnRJZClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIG9mIFJlZDVQcm9TdWJzY3JpYmVyLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoU3Vic2NyaWJlciAoc3Vic2NyaWJlcikge1xuICAgIGRlYnVnKE5BTUUsICdbYXR0YWNoc3Vic2NyaWJlcl0nKVxuICAgIHN1YnNjcmliZXIuc2V0Vmlldyh0aGlzLCBlbnZpcm9ubWVudC5nZXRFbGVtZW50SWQodGhpcy5fdGFyZ2V0RWxlbWVudCkpXG4gIH1cblxuICBhdHRhY2hTdHJlYW0gKG1lZGlhU3RyZWFtKSB7XG4gICAgbGV0IGF1dG9wbGF5ID0gdGhpcy5pc0F1dG9wbGF5XG4gICAgZGVidWcoTkFNRSwgJ1thdHRhY2hzdHJlYW1dJylcbiAgICBlbnZpcm9ubWVudC5zZXRWaWRlb1NvdXJjZSh0aGlzLl90YXJnZXRFbGVtZW50LCBtZWRpYVN0cmVhbSwgYXV0b3BsYXkpXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudC5wYXVzZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihOQU1FLCBgQ291bGQgbm90IHN0b3AgdmlkZW8gZWxlbWVudDogJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH1cblxuICBnZXQgaXNBdXRvcGxheSAoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5fdGFyZ2V0RWxlbWVudCwgJ2F1dG9wbGF5JylcbiAgfVxuXG4gIGdldCB2aWV3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWxlbWVudFxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWJhY2tWaWV3XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvdmlldy9wbGF5YmFjay5qcyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIG1ldGEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkaXRlckRldGVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyAgICA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSAgICAgICAgICAgICA9IG5ldyBDXG4gICAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgICAsIEhBU05UX0NIQUlOSU5HICAgICAgID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZVxuICAgICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAsIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24oKXsgaW5zdGFuY2UuaGFzKDEpOyB9KVxuICAgICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgICAgLCBBQ0NFUFRfSVRFUkFCTEVTICAgICA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgICAgLCBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpXG4gICAgICAgICAgLCBpbmRleCAgICAgPSA1O1xuICAgICAgICB3aGlsZShpbmRleC0tKSRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICAgIH0pO1xuICAgIGlmKCFBQ0NFUFRfSVRFUkFCTEVTKXsgXG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZihCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGZhaWxzICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgd2tzICAgICAgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGxlbmd0aCwgZXhlYyl7XG4gIHZhciBTWU1CT0wgICA9IHdrcyhLRVkpXG4gICAgLCBmbnMgICAgICA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKVxuICAgICwgc3RyZm4gICAgPSBmbnNbMF1cbiAgICAsIHJ4Zm4gICAgID0gZm5zWzFdO1xuICBpZihmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpe1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24oc3RyaW5nLCBhcmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uKHN0cmluZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbCkgICAgIHJlc3VsdCArPSAnZyc7XG4gIGlmKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpICByZXN1bHQgKz0gJ20nO1xuICBpZih0aGF0LnVuaWNvZGUpICAgIHJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KSAgICAgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgTUFUQ0ggICAgPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKXx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBUWVBFRCAgPSB1aWQoJ3R5cGVkX2FycmF5JylcbiAgLCBWSUVXICAgPSB1aWQoJ3ZpZXcnKVxuICAsIEFCViAgICA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpXG4gICwgQ09OU1RSID0gQUJWXG4gICwgaSA9IDAsIGwgPSA5LCBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUoaSA8IGwpe1xuICBpZihUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKXtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiAgICBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogIFRZUEVELFxuICBWSUVXOiAgIFZJRVdcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LnN1cHBvcnRzV2ViU29ja2V0KClcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LmNyZWF0ZVdlYlNvY2tldCh1cmwpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvYWRhcHRlci93ZWJzb2NrZXQuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGNvbnN0IFB1Ymxpc2hUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBSVE1QOiAncnRtcCcsXG4gIFJUQzogJ3J0Yydcbn0pXG5cbmV4cG9ydCBjb25zdCBQdWJsaXNoTW9kZVR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIExJVkU6ICdsaXZlJyxcbiAgUkVDT1JEOiAncmVjb3JkJyxcbiAgQVBQRU5EOiAnYXBwZW5kJ1xufSlcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2VudW0vcHVibGlzaC5qcyIsImV4cG9ydCBjb25zdCBjb21tb24gPSBPYmplY3QuZnJlZXplKHtcbiAgQ09OTkVDVF9TVUNDRVNTOiAnQ29ubmVjdC5TdWNjZXNzJyxcbiAgQ09OTkVDVF9GQUlMVVJFOiAnQ29ubmVjdC5GYWlsdXJlJyxcbiAgUFJPUEVSVFlfVVBEQVRFOiAnU2hhcmVkT2JqZWN0LlByb3BlcnR5VXBkYXRlJyxcbiAgTUVUSE9EX1VQREFURTogJ1NoYXJlZE9iamVjdC5NZXRob2RVcGRhdGUnXG59KVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZXZlbnQvc2hhcmVkb2JqZWN0LWV2ZW50LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcblxuaW1wb3J0IHsgZGVidWcsIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuY29uc3QgTkFNRSA9ICdSNVByb1B1Ymxpc2hWaWV3J1xuXG5jb25zdCBwdWJsaXNoZXJJZCA9ICdyZWQ1cHJvLXB1Ymxpc2hlcidcblxuY2xhc3MgUHVibGlzaFZpZXcge1xuXG4gIGNvbnN0cnVjdG9yIChlbGVtZW50SWQgPSBwdWJsaXNoZXJJZCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl90YXJnZXRFbGVtZW50ID0gZW52aXJvbm1lbnQucmVzb2x2ZUVsZW1lbnQoZWxlbWVudElkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgaW5zdGFudGlhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUmVkNVByb1B1Ymxpc2hlci4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIGF0dGFjaFB1Ymxpc2hlciAocHVibGlzaGVyKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thdHRhY2hwdWJsaXNoZXJdJylcbiAgICBwdWJsaXNoZXIuc2V0Vmlldyh0aGlzLCBlbnZpcm9ubWVudC5nZXRFbGVtZW50SWQodGhpcy5fdGFyZ2V0RWxlbWVudCkpXG4gIH1cblxuICBwcmV2aWV3IChtZWRpYVN0cmVhbSkge1xuICAgIGxldCBhdXRvcGxheSA9IHRoaXMuaXNBdXRvcGxheVxuICAgIGRlYnVnKE5BTUUsIGBbcHJldmlld106IGF1dG9wbGF5KCR7YXV0b3BsYXl9KWApXG4gICAgZW52aXJvbm1lbnQuc2V0VmlkZW9Tb3VyY2UodGhpcy5fdGFyZ2V0RWxlbWVudCwgbWVkaWFTdHJlYW0sIGF1dG9wbGF5KVxuICB9XG5cbiAgZ2V0IGlzQXV0b3BsYXkgKCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudC5oYXNBdHRyaWJ1dGVEZWZpbmVkKHRoaXMuX3RhcmdldEVsZW1lbnQsICdhdXRvcGxheScpXG4gIH1cblxuICBnZXQgdmlldyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldEVsZW1lbnRcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFB1Ymxpc2hWaWV3XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvdmlldy9wdWJsaXNoLmpzIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSB0b0luZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpXG4gICAgLCBlbmQgICAgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2goZSl7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoKGYpeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgdGFyZ2V0LCBDKXtcbiAgdmFyIFAsIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIGlmKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2Ype1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG4gICAgICAsIGwgPSBzLmxlbmd0aFxuICAgICAgLCBhLCBiO1xuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSl7XG4gIGlmKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSlcbiAgICAsIHJlcyA9ICcnXG4gICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xuICBpZihuIDwgMCB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkdHlwZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBhbkluc3RhbmNlICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCB0b0ludGVnZXIgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnT1BOICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGFycmF5RmlsbCAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgQVJSQVlfQlVGRkVSICAgPSAnQXJyYXlCdWZmZXInXG4gICwgREFUQV9WSUVXICAgICAgPSAnRGF0YVZpZXcnXG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIFdST05HX0xFTkdUSCAgID0gJ1dyb25nIGxlbmd0aCEnXG4gICwgV1JPTkdfSU5ERVggICAgPSAnV3JvbmcgaW5kZXghJ1xuICAsICRBcnJheUJ1ZmZlciAgID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl1cbiAgLCAkRGF0YVZpZXcgICAgICA9IGdsb2JhbFtEQVRBX1ZJRVddXG4gICwgTWF0aCAgICAgICAgICAgPSBnbG9iYWwuTWF0aFxuICAsIFJhbmdlRXJyb3IgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgLCBJbmZpbml0eSAgICAgICA9IGdsb2JhbC5JbmZpbml0eVxuICAsIEJhc2VCdWZmZXIgICAgID0gJEFycmF5QnVmZmVyXG4gICwgYWJzICAgICAgICAgICAgPSBNYXRoLmFic1xuICAsIHBvdyAgICAgICAgICAgID0gTWF0aC5wb3dcbiAgLCBmbG9vciAgICAgICAgICA9IE1hdGguZmxvb3JcbiAgLCBsb2cgICAgICAgICAgICA9IE1hdGgubG9nXG4gICwgTE4yICAgICAgICAgICAgPSBNYXRoLkxOMlxuICAsIEJVRkZFUiAgICAgICAgID0gJ2J1ZmZlcidcbiAgLCBCWVRFX0xFTkdUSCAgICA9ICdieXRlTGVuZ3RoJ1xuICAsIEJZVEVfT0ZGU0VUICAgID0gJ2J5dGVPZmZzZXQnXG4gICwgJEJVRkZFUiAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVJcbiAgLCAkTEVOR1RIICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIXG4gICwgJE9GRlNFVCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciBwYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKHZhbHVlLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgYnVmZmVyID0gQXJyYXkobkJ5dGVzKVxuICAgICwgZUxlbiAgID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICAgPSAoMSA8PCBlTGVuKSAtIDFcbiAgICAsIGVCaWFzICA9IGVNYXggPj4gMVxuICAgICwgcnQgICAgID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMFxuICAgICwgaSAgICAgID0gMFxuICAgICwgcyAgICAgID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMFxuICAgICwgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpXG4gIGlmKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSl7XG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpe1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmKHZhbHVlICogYyA+PSAyKXtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IGVNYXgpe1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvcig7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59O1xudmFyIHVucGFja0lFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBlTGVuICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgPSAoMSA8PCBlTGVuKSAtIDFcbiAgICAsIGVCaWFzID0gZU1heCA+PiAxXG4gICAgLCBuQml0cyA9IGVMZW4gLSA3XG4gICAgLCBpICAgICA9IG5CeXRlcyAtIDFcbiAgICAsIHMgICAgID0gYnVmZmVyW2ktLV1cbiAgICAsIGUgICAgID0gcyAmIDEyN1xuICAgICwgbTtcbiAgcyA+Pj0gNztcbiAgZm9yKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZihlID09PSAwKXtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYoZSA9PT0gZU1heCl7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59O1xuXG52YXIgdW5wYWNrSTMyID0gZnVuY3Rpb24oYnl0ZXMpe1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn07XG52YXIgcGFja0k4ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59O1xudmFyIHBhY2tJMTYgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59O1xudmFyIHBhY2tJMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrRjY0ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn07XG52YXIgcGFja0YzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oQywga2V5LCBpbnRlcm5hbCl7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH19KTtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKXtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4XG4gICAgLCBpbnRJbmRleCA9IHRvSW50ZWdlcihudW1JbmRleCk7XG4gIGlmKG51bUluZGV4ICE9IGludEluZGV4IHx8IGludEluZGV4IDwgMCB8fCBpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYlxuICAgICwgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF1cbiAgICAsIHBhY2sgID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59O1xudmFyIHNldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKXtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4XG4gICAgLCBpbnRJbmRleCA9IHRvSW50ZWdlcihudW1JbmRleCk7XG4gIGlmKG51bUluZGV4ICE9IGludEluZGV4IHx8IGludEluZGV4IDwgMCB8fCBpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYlxuICAgICwgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF1cbiAgICAsIHBhY2sgID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKylzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn07XG5cbnZhciB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzID0gZnVuY3Rpb24odGhhdCwgbGVuZ3RoKXtcbiAgYW5JbnN0YW5jZSh0aGF0LCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gIHZhciBudW1iZXJMZW5ndGggPSArbGVuZ3RoXG4gICAgLCBieXRlTGVuZ3RoICAgPSB0b0xlbmd0aChudW1iZXJMZW5ndGgpO1xuICBpZihudW1iZXJMZW5ndGggIT0gYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gIHJldHVybiBieXRlTGVuZ3RoO1xufTtcblxuaWYoISR0eXBlZC5BQlYpe1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgIHZhciBieXRlTGVuZ3RoID0gdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpO1xuICAgIHRoaXMuX2IgICAgICAgPSBhcnJheUZpbGwuY2FsbChBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF1cbiAgICAgICwgb2Zmc2V0ICAgICAgID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmKERFU0NSSVBUT1JTKXtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYoIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcjsgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSl7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7ICl7XG4gICAgICBpZighKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9O1xuICAgIGlmKCFMSUJSQVJZKUFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKVxuICAgICwgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBjb25zdCBQbGF5YmFja1R5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFJUQzogJ3J0YycsXG4gIFJUTVA6ICdydG1wJyxcbiAgSExTOiAnaGxzJ1xufSlcblxuZXhwb3J0IGNvbnN0IFBsYXliYWNrQXVkaW9FbmNvZGVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gIE9QVVM6ICdPcHVzJyxcbiAgUENNVTogJ1BDTVUnLFxuICBQQ01BOiAnUENNQScsXG4gIFNQRUVYOiAnU3BlZXgnLFxuICBOT05FOiAnTk9ORSdcbn0pXG5cbmV4cG9ydCBjb25zdCBQbGF5YmFja1ZpZGVvRW5jb2RlciA9IE9iamVjdC5mcmVlemUoe1xuICBWUDg6ICdWUDgnLFxuICBIMjY0OiAnSDI2NCcsXG4gIE5PTkU6ICdOT05FJ1xufSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9lbnVtL3BsYXliYWNrLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuL2Jyb3dzZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5cbmV4cG9ydCBjb25zdCBkZWZpbmVFbWJlZEVsZW1lbnQgPSAodGFyZ2V0RWxlbWVudCwgdGFyZ2V0UGFyZW50KSA9PiB7XG4gIGxldCBkZmQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgY29uc3QgZWxlbWVudElkID0gdGFyZ2V0RWxlbWVudC5pZFxuICBpZiAodGFyZ2V0RWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8nKSB7XG4gICAgbGV0IGRpdiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgZGl2LmlkID0gZWxlbWVudElkICsgJ19ydG1wJ1xuICAgIHRhcmdldFBhcmVudC5hcHBlbmRDaGlsZChkaXYpXG4gICAgaWYgKHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldEVsZW1lbnQpXG4gICAgfVxuICAgIGRmZC5yZXNvbHZlKGRpdi5pZClcbiAgfSBlbHNlIHtcbiAgICBkZmQucmVzb2x2ZShlbGVtZW50SWQpXG4gIH1cbiAgcmV0dXJuIGRmZC5wcm9taXNlXG59XG5cbmV4cG9ydCBjb25zdCBlbWJlZFN3Zk9iamVjdCA9IChpZE5hbWUsIG9wdGlvbnMsIGZsYXNodmFycywgc3dmb2JqZWN0LCBlbGVtZW50SWQpID0+IHtcbiAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICBsZXQgcGFyYW1zID0ge1xuICAgIHF1YWxpdHk6ICdoaWdoJyxcbiAgICB3bW9kZTogJ29wYXF1ZScsXG4gICAgYmdjb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgJyMwMDAnLFxuICAgIGFsbG93c2NyaXB0YWNjZXNzOiAnYWx3YXlzJyxcbiAgICBhbGxvd2Z1bGxzY3JlZW46ICd0cnVlJyxcbiAgICBhbGxvd25ldHdvcmtpbmc6ICdhbGwnXG4gIH1cbiAgbGV0IGF0dHJpYnV0ZXMgPSB7XG4gICAgaWQ6IGlkTmFtZSxcbiAgICBuYW1lOiBpZE5hbWUsXG4gICAgYWxpZ246ICdtaWRkbGUnXG4gIH1cbiAgaWYgKHN3Zm9iamVjdC5oYXNGbGFzaFBsYXllclZlcnNpb24ob3B0aW9ucy5taW5GbGFzaFZlcnNpb24pKSB7XG4gICAgc3dmb2JqZWN0LmVtYmVkU1dGKFxuICAgICAgb3B0aW9ucy5zd2YsXG4gICAgICBlbGVtZW50SWQsXG4gICAgICBvcHRpb25zLmVtYmVkV2lkdGggfHwgNjQwLFxuICAgICAgb3B0aW9ucy5lbWJlZEhlaWdodCB8fCA0ODAsXG4gICAgICBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbixcbiAgICAgIG9wdGlvbnMucHJvZHVjdEluc3RhbGxVUkwsXG4gICAgICBmbGFzaHZhcnMsXG4gICAgICBwYXJhbXMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgZGZkLnJlc29sdmUpXG4gIH0gZWxzZSB7XG4gICAgZGZkLnJlamVjdCgnRmxhc2ggUGxheWVyIFZlcnNpb24gaXMgbm90IHN1cHBvcnRlZC4nKVxuICB9XG4gIHJldHVybiBkZmQucHJvbWlzZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2Vudi9lbWJlZC5qcyIsImV4cG9ydCBjb25zdCBjb21tb24gPSBPYmplY3QuZnJlZXplKHtcbiAgQ09OTkVDVF9TVUNDRVNTOiAnQ29ubmVjdC5TdWNjZXNzJyxcbiAgQ09OTkVDVF9GQUlMVVJFOiAnQ29ubmVjdC5GYWlsdXJlJyxcbiAgUFVCTElTSF9TVEFSVDogJ1B1Ymxpc2guU3RhcnQnLFxuICBQVUJMSVNIX0ZBSUw6ICdQdWJsaXNoLkZhaWwnLFxuICBQVUJMSVNIX0lOVkFMSURfTkFNRTogJ1B1Ymxpc2guSW52YWxpZE5hbWUnLFxuICBVTlBVQkxJU0hfU1VDQ0VTUzogJ1VucHVibGlzaC5TdWNjZXNzJyxcbiAgUFVCTElTSF9NRVRBREFUQTogJ1B1Ymxpc2guTWV0YWRhdGEnLFxuICBDT05ORUNUSU9OX0NMT1NFRDogJ1B1Ymxpc2hlci5Db25uZWN0aW9uLkNsb3NlZCcsXG4gIERJTUVOU0lPTl9DSEFOR0U6ICdQdWJsaXNoZXIuVmlkZW8uRGltZW5zaW9uQ2hhbmdlJ1xufSlcblxuZXhwb3J0IGNvbnN0IGZhaWxvdmVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBVQkxJU0hFUl9SRUpFQ1Q6ICdQdWJsaXNoZXIuUmVqZWN0JyxcbiAgUFVCTElTSEVSX0FDQ0VQVDogJ1B1Ymxpc2hlci5BY2NlcHQnXG59KVxuXG5leHBvcnQgY29uc3QgcnRjID0gT2JqZWN0LmZyZWV6ZSh7XG4gIE1FRElBX1NUUkVBTV9BVkFJTEFCTEU6ICdXZWJSVEMuTWVkaWFTdHJlYW0uQXZhaWxhYmxlJyxcbiAgUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRTogJ1dlYlJUQy5QZWVyQ29ubmVjdGlvbi5BdmFpbGFibGUnLFxuICBPRkZFUl9TVEFSVDogJ1dlYlJUQy5PZmZlci5TdGFydCcsXG4gIE9GRkVSX0VORDogJ1dlYlJUQy5PZmZlci5FbmQnLFxuICBJQ0VfVFJJQ0tMRV9DT01QTEVURTogJ1dlYlJUQy5JY2VUcmlja2xlLkNvbXBsZXRlJ1xufSlcblxuZXhwb3J0IGNvbnN0IHJ0bXAgPSBPYmplY3QuZnJlZXplKHtcbiAgRU1CRURfU1VDQ0VTUzogJ0ZsYXNoUGxheWVyLkVtYmVkLlN1Y2Nlc3MnLFxuICBFTUJFRF9GQUlMVVJFOiAnRmxhc2hQbGF5ZXIuRW1iZWQuRmFpbHVyZSdcbn0pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZXZlbnQvcHVibGlzaGVyLWV2ZW50LmpzIiwiZXhwb3J0IGNvbnN0IGNvbW1vbiA9IE9iamVjdC5mcmVlemUoe1xuICBDT05ORUNUX1NVQ0NFU1M6ICdDb25uZWN0LlN1Y2Nlc3MnLFxuICBDT05ORUNUX0ZBSUxVUkU6ICdDb25uZWN0LkZhaWx1cmUnLFxuICBTVUJTQ1JJQkVfU1RBUlQ6ICdTdWJzY3JpYmUuU3RhcnQnLFxuICBTVUJTQ1JJQkVfU1RPUDogJ1N1YnNjcmliZS5TdG9wJyxcbiAgU1VCU0NSSUJFX0ZBSUw6ICdTdWJzY3JpYmUuRmFpbCcsXG4gIFNVQlNDUklCRV9JTlZBTElEX05BTUU6ICdTdWJzY3JpYmUuSW52YWxpZE5hbWUnLFxuICBTVUJTQ1JJQkVfTUVUQURBVEE6ICdTdWJzY3JpYmUuTWV0YWRhdGEnLFxuICBTVUJTQ1JJQkVfU0VORF9JTlZPS0U6ICdTdWJzY3JpYmUuU2VuZC5JbnZva2UnLFxuICBQTEFZX1VOUFVCTElTSDogJ1N1YnNjcmliZS5QbGF5LlVucHVibGlzaCcsXG4gIENPTk5FQ1RJT05fQ0xPU0VEOiAnU3Vic2NyaWJlLkNvbm5lY3Rpb24uQ2xvc2VkJyxcbiAgT1JJRU5UQVRJT05fQ0hBTkdFOiAnU3Vic2NyaWJlLk9yaWVudGF0aW9uLkNoYW5nZScsXG4gIFZPTFVNRV9DSEFOR0U6ICdTdWJzY3JpYmUuVm9sdW1lLkNoYW5nZScsXG4gIFBMQVlCQUNLX1RJTUVfVVBEQVRFOiAnU3Vic2NyaWJlLlRpbWUuVXBkYXRlJyxcbiAgUExBWUJBQ0tfU1RBVEVfQ0hBTkdFOiAnU3Vic2NyaWJlLlBsYXliYWNrLkNoYW5nZScsXG4gIEZVTExfU0NSRUVOX1NUQVRFX0NIQU5HRTogJ1N1YnNjcmliZS5GdWxsU2NyZWVuLkNoYW5nZSdcbn0pXG5cbmV4cG9ydCBjb25zdCBmYWlsb3ZlciA9IE9iamVjdC5mcmVlemUoe1xuICBTVUJTQ1JJQkVSX1JFSkVDVDogJ1N1YnNjcmliZXIuUmVqZWN0JyxcbiAgU1VCU0NSSUJFUl9BQ0NFUFQ6ICdTdWJzY3JpYmVyLkFjY2VwdCdcbn0pXG5cbmV4cG9ydCBjb25zdCBydGMgPSBPYmplY3QuZnJlZXplKHtcbiAgUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRTogJ1dlYlJUQy5QZWVyQ29ubmVjdGlvbi5BdmFpbGFibGUnLFxuICBPRkZFUl9TVEFSVDogJ1dlYlJUQy5PZmZlci5TdGFydCcsXG4gIE9GRkVSX0VORDogJ1dlYlJUQy5PZmZlci5FbmQnLFxuICBBTlNXRVJfU1RBUlQ6ICdXZWJSVEMuQW5zd2VyLlN0YXJ0JyxcbiAgQU5TV0VSX0VORDogJ1dlYlJUQy5BbnN3ZXIuRW5kJyxcbiAgQ0FORElEQVRFX1NUQVJUOiAnV2ViUlRDLkNhbmRpZGF0ZS5TdGFydCcsXG4gIENBTkRJREFURV9FTkQ6ICdXZWJSVEMuQ2FuZGlkYXRlLkVuZCcsXG4gIElDRV9UUklDS0xFX0NPTVBMRVRFOiAnV2ViUlRDLkljZVRyaWNrbGUuQ29tcGxldGUnXG59KVxuXG5leHBvcnQgY29uc3QgcnRtcCA9IE9iamVjdC5mcmVlemUoe1xuICBFTUJFRF9TVUNDRVNTOiAnRmxhc2hQbGF5ZXIuRW1iZWQuU3VjY2VzcycsXG4gIEVNQkVEX0ZBSUxVUkU6ICdGbGFzaFBsYXllci5FbWJlZC5GYWlsdXJlJ1xufSlcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2V2ZW50L3N1YnNjcmliZXItZXZlbnQuanMiLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9SVE1QU2hhcmVkT2JqZWN0SGFuZGxlcidcblxuY2xhc3MgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IFtdXG4gIH1cblxuICBhZGRSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgfVxuXG4gIHJlbW92ZVJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGxldCBpID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBsZXQgckhhbmRsZXJcbiAgICB3aGlsZSgtLWkgPiAtMSkge1xuICAgICAgckhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAockhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQgKGV2ZW50KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzaGFyZWRvYmplY3Q6ZXZlbnRdJylcbiAgICBsZXQgaVxuICAgIGxldCBsZW5ndGggPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmxlbmd0aFxuICAgIGxldCBoYW5kbGVyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tpXVxuICAgICAgaWYgKGhhbmRsZXIucmVzcG9uZChKU09OLnBhcnNlKGV2ZW50KSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIgKG5hbWUsIGVsKSB7XG4gICAgY29uc3QgX2hhbmRsZVNoYXJlZE9iamVjdEV2ZW50ID0gdGhpcy5oYW5kbGVTaGFyZWRPYmplY3RFdmVudC5iaW5kKHRoaXMpXG4gICAgY29uc3QgZWxJZCA9IGVsLmlkLnNwbGl0KCctJykuam9pbignXycpXG4gICAgY29uc3QgaGFuZGxlck5hbWUgPSBbJ2hhbmRsZVNoYXJlZE9iamVjdEV2ZW50JywgZWxJZF0uam9pbignXycpXG4gICAgZGVidWcoTkFNRSwgYFthc3NpZ246c2hhcmVkb2JqZWN0OnJlc3BvbmRlcl0gOjogJHtlbElkfWApXG4gICAgZGVidWcoTkFNRSwgYFtzaGFyZWRvamVjdDpyZXNwb25kZXJdIDo6ICR7aGFuZGxlck5hbWV9YClcbiAgICBlbC5zZXRTaGFyZWRPYmplY3RSZXNwb25kZXIobmFtZSwgaGFuZGxlck5hbWUpXG4gICAgZW52aXJvbm1lbnQuc2V0R2xvYmFsKGhhbmRsZXJOYW1lLCBfaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQpXG4gIH1cblxuICBjb25uZWN0IChzd2ZJZCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdChzd2ZJZClcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIHdhcm4oYENvdWxkIG5vdCBsb2NhdGUgZW1iZWRkZWQgRmxhc2ggb2JqZWN0IGZvciBpZDogJHtzd2ZJZH1gKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIHdoaWxlICh0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuc2hpZnQoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNoYXJlZE9iamVjdFNlbmQobmFtZSwgY2FsbE5hbWUsIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ0NvdWxkIG5vdCBzZW5kIHRvIHNoYXJlZCBvYmplY3QgKCcgKyBuYW1lICsgJykuIEVycm9yOiAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNoYXJlZE9iamVjdFNlbmRQcm9wZXJ0eShuYW1lLCBrZXksIHZhbHVlKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2FybignQ291bGQgbm90IHNlbmQgdG8gc2hhcmVkIG9iamVjdCAoJyArIG5hbWUgKyAnKS4gRXJyb3I6ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tnZXRSZW1vdGVTaGFyZWRPYmplY3RdJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5hc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIoc2hhcmVkT2JqZWN0TmFtZSwgdGhpcy5fZWxlbWVudClcbiAgICAgIHRoaXMuX2VsZW1lbnQuZ2V0UmVtb3RlU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3QgZ2V0IHJlbW90ZSBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Nvbm5lY3RUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNvbm5lY3RUb1NoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2FybignQ291bGQgbm90IGNvbm5lY3QgdG8gc2hhcmVkIG9iamVjdCAoJyArIG5hbWUgKyAnKS4gRXJyb3I6ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgY2xvc2VTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3RUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmRpc2Nvbm5lY3RGcm9tU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3QgZGlzY29ubmVjdCB0byBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2hlbHBlci9zaGFyZWRvYmplY3QtaGVscGVyLXJ0bXAuanMiLCIndXNlIHN0cmljdCdcbmltcG9ydCAqIGFzIHdlYnNvY2tldCBmcm9tICcuLi9hZGFwdGVyL3dlYnNvY2tldCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGluZm8sIGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jbGFzcyBTb2NrZXRIZWxwZXIge1xuXG4gIGNvbnN0cnVjdG9yIChyZXNwb25kZXIsIG5hbWUpIHtcbiAgICB0aGlzLl9yZXNwb25kZXIgPSByZXNwb25kZXJcbiAgICB0aGlzLl9wZW5kaW5nUG9zdFJlcXVlc3RzID0gW11cbiAgICB0aGlzLl93ZWJzb2NrZXQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX25hbWUgPSBuYW1lXG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IFtdXG4gICAgdGhpcy5faXNUZXJtaW5hdGVkID0gZmFsc2VcbiAgICB0aGlzLl9vbmNsb3NlID0gdGhpcy50ZWFyRG93bi5iaW5kKHRoaXMpXG4gIH1cblxuICBfcmVtb3ZlU29ja2V0SGFuZGxlcnMgKHdzKSB7XG4gICAgd3Mub25vcGVuID0gdW5kZWZpbmVkXG4gICAgd3Mub25tZXNzYWdlID0gdW5kZWZpbmVkXG4gICAgd3Mub25lcnJvciA9IHVuZGVmaW5lZFxuICAgIHdzLm9uY2xvc2UgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9hZGRTb2NrZXRIYW5kbGVycyAod3MsIHByb21pc2UpIHtcblxuICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIGluZm8odGhpcy5fbmFtZSwgJ1t3ZWJzb2NrZXRvcGVuXScpXG4gICAgICB3aGlsZSAodGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucG9zdCh0aGlzLl9wZW5kaW5nUG9zdFJlcXVlc3RzLnNoaWZ0KCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3Mub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgdGhpcy50ZWFyRG93bigpXG4gICAgICB3YXJuKHRoaXMuX25hbWUsIGBbd2Vic29ja2V0ZXJyb3JdOiBFcnJvciBmcm9tIFdlYlNvY2tldC4gJHtlcnJvci50eXBlfWApXG4gICAgICBwcm9taXNlLnJlamVjdChlcnJvcilcbiAgICB9XG5cbiAgICB3cy5vbm1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgdGhpcy5yZXNwb25kKG1lc3NhZ2UpXG4gICAgfVxuXG4gICAgd3Mub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgd2Fybih0aGlzLl9uYW1lLCBgW3dlYnNvY2tldGNsb3NlXTogJHtldmVudC5jb2RlfWApXG4gICAgICBpZiAodGhpcy5fcmVzcG9uZGVyKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldENsb3NlKGV2ZW50KVxuICAgICAgfVxuICAgICAgdGhpcy50ZWFyRG93bigpXG4gICAgfVxuXG4gIH1cblxuICBvblVuZXhwZWN0ZWRTb2NrZXRFcnJvciAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5fcmVzcG9uZGVyKSB7XG4gICAgICB0aGlzLl9yZXNwb25kZXIub25Tb2NrZXRDbG9zZShlcnJvcilcbiAgICB9XG4gICAgd2Fybih0aGlzLl9uYW1lLCBgW3dlYnNvY2tldGVycm9yXTogVW5leHBlY3RlZCBFcnJvciBmcm9tIFdlYlNvY2tldC4gJHtlcnJvci50eXBlfSwgJHtlcnJvci5kZXRhaWx9YClcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgfVxuXG4gIHNldFVwICh1cmwsIHNldHVwUHJvbWlzZSkge1xuICAgIHRoaXMudGVhckRvd24oKVxuICAgIHRoaXMuX2lzVGVybWluYXRlZCA9IGZhbHNlXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSBzZXR1cFByb21pc2VcbiAgICBlbnZpcm9ubWVudC5hZGRDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgICB0aGlzLl93ZWJzb2NrZXQgPSB3ZWJzb2NrZXQuY3JlYXRlKHVybClcbiAgICB0aGlzLl9hZGRTb2NrZXRIYW5kbGVycyh0aGlzLl93ZWJzb2NrZXQsIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlKVxuICB9XG5cbiAgdGVhckRvd24gKCkge1xuICAgIHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMubGVuZ3RoID0gMFxuICAgIGlmICh0eXBlb2YgdGhpcy5fd2Vic29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0SGFuZGxlcnModGhpcy5fd2Vic29ja2V0KVxuICAgICAgdGhpcy5fd2Vic29ja2V0LmNsb3NlKClcbiAgICB9XG4gICAgdGhpcy5fd2Vic29ja2V0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5faXNUZXJtaW5hdGVkID0gdHJ1ZVxuICAgIHdoaWxlKHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zaGlmdCgpXG4gICAgfVxuICAgIGVudmlyb25tZW50LnJlbW92ZUNsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlKVxuICB9XG5cbiAgZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlIChtZXNzYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZS5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKSA6IG1lc3NhZ2UuZGF0YVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2Fybih0aGlzLl9uYW1lLCAnQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgYXMgSlNPTi4gTWVzc2FnZT0gJyArIG1lc3NhZ2UuZGF0YSArICcuIEVycm9yPSAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgYWRkU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpXG4gIH1cblxuICByZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICBsZXQgaSA9IHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMubGVuZ3RoXG4gICAgbGV0IHJIYW5kbGVyXG4gICAgd2hpbGUoLS1pID4gLTEpIHtcbiAgICAgIHJIYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tpXVxuICAgICAgaWYgKHJIYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuc3BsaWNlKGksIDEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU1lc3NhZ2VSZXNwb25zZSAobWVzc2FnZSkge1xuICAgIGxldCBpLCBoYW5kbGVyXG4gICAgbGV0IGxlbmd0aCA9IHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tpXVxuICAgICAgaWYgKGhhbmRsZXIucmVzcG9uZChtZXNzYWdlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHBvc3QgKHNlbmRSZXF1ZXN0KSB7XG4gICAgaWYgKHRoaXMuX3dlYnNvY2tldCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3dlYnNvY2tldC5yZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCAnW3dlYnNvY2tldC1wb3N0XTogJyArIEpTT04uc3RyaW5naWZ5KHNlbmRSZXF1ZXN0LCBudWxsLCAyKSlcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoc2VuZFJlcXVlc3QpKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgYENvdWxkIG5vdCBzZW5kIHJlcXVlc3Q6ICR7c2VuZFJlcXVlc3R9LiAke2V9YClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX3dlYnNvY2tldCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICh0aGlzLl93ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMiB8fCB0aGlzLl93ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMykpIC8qIFdlYlNvY2tldC4oQ0xPU0lORyB8IENMT1NFRCkgKi8ge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX2lzVGVybWluYXRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cy5wdXNoKHNlbmRSZXF1ZXN0KVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXNwb25kIChtZXNzYWdlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBsZXQgaGFuZGxlZCA9IHRoaXMuaGFuZGxlTWVzc2FnZVJlc3BvbnNlKG1lc3NhZ2UpXG4gICAgaWYgKCFoYW5kbGVkICYmIG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgd2Fybih0aGlzLl9uYW1lLCAnRGV0ZXJtaW5lZCB3ZWJzb2NrZXQgcmVzcG9uc2Ugbm90IGluIGNvcnJlY3QgZm9ybWF0LiBBYm9ydGluZyBtZXNzYWdlIGhhbmRsZS4nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbd2Vic29ja2V0LXJlc3BvbnNlXTogJyArIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpKVxuICAgICAgaWYgKGpzb24uaXNBdmFpbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uaXNBdmFpbGFibGUgPT09ICdib29sZWFuJyAmJiBqc29uLmlzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU3RyZWFtQXZhaWxhYmxlKGpzb24pXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TdHJlYW1VbmF2YWlsYWJsZShqc29uKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihqc29uLmRhdGEubWVzc2FnZSwganNvbi5kYXRhLmRldGFpbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5TdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0Lm9uZXJyb3IgPSB0aGlzLm9uVW5leHBlY3RlZFNvY2tldEVycm9yLmJpbmQodGhpcylcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoanNvbi5kYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLkNvbm5lY3QuUmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZS5yZWplY3QoJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5SZWplY3RlZCcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5SZWplY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnJlamVjdCgnTmV0Q29ubmVjdGlvbi5Db25uZWN0LlJlamVjdGVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVkXG4gIH1cblxuICBnZXRSZW1vdGVTaGFyZWRPYmplY3QgKG5hbWUpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0R2V0UmVtb3RlOiB7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY29ubmVjdFRvU2hhcmVkT2JqZWN0IChuYW1lKSB7XG4gICAgdGhpcy5wb3N0KHtcbiAgICAgIHNoYXJlZE9iamVjdENvbm5lY3Q6IHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzZW5kVG9TaGFyZWRPYmplY3QgKG5hbWUsIGNhbGxOYW1lLCBkYXRhKSB7XG4gICAgdGhpcy5wb3N0KHtcbiAgICAgIHNoYXJlZE9iamVjdFNlbmQ6IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgY2FsbDogY2FsbE5hbWUsXG4gICAgICAgIHBhcmFtczogW2RhdGFdXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5wb3N0KHtcbiAgICAgIHNoYXJlZE9iamVjdFNldFByb3BlcnR5OiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2xvc2VTaGFyZWRPYmplY3QgKG5hbWUpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0Q2xvc2U6IHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTb2NrZXRIZWxwZXJcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2hlbHBlci9zb2NrZXQtaGVscGVyLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGluZmxhdGUgPSAob2JqLCBwcm9wLCB2YWx1ZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSlcbn1cblxuY2xhc3MgUlRDTWVkaWFWaWRlb0NvbnN0cmFpbnQge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpbmZsYXRlKHRoaXMsICd3aWR0aCcsIHtcbiAgICAgIGV4YWN0OiA2NDBcbiAgICB9KVxuICAgIGluZmxhdGUodGhpcywgJ2hlaWdodCcsIHtcbiAgICAgIGV4YWN0OiA0ODBcbiAgICB9KVxuICB9XG5cbn1cblxuY2xhc3MgUlRNUE1lZGlhVmlkZW9Db25zdHJhaW50IHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaW5mbGF0ZSh0aGlzLCAnd2lkdGgnLCA2NDApXG4gICAgaW5mbGF0ZSh0aGlzLCAnaGVpZ2h0JywgNDgwKVxuICAgIGluZmxhdGUodGhpcywgJ2ZvcmNlJywgZmFsc2UpXG4gICAgaW5mbGF0ZSh0aGlzLCAnZnJhbWVyYXRlJywgMTUpXG4gICAgaW5mbGF0ZSh0aGlzLCAnYmFuZHdpZHRoJywgNTAwMDApXG4gICAgaW5mbGF0ZSh0aGlzLCAncXVhbGl0eScsIDgwKVxuICAgIGluZmxhdGUodGhpcywgJ3Byb2ZpbGUnLCAnYmFzZWxpbmUnKVxuICAgIGluZmxhdGUodGhpcywgJ2xldmVsJywgMy4xKVxuICB9XG5cbn1cblxuY2xhc3MgUlRDTWVkaWFDb25zdHJhaW50IHtcblxuICBjb25zdHJ1Y3RvciAoYXVkaW8gPSB0cnVlLCB2aWRlbyA9IHVuZGVmaW5lZCkge1xuICAgIGluZmxhdGUodGhpcywgJ2F1ZGlvJywgYXVkaW8pXG4gICAgaW5mbGF0ZSh0aGlzLCAndmlkZW8nLCB2aWRlbyB8fCBuZXcgUlRDTWVkaWFWaWRlb0NvbnN0cmFpbnQoKSlcbiAgfVxufVxuXG5jbGFzcyBSVE1QTWVkaWFDb25zdHJhaW50IHtcblxuICBjb25zdHJ1Y3RvciAoYXVkaW8gPSB0cnVlLCB2aWRlbyA9IHVuZGVmaW5lZCkge1xuICAgIGluZmxhdGUodGhpcywgJ2F1ZGlvJywgYXVkaW8pXG4gICAgaW5mbGF0ZSh0aGlzLCAndmlkZW8nLCB2aWRlbyB8fCBuZXcgUlRNUE1lZGlhVmlkZW9Db25zdHJhaW50KCkpXG4gIH1cbn1cblxuZXhwb3J0IHsgUlRDTWVkaWFDb25zdHJhaW50LCBSVE1QTWVkaWFDb25zdHJhaW50IH1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3B1Ymxpc2hlci9jb25zdHJhaW50L2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBFdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50J1xuXG5jbGFzcyBTbGlkZXJFdmVudCBleHRlbmRzIEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgY29udHJvbCwgZGF0YSkge1xuICAgIHN1cGVyKHR5cGUsIGRhdGEpXG4gICAgdGhpcy5fY29udHJvbCA9IGNvbnRyb2xcbiAgfVxuXG4gIGdldCBjb250cm9sICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbFxuICB9XG5cbn1cblxuY29uc3QgU2xpZGVyRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBDSEFOR0VfU1RBUlQ6ICdjaGFuZ2VzdGFydCcsXG4gIENIQU5HRTogJ2NoYW5nZScsXG4gIENIQU5HRV9DT01QTEVURTogJ2NoYW5nZWNvbXBsZXRlJ1xufSlcblxuZXhwb3J0IHsgU2xpZGVyRXZlbnQgYXMgU2xpZGVyRXZlbnQgfVxuZXhwb3J0IHsgU2xpZGVyRXZlbnRUeXBlcyBhcyBTbGlkZXJFdmVudFR5cGVzIH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9zdWJzY3JpYmVyL2NvbnRyb2xzL2V2ZW50LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4vcHJvbWlzZSdcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKVxuXG5jb25zdCBwdnQgPSAoY3R4KSA9PiB7XG4gIGlmICghbWFwLmhhcyhjdHgpKSB7XG4gICAgbWFwLnNldChjdHgsIHt9KVxuICB9XG5cbiAgcmV0dXJuIG1hcC5nZXQoY3R4KVxufVxuXG5leHBvcnQgY2xhc3MgSW1wbEZhY3RvcnlPcmRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubGlzdG9yZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAqIGxpc3RvcmRlciAobGlzdCkge1xuICAgICAgICB3aGlsZSAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgeWllbGQgbGlzdC5zaGlmdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCkpXG5cbiAgICBwdnQodGhpcykuZmluZCA9IChpdGVyYXRvciwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4gPSBudWxsLCBsYXN0RXJyb3IgPSBudWxsKSA9PiB7XG4gICAgICBjb25zdCBbdHlwZSwgSW1wbF0gPSBwdnQodGhpcykubmV4dChpdGVyYXRvciwgbWFwKVxuICAgICAgaWYgKCFJbXBsKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGxhc3RFcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwXG4gICAgICAgIGxldCBzcmMgPSBvcHRpb25zW3R5cGVdXG4gICAgICAgIHNyYyA9IHNyYyB8fCBvcHRpb25zXG4gICAgICAgIGlmIChpbml0Rm4pIHtcbiAgICAgICAgICBwID0gbmV3IEltcGwoKVtpbml0Rm5dKHNyYylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwID0gbmV3IEltcGwoc3JjKVxuICAgICAgICB9XG4gICAgICAgIHAudGhlbigoY29uY3JldGUpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUoY29uY3JldGUpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvclxuICAgICAgICAgIHB2dCh0aGlzKS5maW5kKGl0ZXJhdG9yLCBtYXAsIG9wdGlvbnMsIHByb21pc2UsIGluaXRGbiwgbGFzdEVycm9yKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHB2dCh0aGlzKS5uZXh0ID0gKG9yZGVyLCBtYXApID0+IHtcbiAgICAgIGxldCBJbXBsXG4gICAgICBsZXQga2V5XG4gICAgICBjb25zdCBuZXh0ID0gb3JkZXIubmV4dCgpXG4gICAgICBpZiAoIW5leHQuZG9uZSkge1xuICAgICAgICBrZXkgPSBuZXh0LnZhbHVlXG4gICAgICAgIEltcGwgPSBtYXAuZ2V0KGtleSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBba2V5LCBJbXBsXVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZSAob3JkZXIsIG1hcCwgb3B0aW9ucywgaW5pdEZuID0gbnVsbCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBwdnQodGhpcykuZmluZCh0aGlzLmxpc3RvcmRlcihvcmRlci5zbGljZSgpKSwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4pXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1wbEZhY3RvcnlPcmRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3V0aWwvaW1wbC1mYWN0b3J5LW9yZGVyLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIGh0dHA6Ly9ibG9nLmNhcmJvbmZpdmUuY29tLzIwMTUvMDEvMTQvZ2V0dGluLWZyZWFreS1mdW5jdGlvbmFsLXdjdXJyaWVkLWphdmFzY3JpcHQvXG5leHBvcnQgY29uc3QgY3VycnkgPSAoZngpID0+IHtcbiAgbGV0IGFyaXR5ID0gZngubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24gZjEoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IGFyaXR5KSB7XG4gICAgICByZXR1cm4gZnguYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYyKCkge1xuICAgICAgICBjb25zdCBhcmdzMiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHJldHVybiBmMS5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhcmdzMikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGZpbHRlciA9IGN1cnJ5KChmbiwgbGlzdCkgPT4ge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KVxuXG5leHBvcnQgY29uc3QgdG9JbnQgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUucGFyc2VJbnQoMTApXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldE9yRWxzZSA9ICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIHJldHVybiB2YWx1ZSB8fCBkZWZhdWx0VmFsdWVcbn1cblxuZXhwb3J0IGNvbnN0IGdldEludE9yRWxzZSA9ICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gIHJldHVybiAhaXNOYU4odG9JbnQodmFsdWUpKSA/IHRvSW50KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvdXRpbC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZGlmaWVzIHRhcmdldCBgb2JqZWN0YCBpbiBwbGFjZSB3aXRoIGEgbmFtZXNwYWNlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZXBEZWZpbmUgPSAob2JqZWN0LCBwYXRocywgdmFsdWUpID0+IHtcbiAgbGV0IGkgPSAwXG4gIGxldCB0YWlsID0gb2JqZWN0XG4gIGNvbnN0IHByb3AgPSBwYXRocy5wb3AoKVxuICBjb25zdCBsZW5ndGggPSBwYXRocy5sZW5ndGhcbiAgZm9yIChpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcGF0aCA9IHBhdGhzW2ldXG4gICAgdGFpbFtwYXRoXSA9IHRhaWxbcGF0aF0gfHwge31cbiAgICB0YWlsID0gdGFpbFtwYXRoXVxuICB9XG4gIHRhaWxbcHJvcF0gPSB2YWx1ZVxufVxuXG5leHBvcnQgY29uc3QgZGVlcENvcHkgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iailcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvdXRpbC9vYmplY3QuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGNvbnN0IHJ0Y1NvY2tldEVuZHBvaW50RnJvbU9wdGlvbnMgPSAob3B0aW9ucywgcGFyYW1zID0gdW5kZWZpbmVkKSA9PiB7XG4gIGNvbnN0IHByb3RvY29sID0gb3B0aW9ucy53c3Byb3RvY29sIHx8IG9wdGlvbnMucHJvdG9jb2xcbiAgY29uc3QgcG9ydCA9IG9wdGlvbnMud3Nwb3J0IHx8IG9wdGlvbnMucG9ydFxuICBjb25zdCBhcHBFbmRwb2ludCA9IG9wdGlvbnMuY29udGV4dCA/IFtvcHRpb25zLmFwcCwgb3B0aW9ucy5jb250ZXh0XS5qb2luKCcvJykgOiBvcHRpb25zLmFwcFxuICBsZXQgZW5kcG9pbnQgPSBgJHtwcm90b2NvbH06Ly8ke29wdGlvbnMuaG9zdH06JHtwb3J0fS8ke2FwcEVuZHBvaW50fWBcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihwYXJhbXMsIG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcylcbiAgfVxuICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQga3YgPSBbXVxuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBrdi5wdXNoKFtrZXksIHBhcmFtc1trZXldXS5qb2luKCc9JykpXG4gICAgfSlcbiAgICBpZiAoa3YubGVuZ3RoID4gMCkge1xuICAgICAgZW5kcG9pbnQgKz0gJz8nICsgKGt2LmpvaW4oJyYnKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW5kcG9pbnRcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3V0aWwvdXJsLWVuZHBvaW50LmpzIiwiLyoqXG4gKiAhVGhpcyBpcyBhIHN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiBCdW55YW4gdGFyZ2V0ZWQgc3BlY2lmaWNhbGx5IGZvciB0aGUgYnJvd3NlclxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVHJlbnQgTWljay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3llbnQgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoZSBidW55YW4gbG9nZ2luZyBsaWJyYXJ5IGZvciBub2RlLmpzLlxuICpcbiAqIC0qLSBtb2RlOiBqcyAtKi1cbiAqIHZpbTogZXhwYW5kdGFiOnRzPTQ6c3c9NFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZFUlNJT04gPSAnMC4yLjMnO1xuXG4vLyBCdW55YW4gbG9nIGZvcm1hdCB2ZXJzaW9uLiBUaGlzIGJlY29tZXMgdGhlICd2JyBmaWVsZCBvbiBhbGwgbG9nIHJlY29yZHMuXG4vLyBgMGAgaXMgdW50aWwgSSByZWxlYXNlIGEgdmVyc2lvbiAnMS4wLjAnIG9mIG5vZGUtYnVueWFuLiBUaGVyZWFmdGVyLFxuLy8gc3RhcnRpbmcgd2l0aCBgMWAsIHRoaXMgd2lsbCBiZSBpbmNyZW1lbnRlZCBpZiB0aGVyZSBpcyBhbnkgYmFja3dhcmRcbi8vIGluY29tcGF0aWJsZSBjaGFuZ2UgdG8gdGhlIGxvZyByZWNvcmQgZm9ybWF0LiBEZXRhaWxzIHdpbGwgYmUgaW5cbi8vICdDSEFOR0VTLm1kJyAodGhlIGNoYW5nZSBsb2cpLlxudmFyIExPR19WRVJTSU9OID0gMDtcblxuLy8tLS0tIEludGVybmFsIHN1cHBvcnQgc3R1ZmZcblxuLyoqXG4gKiBBIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3QuIEJ1bnlhbiBsb2dnaW5nIGF0dGVtcHRzIHRvIG5ldmVyIGNhdXNlXG4gKiBleGNlcHRpb25zLCBzbyB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIGhhbmRsZSBub24tb2JqZWN0cyBncmFjZWZ1bGx5LlxuICovXG5mdW5jdGlvbiBvYmpDb3B5KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHsgIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIChvYmopID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGNvcHlba10gPSBvYmpba107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn1cblxudmFyIGZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcblxuICAgIGlmKGYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5cbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT09ICclJScpIHtcbiAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICBjYXNlICclaic6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogR2F0aGVyIHNvbWUgY2FsbGVyIGluZm8gMyBzdGFjayBsZXZlbHMgdXAuXG4gKiBTZWUgPGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpPi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FsbGVyM0luZm8oKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBzYXZlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgdmFyIHNhdmVQcmVwYXJlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMztcbiAgICAvL0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGdldENhbGxlcjNJbmZvKTtcblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKF8sIHN0YWNrKSB7XG4gICAgICAgIHZhciBjYWxsZXIgPSBzdGFja1syXTtcbiAgICAgICAgb2JqLmZpbGUgPSBjYWxsZXIuZ2V0RmlsZU5hbWUoKTtcbiAgICAgICAgb2JqLmxpbmUgPSBjYWxsZXIuZ2V0TGluZU51bWJlcigpO1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxlci5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIG9iai5mdW5jID0gZnVuYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc2F2ZUxpbWl0O1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gc2F2ZVByZXBhcmU7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5mdW5jdGlvbiBfaW5kZW50KHMsIGluZGVudCkge1xuICAgIGlmICghaW5kZW50KSB7XG4gICAgICAgIGluZGVudCA9ICcgICAgJztcbiAgICB9XG4gICAgdmFyIGxpbmVzID0gcy5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICByZXR1cm4gaW5kZW50ICsgbGluZXMuam9pbignXFxuJyArIGluZGVudCk7XG59XG5cblxuLyoqXG4gKiBXYXJuIGFib3V0IGFuIGJ1bnlhbiBwcm9jZXNzaW5nIGVycm9yLlxuICpcbiAqIEBwYXJhbSBtc2cge1N0cmluZ30gTWVzc2FnZSB3aXRoIHdoaWNoIHRvIHdhcm4uXG4gKiBAcGFyYW0gZGVkdXBLZXkge1N0cmluZ30gT3B0aW9uYWwuIEEgc2hvcnQgc3RyaW5nIGtleSBmb3IgdGhpcyB3YXJuaW5nIHRvXG4gKiAgICAgIGhhdmUgaXRzIHdhcm5pbmcgb25seSBwcmludGVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIF93YXJuKG1zZywgZGVkdXBLZXkpIHtcbiAgICBpZiAoZGVkdXBLZXkpIHtcbiAgICAgICAgaWYgKF93YXJuZWRbZGVkdXBLZXldKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3dhcm5lZFtkZWR1cEtleV0gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4nKTtcbn1cbmZ1bmN0aW9uIF9oYXZlV2FybmVkKGRlZHVwS2V5KSB7XG4gICAgcmV0dXJuIF93YXJuZWRbZGVkdXBLZXldO1xufVxudmFyIF93YXJuZWQgPSB7fTtcblxuXG5mdW5jdGlvbiBDb25zb2xlUmF3U3RyZWFtKCkge1xufVxuQ29uc29sZVJhd1N0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocmVjKSB7XG4gICAgaWYgKHJlYy5sZXZlbCA8IElORk8pIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVjKTtcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKHJlYyk7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBFUlJPUikge1xuICAgICAgICBjb25zb2xlLndhcm4ocmVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKHJlYyk7XG4gICAgfVxuXG4gICAgaWYocmVjLmVyciAmJiByZWMuZXJyLnN0YWNrKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocmVjLmVyci5zdGFjayk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQ29uc29sZUZvcm1hdHRlZFN0cmVhbSgpIHt9XG5Db25zb2xlRm9ybWF0dGVkU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChyZWMpIHtcblxuICAgIHZhciBsZXZlbENzcywgZGVmYXVsdENzcyA9ICdjb2xvcjogRGltR3JheScsIG1zZ0NzcyA9ICdjb2xvcjogU3RlZWxCbHVlJztcblxuICAgIGlmIChyZWMubGV2ZWwgPCBERUJVRykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogRGVlcFBpbmsnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgSU5GTykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogR29sZGVuUm9kJztcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IERhcmtUdXJxdW9pc2UnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgRVJST1IpIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IFB1cnBsZSc7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBGQVRBTCkge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogQ3JpbXNvbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IEJsYWNrJztcbiAgICB9XG5cbiAgICB2YXIgbG9nZ2VyTmFtZSA9IHJlYy5jaGlsZE5hbWUgPyByZWMubmFtZSArICcvJyArIHJlYy5jaGlsZE5hbWUgOiByZWMubmFtZTtcblxuICAgIC8vZ2V0IGxldmVsIG5hbWUgYW5kIHBhZCBzdGFydCB3aXRoIHNwYWNzXG4gICAgdmFyIGxldmVsTmFtZSA9IG5hbWVGcm9tTGV2ZWxbcmVjLmxldmVsXS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldmVsTmFtZSA9IEFycmF5KDYgLSBsZXZlbE5hbWUubGVuZ3RoKS5qb2luKCcgJykgKyBsZXZlbE5hbWU7XG5cbiAgICBmdW5jdGlvbiBwYWRaZXJvcyhudW1iZXIsIGxlbikge1xuICAgICAgICByZXR1cm4gQXJyYXkoKGxlbiArIDEpIC0gKG51bWJlciArICcnKS5sZW5ndGgpLmpvaW4oJzAnKSArIG51bWJlcjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnWyVzOiVzOiVzOiVzXSAlYyVzJWM6ICVzOiAlYyVzJyxcbiAgICAgICAgcGFkWmVyb3MocmVjLnRpbWUuZ2V0SG91cnMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbnV0ZXMoKSwgMiksXG4gICAgICAgIHBhZFplcm9zKHJlYy50aW1lLmdldFNlY29uZHMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbGxpc2Vjb25kcygpLCA0KSxcbiAgICAgICAgbGV2ZWxDc3MsIGxldmVsTmFtZSxcbiAgICAgICAgZGVmYXVsdENzcywgbG9nZ2VyTmFtZSxcbiAgICAgICAgbXNnQ3NzLCByZWMubXNnKTtcbiAgICBpZihyZWMuZXJyICYmIHJlYy5lcnIuc3RhY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coJyVjJXMsJywgbGV2ZWxDc3MsIHJlYy5lcnIuc3RhY2spO1xuICAgIH1cbn07XG5cbi8vLS0tLSBMZXZlbHNcblxudmFyIFRSQUNFID0gMTA7XG52YXIgREVCVUcgPSAyMDtcbnZhciBJTkZPID0gMzA7XG52YXIgV0FSTiA9IDQwO1xudmFyIEVSUk9SID0gNTA7XG52YXIgRkFUQUwgPSA2MDtcblxudmFyIGxldmVsRnJvbU5hbWUgPSB7XG4gICAgJ3RyYWNlJzogVFJBQ0UsXG4gICAgJ2RlYnVnJzogREVCVUcsXG4gICAgJ2luZm8nOiBJTkZPLFxuICAgICd3YXJuJzogV0FSTixcbiAgICAnZXJyb3InOiBFUlJPUixcbiAgICAnZmF0YWwnOiBGQVRBTFxufTtcbnZhciBuYW1lRnJvbUxldmVsID0ge307XG5PYmplY3Qua2V5cyhsZXZlbEZyb21OYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgbmFtZUZyb21MZXZlbFtsZXZlbEZyb21OYW1lW25hbWVdXSA9IG5hbWU7XG59KTtcblxuXG4vKipcbiAqIFJlc29sdmUgYSBsZXZlbCBudW1iZXIsIG5hbWUgKHVwcGVyIG9yIGxvd2VyY2FzZSkgdG8gYSBsZXZlbCBudW1iZXIgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUxldmVsKG5hbWVPck51bSkge1xuICAgIHZhciBsZXZlbCA9ICh0eXBlb2YgKG5hbWVPck51bSkgPT09ICdzdHJpbmcnID8gbGV2ZWxGcm9tTmFtZVtuYW1lT3JOdW0udG9Mb3dlckNhc2UoKV0gOiBuYW1lT3JOdW0pO1xuICAgIHJldHVybiBsZXZlbDtcbn1cblxuXG4vLy0tLS0gTG9nZ2VyIGNsYXNzXG5cbi8qKlxuICogQ3JlYXRlIGEgTG9nZ2VyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFNlZSBkb2N1bWVudGF0aW9uIGZvciBmdWxsIGRldGFpbHMuIEF0IG1pbmltdW1cbiAqICAgIHRoaXMgbXVzdCBpbmNsdWRlIGEgJ25hbWUnIHN0cmluZyBrZXkuIENvbmZpZ3VyYXRpb24ga2V5czpcbiAqICAgICAgLSBgc3RyZWFtc2A6IHNwZWNpZnkgdGhlIGxvZ2dlciBvdXRwdXQgc3RyZWFtcy4gVGhpcyBpcyBhbiBhcnJheSBvZlxuICogICAgICAgIG9iamVjdHMgd2l0aCB0aGVzZSBmaWVsZHM6XG4gKiAgICAgICAgICAtIGB0eXBlYDogVGhlIHN0cmVhbSB0eXBlLiBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgICAgICAgIE9mdGVuIHRoaXMgaXMgaW1wbGllZCBieSB0aGUgb3RoZXIgZmllbGRzLiBFeGFtcGxlcyBhcmVcbiAqICAgICAgICAgICAgJ2ZpbGUnLCAnc3RyZWFtJyBhbmQgXCJyYXdcIi5cbiAqICAgICAgICAgIC0gYGxldmVsYDogRGVmYXVsdHMgdG8gJ2luZm8nLlxuICogICAgICAgICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgICAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICAgICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAgICAgICAtIGBjbG9zZU9uRXhpdGAgKGJvb2xlYW4pOiBPcHRpb25hbC4gRGVmYXVsdCBpcyB0cnVlIGZvciBhXG4gKiAgICAgICAgICAgICdmaWxlJyBzdHJlYW0gd2hlbiBgcGF0aGAgaXMgZ2l2ZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqICAgICAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgIC0gYGxldmVsYDogc2V0IHRoZSBsZXZlbCBmb3IgYSBzaW5nbGUgb3V0cHV0IHN0cmVhbSAoY2Fubm90IGJlIHVzZWRcbiAqICAgICAgICB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc3RyZWFtYDogdGhlIG91dHB1dCBzdHJlYW0gZm9yIGEgbG9nZ2VyIHdpdGgganVzdCBvbmUsIGUuZy5cbiAqICAgICAgICBgcHJvY2Vzcy5zdGRvdXRgIChjYW5ub3QgYmUgdXNlZCB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc2VyaWFsaXplcnNgOiBvYmplY3QgbWFwcGluZyBsb2cgcmVjb3JkIGZpZWxkIG5hbWVzIHRvXG4gKiAgICAgICAgc2VyaWFsaXppbmcgZnVuY3Rpb25zLiBTZWUgUkVBRE1FLm1kIGZvciBkZXRhaWxzLlxuICogICAgICAtIGBzcmNgOiBCb29sZWFuIChkZWZhdWx0IGZhbHNlKS4gU2V0IHRydWUgdG8gZW5hYmxlICdzcmMnIGF1dG9tYXRpY1xuICogICAgICAgIGZpZWxkIHdpdGggbG9nIGNhbGwgc291cmNlIGluZm8uXG4gKiAgICBBbGwgb3RoZXIga2V5cyBhcmUgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogQW4gYWx0ZXJuYXRpdmUgKmludGVybmFsKiBjYWxsIHNpZ25hdHVyZSBpcyB1c2VkIGZvciBjcmVhdGluZyBhIGNoaWxkOlxuICogICAgbmV3IExvZ2dlcig8cGFyZW50IGxvZ2dlcj4sIDxjaGlsZCBvcHRpb25zPlssIDxjaGlsZCBvcHRzIGFyZSBzaW1wbGU+XSk7XG4gKlxuICogQHBhcmFtIF9jaGlsZFNpbXBsZSAoQm9vbGVhbikgQW4gYXNzZXJ0aW9uIHRoYXQgdGhlIGdpdmVuIGBfY2hpbGRPcHRpb25zYFxuICogICAgKGEpIG9ubHkgYWRkIGZpZWxkcyAobm8gY29uZmlnKSBhbmQgKGIpIG5vIHNlcmlhbGl6YXRpb24gaGFuZGxpbmcgaXNcbiAqICAgIHJlcXVpcmVkIGZvciB0aGVtLiBJT1csIHRoaXMgaXMgYSBmYXN0IHBhdGggZm9yIGZyZXF1ZW50IGNoaWxkXG4gKiAgICBjcmVhdGlvbi5cbiAqL1xuZnVuY3Rpb24gTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMsIF9jaGlsZFNpbXBsZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMb2dnZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIElucHV0IGFyZyB2YWxpZGF0aW9uLlxuICAgIHZhciBwYXJlbnQ7XG4gICAgaWYgKF9jaGlsZE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJlbnQgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gX2NoaWxkT3B0aW9ucztcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgTG9nZ2VyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBMb2dnZXIgY3JlYXRpb246IGRvIG5vdCBwYXNzIGEgc2Vjb25kIGFyZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIChvYmplY3QpIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5hbWUgKHN0cmluZykgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgb3B0aW9ucy5uYW1lOiBjaGlsZCBjYW5ub3Qgc2V0IGxvZ2dlciBuYW1lJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtICYmIG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgbWl4IFwic3RyZWFtc1wiIGFuZCBcInN0cmVhbVwiIG9wdGlvbnMnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtcyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnN0cmVhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucy5zdHJlYW1zOiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlcmlhbGl6ZXJzICYmICh0eXBlb2YgKG9wdGlvbnMuc2VyaWFsaXplcnMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2VyaWFsaXplcnMpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMuc2VyaWFsaXplcnM6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGZpZWxkcywgbmFtZSwgaTtcblxuICAgIC8vIEZhc3QgcGF0aCBmb3Igc2ltcGxlIGNoaWxkIGNyZWF0aW9uLlxuICAgIGlmIChwYXJlbnQgJiYgX2NoaWxkU2ltcGxlKSB7XG4gICAgICAgIC8vIGBfaXNTaW1wbGVDaGlsZGAgaXMgYSBzaWduYWwgdG8gc3RyZWFtIGNsb3NlIGhhbmRsaW5nIHRoYXQgdGhpcyBjaGlsZFxuICAgICAgICAvLyBvd25zIG5vbmUgb2YgaXRzIHN0cmVhbXMuXG4gICAgICAgIHRoaXMuX2lzU2ltcGxlQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2xldmVsID0gcGFyZW50Ll9sZXZlbDtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gcGFyZW50LnN0cmVhbXM7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplcnMgPSBwYXJlbnQuc2VyaWFsaXplcnM7XG4gICAgICAgIHRoaXMuc3JjID0gcGFyZW50LnNyYztcbiAgICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgICAgdmFyIHBhcmVudEZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyhwYXJlbnQuZmllbGRzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudEZpZWxkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJlbnRGaWVsZE5hbWVzW2ldO1xuICAgICAgICAgICAgZmllbGRzW25hbWVdID0gcGFyZW50LmZpZWxkc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOdWxsIHZhbHVlcy5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9sZXZlbCA9IHBhcmVudC5fbGV2ZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50LnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gb2JqQ29weShwYXJlbnQuc3RyZWFtc1tpXSk7XG4gICAgICAgICAgICBzLmNsb3NlT25FeGl0ID0gZmFsc2U7IC8vIERvbid0IG93biBwYXJlbnQgc3RyZWFtLlxuICAgICAgICAgICAgdGhpcy5zdHJlYW1zLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJpYWxpemVycyA9IG9iakNvcHkocGFyZW50LnNlcmlhbGl6ZXJzKTtcbiAgICAgICAgdGhpcy5zcmMgPSBwYXJlbnQuc3JjO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IG9iakNvcHkocGFyZW50LmZpZWxkcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsKG9wdGlvbnMubGV2ZWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgKmNvbmZpZyogb3B0aW9ucyAoaS5lLiBvcHRpb25zIHRoYXQgYXJlIG5vdCBqdXN0IHBsYWluIGRhdGFcbiAgICAvLyBmb3IgbG9nIHJlY29yZHMpLlxuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgICBzZWxmLmFkZFN0cmVhbSh7XG4gICAgICAgICAgICB0eXBlOiAnc3RyZWFtJyxcbiAgICAgICAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW0sXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICBvcHRpb25zLnN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgc2VsZi5hZGRTdHJlYW0ocywgb3B0aW9ucy5sZXZlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyZW50ICYmIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgdGhpcy5sZXZlbChvcHRpb25zLmxldmVsKTtcbiAgICB9IGVsc2UgaWYgKCFwYXJlbnQpIHtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aGUgYnJvd3NlciB3ZSdsbCBiZSBlbWl0dGluZyB0byBjb25zb2xlLmxvZyBieSBkZWZhdWx0LlxuICAgICAgICAgKiBBbnkgY29uc29sZS5sb2cgd29ydGggaXRzIHNhbHQgdGhlc2UgZGF5cyBjYW4gbmljZWx5IHJlbmRlclxuICAgICAgICAgKiBhbmQgaW50cm9zcGVjdCBvYmplY3RzIChlLmcuIHRoZSBGaXJlZm94IGFuZCBDaHJvbWUgY29uc29sZSlcbiAgICAgICAgICogc28gbGV0J3MgZW1pdCB0aGUgcmF3IGxvZyByZWNvcmQuIEFyZSB0aGVyZSBicm93c2VycyBmb3Igd2hpY2hcbiAgICAgICAgICogdGhhdCBicmVha3MgdGhpbmdzP1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5hZGRTdHJlYW0oe1xuICAgICAgICAgICAgdHlwZTogJ3JhdycsXG4gICAgICAgICAgICBzdHJlYW06IG5ldyBDb25zb2xlUmF3U3RyZWFtKCksXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXJpYWxpemVycykge1xuICAgICAgICBzZWxmLmFkZFNlcmlhbGl6ZXJzKG9wdGlvbnMuc2VyaWFsaXplcnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZpZWxkcy5cbiAgICAvLyBUaGVzZSBhcmUgdGhlIGRlZmF1bHQgZmllbGRzIGZvciBsb2cgcmVjb3JkcyAobWludXMgdGhlIGF0dHJpYnV0ZXNcbiAgICAvLyByZW1vdmVkIGluIHRoaXMgY29uc3RydWN0b3IpLiBUbyBhbGxvdyBzdG9yaW5nIHJhdyBsb2cgcmVjb3Jkc1xuICAgIC8vICh1bnJlbmRlcmVkKSwgYHRoaXMuZmllbGRzYCBtdXN0IG5ldmVyIGJlIG11dGF0ZWQuIENyZWF0ZSBhIGNvcHkgZm9yXG4gICAgLy8gYW55IGNoYW5nZXMuXG4gICAgZmllbGRzID0gb2JqQ29weShvcHRpb25zKTtcbiAgICBkZWxldGUgZmllbGRzLnN0cmVhbTtcbiAgICBkZWxldGUgZmllbGRzLmxldmVsO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3RyZWFtcztcbiAgICBkZWxldGUgZmllbGRzLnNlcmlhbGl6ZXJzO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3JjO1xuICAgIGlmICh0aGlzLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5U2VyaWFsaXplcnMoZmllbGRzKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHNlbGYuZmllbGRzW2tdID0gZmllbGRzW2tdO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFkZCBhIHN0cmVhbVxuICpcbiAqIEBwYXJhbSBzdHJlYW0ge09iamVjdH0uIE9iamVjdCB3aXRoIHRoZXNlIGZpZWxkczpcbiAqICAgIC0gYHR5cGVgOiBUaGUgc3RyZWFtIHR5cGUuIFNlZSBSRUFETUUubWQgZm9yIGZ1bGwgZGV0YWlscy5cbiAqICAgICAgT2Z0ZW4gdGhpcyBpcyBpbXBsaWVkIGJ5IHRoZSBvdGhlciBmaWVsZHMuIEV4YW1wbGVzIGFyZVxuICogICAgICAnZmlsZScsICdzdHJlYW0nIGFuZCBcInJhd1wiLlxuICogICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAtIGBsZXZlbGA6IE9wdGlvbmFsLiBGYWxscyBiYWNrIHRvIGBkZWZhdWx0TGV2ZWxgLlxuICogICAgLSBgY2xvc2VPbkV4aXRgIChib29sZWFuKTogT3B0aW9uYWwuIERlZmF1bHQgaXMgdHJ1ZSBmb3IgYVxuICogICAgICAnZmlsZScgc3RyZWFtIHdoZW4gYHBhdGhgIGlzIGdpdmVuLCBmYWxzZSBvdGhlcndpc2UuXG4gKiAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiBAcGFyYW0gZGVmYXVsdExldmVsIHtOdW1iZXJ8U3RyaW5nfSBPcHRpb25hbC4gQSBsZXZlbCB0byB1c2UgaWZcbiAqICAgICAgYHN0cmVhbS5sZXZlbGAgaXMgbm90IHNldC4gSWYgbmVpdGhlciBpcyBnaXZlbiwgdGhpcyBkZWZhdWx0cyB0byBJTkZPLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzLCBkZWZhdWx0TGV2ZWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGRlZmF1bHRMZXZlbCA9PT0gbnVsbCB8fCBkZWZhdWx0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0TGV2ZWwgPSBJTkZPO1xuICAgIH1cblxuICAgIHMgPSBvYmpDb3B5KHMpO1xuXG4gICAgLy8gSW1wbGljaXQgJ3R5cGUnIGZyb20gb3RoZXIgYXJncy5cbiAgICBpZiAoIXMudHlwZSAmJiBzLnN0cmVhbSkge1xuICAgICAgICBzLnR5cGUgPSAncmF3JztcbiAgICB9XG4gICAgcy5yYXcgPSAocy50eXBlID09PSAncmF3Jyk7ICAvLyBQRVJGOiBBbGxvdyBmb3IgZmFzdGVyIGNoZWNrIGluIGBfZW1pdGAuXG5cbiAgICBpZiAocy5sZXZlbCkge1xuICAgICAgICBzLmxldmVsID0gcmVzb2x2ZUxldmVsKHMubGV2ZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMubGV2ZWwgPSByZXNvbHZlTGV2ZWwoZGVmYXVsdExldmVsKTtcbiAgICB9XG4gICAgaWYgKHMubGV2ZWwgPCBzZWxmLl9sZXZlbCkge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IHMubGV2ZWw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgIGlmICghcy5jbG9zZU9uRXhpdCkge1xuICAgICAgICAgICAgICAgIHMuY2xvc2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgaWYgKCFzLmNsb3NlT25FeGl0KSB7XG4gICAgICAgICAgICAgICAgcy5jbG9zZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIHN0cmVhbSB0eXBlIFwiJyArIHMudHlwZSArICdcIicpO1xuICAgIH1cblxuICAgIHNlbGYuc3RyZWFtcy5wdXNoKHMpO1xuICAgIGRlbGV0ZSBzZWxmLmhhdmVOb25SYXdTdHJlYW1zOyAgLy8gcmVzZXRcbn07XG5cblxuLyoqXG4gKiBBZGQgc2VyaWFsaXplcnNcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplcnMge09iamVjdH0gT3B0aW9uYWwuIE9iamVjdCBtYXBwaW5nIGxvZyByZWNvcmQgZmllbGQgbmFtZXNcbiAqICAgIHRvIHNlcmlhbGl6aW5nIGZ1bmN0aW9ucy4gU2VlIFJFQURNRS5tZCBmb3IgZGV0YWlscy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5hZGRTZXJpYWxpemVycyA9IGZ1bmN0aW9uIGFkZFNlcmlhbGl6ZXJzKHNlcmlhbGl6ZXJzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHNlbGYuc2VyaWFsaXplcnMgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc2VyaWFsaXplcnMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyID0gc2VyaWFsaXplcnNbZmllbGRdO1xuICAgICAgICBpZiAodHlwZW9mIChzZXJpYWxpemVyKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXQoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgc2VyaWFsaXplciBmb3IgXCIlc1wiIGZpZWxkOiBtdXN0IGJlIGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZpZWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNlcmlhbGl6ZXJzW2ZpZWxkXSA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBsb2dnZXIsIHR5cGljYWxseSB0byBhZGQgYSBmZXcgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gcGFzc2luZyBhIGxvZ2dlciB0byBhIHN1Yi1jb21wb25lbnQsIGUuZy4gYVxuICogJ3d1enpsZScgY29tcG9uZW50IG9mIHlvdXIgc2VydmljZTpcbiAqXG4gKiAgICB2YXIgd3V6emxlTG9nID0gbG9nLmNoaWxkKHtjb21wb25lbnQ6ICd3dXp6bGUnfSlcbiAqICAgIHZhciB3dXp6bGUgPSBuZXcgV3V6emxlKHsuLi4sIGxvZzogd3V6emxlTG9nfSlcbiAqXG4gKiBUaGVuIGxvZyByZWNvcmRzIGZyb20gdGhlIHd1enpsZSBjb2RlIHdpbGwgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXNcbiAqIHRoZSBhcHAgbG9nLCAqcGx1cyB0aGUgY29tcG9uZW50PSd3dXp6bGUnIGZpZWxkKi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25hbC4gU2V0IG9mIG9wdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGNoaWxkLlxuICogICAgQWxsIG9mIHRoZSBzYW1lIG9wdGlvbnMgZm9yIGEgbmV3IExvZ2dlciBhcHBseSBoZXJlLiBOb3RlczpcbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc3RyZWFtcyBhcmUgaW5oZXJpdGVkIGFuZCBjYW5ub3QgYmUgcmVtb3ZlZCBpbiB0aGlzXG4gKiAgICAgICAgY2FsbC4gQW55IGdpdmVuIGBzdHJlYW1zYCBhcmUgKmFkZGVkKiB0byB0aGUgc2V0IGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC5cbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc2VyaWFsaXplcnMgYXJlIGluaGVyaXRlZCwgdGhvdWdoIGNhbiBlZmZlY3RpdmVseSBiZVxuICogICAgICAgIG92ZXJ3cml0dGVuIGJ5IHVzaW5nIGR1cGxpY2F0ZSBrZXlzLlxuICogICAgICAtIENhbiB1c2UgYGxldmVsYCB0byBzZXQgdGhlIGxldmVsIG9mIHRoZSBzdHJlYW1zIGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC4gVGhlIGxldmVsIGZvciB0aGUgcGFyZW50IGlzIE5PVCBhZmZlY3RlZC5cbiAqIEBwYXJhbSBzaW1wbGUge0Jvb2xlYW59IE9wdGlvbmFsLiBTZXQgdG8gdHJ1ZSB0byBhc3NlcnQgdGhhdCBgb3B0aW9uc2BcbiAqICAgIChhKSBvbmx5IGFkZCBmaWVsZHMgKG5vIGNvbmZpZykgYW5kIChiKSBubyBzZXJpYWxpemF0aW9uIGhhbmRsaW5nIGlzXG4gKiAgICByZXF1aXJlZCBmb3IgdGhlbS4gSU9XLCB0aGlzIGlzIGEgZmFzdCBwYXRoIGZvciBmcmVxdWVudCBjaGlsZFxuICogICAgY3JlYXRpb24uIFNlZSAndG9vbHMvdGltZWNoaWxkLmpzJyBmb3IgbnVtYmVycy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzaW1wbGUpIHtcbiAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLCBvcHRpb25zIHx8IHt9LCBzaW1wbGUpO1xufTtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhbGwgc3RyZWFtcyBvbiB0aGlzIGxvZ2dlci5cbiAqXG4gKiBHZXQgVXNhZ2U6XG4gKiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGxvZyBsZXZlbCAobG93ZXN0IGxldmVsIG9mIGFsbCBpdHMgc3RyZWFtcykuXG4gKiAgICBsb2cubGV2ZWwoKSAtPiBJTkZPXG4gKlxuICogU2V0IFVzYWdlOlxuICogICAgbG9nLmxldmVsKElORk8pICAgICAgIC8vIHNldCBhbGwgc3RyZWFtcyB0byBsZXZlbCBJTkZPXG4gKiAgICBsb2cubGV2ZWwoJ2luZm8nKSAgICAgLy8gY2FuIHVzZSAnaW5mbycgZXQgYWwgYWxpYXNlc1xuICovXG5Mb2dnZXIucHJvdG90eXBlLmxldmVsID0gZnVuY3Rpb24gbGV2ZWwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgfVxuICAgIHZhciBuZXdMZXZlbCA9IHJlc29sdmVMZXZlbCh2YWx1ZSk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnN0cmVhbXNbaV0ubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbn07XG5cblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhIHBhcnRpY3VsYXIgc3RyZWFtIG9uIHRoaXMgbG9nZ2VyLlxuICpcbiAqIEdldCBVc2FnZTpcbiAqICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGxldmVscyBvZiBlYWNoIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoKSAtPiBbVFJBQ0UsIElORk9dXG4gKlxuICogICAgLy8gUmV0dXJucyBhIGxldmVsIG9mIHRoZSBpZGVudGlmaWVkIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoMCkgLT4gVFJBQ0UgICAgICAvLyBsZXZlbCBvZiBzdHJlYW0gYXQgaW5kZXggMFxuICogICAgbG9nLmxldmVscygnZm9vJykgICAgICAgICAgIC8vIGxldmVsIG9mIHN0cmVhbSB3aXRoIG5hbWUgJ2ZvbydcbiAqXG4gKiBTZXQgVXNhZ2U6XG4gKiAgICBsb2cubGV2ZWxzKDAsIElORk8pICAgICAgICAgLy8gc2V0IGxldmVsIG9mIHN0cmVhbSAwIHRvIElORk9cbiAqICAgIGxvZy5sZXZlbHMoMCwgJ2luZm8nKSAgICAgICAvLyBjYW4gdXNlICdpbmZvJyBldCBhbCBhbGlhc2VzXG4gKiAgICBsb2cubGV2ZWxzKCdmb28nLCBXQVJOKSAgICAgLy8gc2V0IHN0cmVhbSBuYW1lZCAnZm9vJyB0byBXQVJOXG4gKlxuICogU3RyZWFtIG5hbWVzOiBXaGVuIHN0cmVhbXMgYXJlIGRlZmluZWQsIHRoZXkgY2FuIG9wdGlvbmFsbHkgYmUgZ2l2ZW5cbiAqIGEgbmFtZS4gRm9yIGV4YW1wbGUsXG4gKiAgICAgICBsb2cgPSBuZXcgTG9nZ2VyKHtcbiAqICAgICAgICAgc3RyZWFtczogW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICogICAgICAgICAgICAgcGF0aDogJy92YXIvbG9nL215LXNlcnZpY2UvZm9vLmxvZydcbiAqICAgICAgICAgICAgIGxldmVsOiAndHJhY2UnXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgLi4uXG4gKlxuICogQHBhcmFtIG5hbWUge1N0cmluZ3xOdW1iZXJ9IFRoZSBzdHJlYW0gaW5kZXggb3IgbmFtZS5cbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfFN0cmluZ30gVGhlIGxldmVsIHZhbHVlIChJTkZPKSBvciBhbGlhcyAoJ2luZm8nKS5cbiAqICAgIElmIG5vdCBnaXZlbiwgdGhpcyBpcyBhICdnZXQnIG9wZXJhdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdHJlYW0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5sZXZlbHMgPSBmdW5jdGlvbiBsZXZlbHMobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbXMubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5sZXZlbDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtO1xuICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0gPSB0aGlzLnN0cmVhbXNbbmFtZV07XG4gICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0cmVhbSBpbmRleDogJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICAgICAgaWYgKHMubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ25vIHN0cmVhbSB3aXRoIG5hbWUgXCIlc1wiJywgbmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld0xldmVsID0gcmVzb2x2ZUxldmVsKHZhbHVlKTtcbiAgICAgICAgc3RyZWFtLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIGlmIChuZXdMZXZlbCA8IHRoaXMuX2xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEFwcGx5IHJlZ2lzdGVyZWQgc2VyaWFsaXplcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGtleXMgaW4gdGhlIGdpdmVuIGZpZWxkcy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uOiBUaGlzIGlzIG9ubHkgY2FsbGVkIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzZXJpYWxpemVyLlxuICpcbiAqIEBwYXJhbSBmaWVsZHMgKE9iamVjdCkgVGhlIGxvZyByZWNvcmQgZmllbGRzLlxuICogQHBhcmFtIGV4Y2x1ZGVGaWVsZHMgKE9iamVjdCkgT3B0aW9uYWwgbWFwcGluZyBvZiBrZXlzIHRvIGB0cnVlYCBmb3JcbiAqICAgIGtleXMgdG8gTk9UIGFwcGx5IGEgc2VyaWFsaXplci5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5fYXBwbHlTZXJpYWxpemVycyA9IGZ1bmN0aW9uIChmaWVsZHMsIGV4Y2x1ZGVGaWVsZHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBlYWNoIHNlcmlhbGl6ZXIgYWdhaW5zdCB0aGVzZSAocHJlc3VtaW5nIG51bWJlciBvZiBzZXJpYWxpemVyc1xuICAgIC8vIGlzIHR5cGljYWxseSBsZXNzIHRoYW4gbnVtYmVyIG9mIGZpZWxkcykuXG4gICAgT2JqZWN0LmtleXModGhpcy5zZXJpYWxpemVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoZmllbGRzW25hbWVdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChleGNsdWRlRmllbGRzICYmIGV4Y2x1ZGVGaWVsZHNbbmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IHNlbGYuc2VyaWFsaXplcnNbbmFtZV0oZmllbGRzW25hbWVdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfd2Fybihmb3JtYXQoJ2J1bnlhbjogRVJST1I6IEV4Y2VwdGlvbiB0aHJvd24gZnJvbSB0aGUgXCIlc1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnQnVueWFuIHNlcmlhbGl6ZXIuIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gVGhpcyBpcyBhIGJ1ZycgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gdGhhdCBzZXJpYWxpemVyIGZ1bmN0aW9uLlxcbiVzJyxcbiAgICAgICAgICAgICAgICBuYW1lLCBlcnIuc3RhY2sgfHwgZXJyKSk7XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBmb3JtYXQoJyhFcnJvciBpbiBCdW55YW4gbG9nIFwiJXNcIiBzZXJpYWxpemVyIGJyb2tlIGZpZWxkLiBTZWUgc3RkZXJyIGZvciBkZXRhaWxzLiknLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEVtaXQgYSBsb2cgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSByZWMge2xvZyByZWNvcmR9XG4gKiBAcGFyYW0gbm9lbWl0IHtCb29sZWFufSBPcHRpb25hbC4gU2V0IHRvIHRydWUgdG8gc2tpcCBlbWlzc2lvblxuICogICAgICBhbmQganVzdCByZXR1cm4gdGhlIEpTT04gc3RyaW5nLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24gKHJlYywgbm9lbWl0KSB7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBMYXppbHkgZGV0ZXJtaW5lIGlmIHRoaXMgTG9nZ2VyIGhhcyBub24tJ3Jhdycgc3RyZWFtcy4gSWYgdGhlcmUgYXJlXG4gICAgLy8gYW55LCB0aGVuIHdlIG5lZWQgdG8gc3RyaW5naWZ5IHRoZSBsb2cgcmVjb3JkLlxuICAgIGlmICh0aGlzLmhhdmVOb25SYXdTdHJlYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtc1tpXS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhdmVOb25SYXdTdHJlYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0cmluZ2lmeSB0aGUgb2JqZWN0LiBBdHRlbXB0IHRvIHdhcm4vcmVjb3ZlciBvbiBlcnJvci5cbiAgICB2YXIgc3RyO1xuICAgIGlmIChub2VtaXQgfHwgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkocmVjLCBzYWZlQ3ljbGVzKCkpICsgJ1xcbic7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWR1cEtleSA9IGUuc3RhY2suc3BsaXQoL1xcbi9nLCAyKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIF93YXJuKCdidW55YW46IEVSUk9SOiBFeGNlcHRpb24gaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdgSlNPTi5zdHJpbmdpZnkocmVjKWAuIFlvdSBjYW4gaW5zdGFsbCB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdcInNhZmUtanNvbi1zdHJpbmdpZnlcIiBtb2R1bGUgdG8gaGF2ZSBCdW55YW4gZmFsbGJhY2sgJyArXG4gICAgICAgICAgICAgICAgICAgICd0byBzYWZlciBzdHJpbmdpZmljYXRpb24uIFJlY29yZDpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgX2luZGVudChmb3JtYXQoJyVzXFxuJXMnLCByZWMsIGUuc3RhY2spKSxcbiAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQoJyhFeGNlcHRpb24gaW4gSlNPTi5zdHJpbmdpZnkocmVjKTogJWouIFNlZSBzdGRlcnIgZm9yIGRldGFpbHMuKVxcbicsIGUubWVzc2FnZSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2VtaXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cblxuICAgIHZhciBsZXZlbCA9IHJlYy5sZXZlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICBpZiAocy5sZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICAgICAgcy5zdHJlYW0ud3JpdGUocy5yYXcgPyByZWMgOiBzdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblxuLyoqXG4gKiBCdWlsZCBhIGxvZyBlbWl0dGVyIGZ1bmN0aW9uIGZvciBsZXZlbCBtaW5MZXZlbC4gSS5lLiB0aGlzIGlzIHRoZVxuICogY3JlYXRvciBvZiBgbG9nLmluZm9gLCBgbG9nLmVycm9yYCwgZXRjLlxuICovXG5mdW5jdGlvbiBta0xvZ0VtaXR0ZXIobWluTGV2ZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBta1JlY29yZChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZXhjbHVkZUZpZWxkcztcbiAgICAgICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBgbG9nLjxsZXZlbD4oZXJyLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgTG9nZ2VyJ3MgZXJyIHNlcmlhbGl6ZXIsIGlmIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIGVycjogKGxvZy5zZXJpYWxpemVycyAmJiBsb2cuc2VyaWFsaXplcnMuZXJyID8gbG9nLnNlcmlhbGl6ZXJzLmVycihhcmdzWzBdKSA6IExvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIoYXJnc1swXSkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBleGNsdWRlRmllbGRzID0ge2VycjogdHJ1ZX07XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ0FyZ3MgPSBbZmllbGRzLmVyci5tZXNzYWdlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGFyZ3NbMF0pICE9PSAnb2JqZWN0JyAmJiBhcmdzWzBdICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGBsb2cuPGxldmVsPihtc2csIC4uLilgXG4gICAgICAgICAgICAgICAgZmllbGRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gYGxvZy48bGV2ZWw+KGZpZWxkcywgbXNnLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbXNnQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgcmVjb3JkIG9iamVjdC5cbiAgICAgICAgICAgIHZhciByZWMgPSBvYmpDb3B5KGxvZy5maWVsZHMpO1xuICAgICAgICAgICAgcmVjLmxldmVsID0gbWluTGV2ZWw7XG4gICAgICAgICAgICB2YXIgcmVjRmllbGRzID0gKGZpZWxkcyA/IG9iakNvcHkoZmllbGRzKSA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlY0ZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2cuc2VyaWFsaXplcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLl9hcHBseVNlcmlhbGl6ZXJzKHJlY0ZpZWxkcywgZXhjbHVkZUZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlY0ZpZWxkcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICByZWNba10gPSByZWNGaWVsZHNba107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWMubGV2ZWxOYW1lID0gbmFtZUZyb21MZXZlbFttaW5MZXZlbF07XG4gICAgICAgICAgICByZWMubXNnID0gZm9ybWF0LmFwcGx5KGxvZywgbXNnQXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlYy50aW1lKSB7XG4gICAgICAgICAgICAgICAgcmVjLnRpbWUgPSAobmV3IERhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2FsbCBzb3VyY2UgaW5mb1xuICAgICAgICAgICAgaWYgKGxvZy5zcmMgJiYgIXJlYy5zcmMpIHtcbiAgICAgICAgICAgICAgICByZWMuc3JjID0gZ2V0Q2FsbGVyM0luZm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYy52ID0gTE9HX1ZFUlNJT047XG5cbiAgICAgICAgICAgIHJldHVybiByZWM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGRzID0gbnVsbDtcbiAgICAgICAgdmFyIG1zZ0FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciByZWMgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2VtaXQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBTaG93IHRoaXMgaW52YWxpZCBCdW55YW4gdXNhZ2Ugd2FybmluZyAqb25jZSouXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIDxodHRwczovL2dpdGh1Yi5jb20vdHJlbnRtL25vZGUtYnVueWFuL2lzc3Vlcy8xMDA+IGZvclxuICAgICAgICAgICAgICogYW4gZXhhbXBsZSBvZiBob3cgdGhpcyBjYW4gaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZGVkdXBLZXkgPSAndW5ib3VuZCc7XG4gICAgICAgICAgICBpZiAoIV9oYXZlV2FybmVkW2RlZHVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsZXIgPSBnZXRDYWxsZXIzSW5mbygpO1xuICAgICAgICAgICAgICAgIF93YXJuKGZvcm1hdCgnYnVueWFuIHVzYWdlIGVycm9yOiAlczolczogYXR0ZW1wdCB0byBsb2cgd2l0aCBhbiB1bmJvdW5kIGxvZyBtZXRob2Q6IGB0aGlzYCBpczogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyLmZpbGUsIGNhbGxlci5saW5lLCB0aGlzLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyAgIC8vIGBsb2cuPGxldmVsPigpYFxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9sZXZlbCA8PSBtaW5MZXZlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGV2ZWwgPiBtaW5MZXZlbCkge1xuICAgICAgICAgICAgLyogcGFzcyB0aHJvdWdoICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWMgPSBta1JlY29yZChtc2dBcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQocmVjKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb25zIGJlbG93IGxvZyBhIHJlY29yZCBhdCBhIHNwZWNpZmljIGxldmVsLlxuICpcbiAqIFVzYWdlczpcbiAqICAgIGxvZy48bGV2ZWw+KCkgIC0+IGJvb2xlYW4gaXMtdHJhY2UtZW5hYmxlZFxuICogICAgbG9nLjxsZXZlbD4oPEVycm9yPiBlcnIsIFs8c3RyaW5nPiBtc2csIC4uLl0pXG4gKiAgICBsb2cuPGxldmVsPig8c3RyaW5nPiBtc2csIC4uLilcbiAqICAgIGxvZy48bGV2ZWw+KDxvYmplY3Q+IGZpZWxkcywgPHN0cmluZz4gbXNnLCAuLi4pXG4gKlxuICogd2hlcmUgPGxldmVsPiBpcyB0aGUgbG93ZXJjYXNlIHZlcnNpb24gb2YgdGhlIGxvZyBsZXZlbC4gRS5nLjpcbiAqXG4gKiAgICBsb2cuaW5mbygpXG4gKlxuICogQHBhcmFtcyBmaWVsZHMge09iamVjdH0gT3B0aW9uYWwgc2V0IG9mIGFkZGl0aW9uYWwgZmllbGRzIHRvIGxvZy5cbiAqIEBwYXJhbXMgbXNnIHtTdHJpbmd9IExvZyBtZXNzYWdlLiBUaGlzIGNhbiBiZSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsXG4gKiAgICBhcmd1bWVudHMgdGhhdCBhcmUgaGFuZGxlZCBsaWtlXG4gKiAgICBbdXRpbC5mb3JtYXRdKGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9hbGwuaHRtbCN1dGlsLmZvcm1hdCkuXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBta0xvZ0VtaXR0ZXIoVFJBQ0UpO1xuTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IG1rTG9nRW1pdHRlcihERUJVRyk7XG5Mb2dnZXIucHJvdG90eXBlLmluZm8gPSBta0xvZ0VtaXR0ZXIoSU5GTyk7XG5Mb2dnZXIucHJvdG90eXBlLndhcm4gPSBta0xvZ0VtaXR0ZXIoV0FSTik7XG5Mb2dnZXIucHJvdG90eXBlLmVycm9yID0gbWtMb2dFbWl0dGVyKEVSUk9SKTtcbkxvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBta0xvZ0VtaXR0ZXIoRkFUQUwpO1xuXG5cbi8vLS0tLSBTdGFuZGFyZCBzZXJpYWxpemVyc1xuLy8gQSBzZXJpYWxpemVyIGlzIGEgZnVuY3Rpb24gdGhhdCBzZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYVxuLy8gSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgbG9nZ2luZy4gVGhlcmUgaXMgYSBzdGFuZGFyZCBzZXQgb2YgcHJlc3VtZWRcbi8vIGludGVyZXN0aW5nIG9iamVjdHMgaW4gbm9kZS5qcy1sYW5kLlxuXG5Mb2dnZXIuc3RkU2VyaWFsaXplcnMgPSB7fTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKVxuICogbWV0aG9kLiBUaGUgZXJyb3IgY2xhc3NlcyBmcm9tXG4gKiBbdmVycm9yXShodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS12ZXJyb3IpIGFuZFxuICogW3Jlc3RpZnkgdjIuMF0oaHR0cHM6Ly9naXRodWIuY29tL21jYXZhZ2Uvbm9kZS1yZXN0aWZ5KSBhcmUgZXhhbXBsZXMuXG4gKlxuICogQmFzZWQgb24gYGR1bXBFeGNlcHRpb25gIGluXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS1leHRzcHJpbnRmL2Jsb2IvbWFzdGVyL2xpYi9leHRzcHJpbnRmLmpzXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bGxFcnJvclN0YWNrKGV4KSB7XG4gICAgdmFyIHJldCA9IGV4LnN0YWNrIHx8IGV4LnRvU3RyaW5nKCk7XG4gICAgaWYgKGV4LmNhdXNlICYmIHR5cGVvZiAoZXguY2F1c2UpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjZXggPSBleC5jYXVzZSgpO1xuICAgICAgICBpZiAoY2V4KSB7XG4gICAgICAgICAgICByZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGdldEZ1bGxFcnJvclN0YWNrKGNleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChyZXQpO1xufVxuXG4vLyBTZXJpYWxpemUgYW4gRXJyb3Igb2JqZWN0XG4vLyAoQ29yZSBlcnJvciBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlIGluIG5vZGUgMC40LCBub3QgaW4gMC42KS5cbkxvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoIWVyciB8fCAhZXJyLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgIG5hbWU6IGVyci5uYW1lLFxuICAgICAgICBzdGFjazogZ2V0RnVsbEVycm9yU3RhY2soZXJyKSxcbiAgICAgICAgY29kZTogZXJyLmNvZGUsXG4gICAgICAgIHNpZ25hbDogZXJyLnNpZ25hbFxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gQSBKU09OIHN0cmluZ2lmaWVyIHRoYXQgaGFuZGxlcyBjeWNsZXMgc2FmZWx5LlxuLy8gVXNhZ2U6IEpTT04uc3RyaW5naWZ5KG9iaiwgc2FmZUN5Y2xlcygpKVxuZnVuY3Rpb24gc2FmZUN5Y2xlcygpIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwgfHwgdHlwZW9mICh2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4ucHVzaCh2YWwpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG59XG5cbi8vLS0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyO1xuXG5tb2R1bGUuZXhwb3J0cy5UUkFDRSA9IFRSQUNFO1xubW9kdWxlLmV4cG9ydHMuREVCVUcgPSBERUJVRztcbm1vZHVsZS5leHBvcnRzLklORk8gPSBJTkZPO1xubW9kdWxlLmV4cG9ydHMuV0FSTiA9IFdBUk47XG5tb2R1bGUuZXhwb3J0cy5FUlJPUiA9IEVSUk9SO1xubW9kdWxlLmV4cG9ydHMuRkFUQUwgPSBGQVRBTDtcbm1vZHVsZS5leHBvcnRzLnJlc29sdmVMZXZlbCA9IHJlc29sdmVMZXZlbDtcbm1vZHVsZS5leHBvcnRzLmxldmVsRnJvbU5hbWUgPSBsZXZlbEZyb21OYW1lO1xubW9kdWxlLmV4cG9ydHMubmFtZUZyb21MZXZlbCA9IG5hbWVGcm9tTGV2ZWw7XG5cbm1vZHVsZS5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xubW9kdWxlLmV4cG9ydHMuTE9HX1ZFUlNJT04gPSBMT0dfVkVSU0lPTjtcblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcihvcHRpb25zKTtcbn07XG5cbi8vIFVzZWZ1bCBmb3IgY3VzdG9tIGB0eXBlID09ICdyYXcnYCBzdHJlYW1zIHRoYXQgbWF5IGRvIEpTT04gc3RyaW5naWZpY2F0aW9uXG4vLyBvZiBsb2cgcmVjb3JkcyB0aGVtc2VsdmVzLiBVc2FnZTpcbi8vICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShyZWMsIGJ1bnlhbi5zYWZlQ3ljbGVzKCkpO1xubW9kdWxlLmV4cG9ydHMuc2FmZUN5Y2xlcyA9IHNhZmVDeWNsZXM7XG5cbi8vc3RyZWFtc1xubW9kdWxlLmV4cG9ydHMuQ29uc29sZUZvcm1hdHRlZFN0cmVhbSA9IENvbnNvbGVGb3JtYXR0ZWRTdHJlYW07XG5tb2R1bGUuZXhwb3J0cy5Db25zb2xlUmF3U3RyZWFtID0gQ29uc29sZVJhd1N0cmVhbTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnJvd3Nlci1idW55YW4vbGliL2J1bnlhbi5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIG1zZyl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKXRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0luZGV4ICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQvKj0gMCovLCBzdGFydC8qPSAwLCBlbmQgPSBAbGVuZ3RoKi8pe1xuICB2YXIgTyAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuICAgPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIHRvICAgID0gdG9JbmRleCh0YXJnZXQsIGxlbilcbiAgICAsIGZyb20gID0gdG9JbmRleChzdGFydCwgbGVuKVxuICAgICwgZW5kICAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0luZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0bylcbiAgICAsIGluYyAgID0gMTtcbiAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcbiAgICBpbmMgID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gICArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUoY291bnQtLSA+IDApe1xuICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gICArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpe1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxuICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmKGFMZW4gPCAyKWZvcig7Oyl7XG4gICAgaWYoaW5kZXggaW4gc2VsZil7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIHNlbGYpe1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlXG4gICwgZmFjdG9yaWVzICA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24oRiwgbGVuLCBhcmdzKXtcbiAgaWYoIShsZW4gaW4gZmFjdG9yaWVzKSl7XG4gICAgZm9yKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgdmFyIGZuICAgICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbigvKiBhcmdzLi4uICovKXtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYoaXNPYmplY3QoZm4ucHJvdG90eXBlKSlib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIHNldFNwZWNpZXMgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIGZhc3RLZXkgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXlcbiAgLCBTSVpFICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCAnZm9yRWFjaCcpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBnZXRXZWFrICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrXG4gICwgYW5PYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgLCAkaGFzICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgYXJyYXlGaW5kICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAsIGFycmF5RmluZEluZGV4ICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgLCBpZCAgICAgICAgICAgICAgICA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbigpe1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSl7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KWVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmKH5pbmRleCl0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZihkYXRhID09PSB0cnVlKXVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmxvb3IgICAgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgaXNFbnVtICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzRW50cmllcyl7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdChpdClcbiAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBpICAgICAgPSAwXG4gICAgICAsIHJlc3VsdCA9IFtdXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpe1xuICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIFJlZmxlY3QgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCl7XG4gIHZhciBrZXlzICAgICAgID0gZ09QTi5mKGFuT2JqZWN0KGl0KSlcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0XG4gICwgJHRyaW0gICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKVxuICAgICwgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50XG4gICwgJHRyaW0gICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgd3MgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBoZXggICAgICAgPSAvXltcXC0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgcmVwZWF0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpe1xuICB2YXIgUyAgICAgICAgICAgID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgLCBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aFxuICAgICwgZmlsbFN0ciAgICAgID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpXG4gICAgLCBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZihpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoXG4gICAgLCBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKXN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJylyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIHJlZGVmaW5lICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBtZXRhICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0V2VhayAgICAgID0gbWV0YS5nZXRXZWFrXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZVxuICAsIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmVcbiAgLCB0bXAgICAgICAgICAgPSB7fVxuICAsIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCl7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha01hcCcsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZihuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIpO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIGlmKCF0aGlzLl9mKXRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXA7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBTREtfVkVSU0lPTiwgTE9HX0xFVkVMIGluamVjdGVkIGZyb20gd2VicGFjayBidWlsZC5cbmltcG9ydCB7IExFVkVMUywgZXN0YWJsaXNoTG9nZ2VyLCBnZXRMb2dnZXIgfSBmcm9tICcuL2xvZydcbmV4cG9ydCB7IExFVkVMUyBhcyBMb2dMZXZlbHMgfSBmcm9tICcuL2xvZydcbmV4cG9ydCB7IGdldExvZ2dlciBhcyBnZXRMb2dnZXIgfSBmcm9tICcuL2xvZydcblxuaW1wb3J0ICogYXMgc3Vic2NyaWJlckxpYiBmcm9tICcuL3N1YnNjcmliZXIvaW5kZXgnXG5pbXBvcnQgKiBhcyBwdWJsaXNoZXJMaWIgZnJvbSAnLi9wdWJsaXNoZXIvaW5kZXgnXG5pbXBvcnQgKiBhcyBzaGFyZWRPYmplY3RMaWIgZnJvbSAnLi9zaGFyZWRvYmplY3QvaW5kZXgnXG5pbXBvcnQgUGxheWJhY2tWaWV3IGZyb20gJy4vdmlldy9wbGF5YmFjaydcbmltcG9ydCBQdWJsaXNoZXJWaWV3IGZyb20gJy4vdmlldy9wdWJsaXNoJ1xuXG4vKipcbiAqIFN1YnNjcmlwdGlvbiByZWxhdGVkIHJlZmVyZW5jZXMuXG4qL1xuZXhwb3J0IGNvbnN0IFJlZDVQcm9TdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5SZWQ1UHJvU3Vic2NyaWJlclxuZXhwb3J0IGNvbnN0IFJUQ1N1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlJUQ1N1YnNjcmliZXJcbmV4cG9ydCBjb25zdCBITFNTdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5ITFNTdWJzY3JpYmVyXG5leHBvcnQgY29uc3QgUlRNUFN1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlJUTVBTdWJzY3JpYmVyXG5leHBvcnQgeyBQbGF5YmFja1ZpZXcgfVxuXG4vKipcbiAqIEJyb2FkY2FzdCByZWxhdGVkIHJlZmVyZW5jZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWQ1UHJvUHVibGlzaGVyID0gcHVibGlzaGVyTGliLlJlZDVQcm9QdWJsaXNoZXJcbmV4cG9ydCBjb25zdCBSVE1QUHVibGlzaGVyID0gcHVibGlzaGVyTGliLlJUTVBQdWJsaXNoZXJcbmV4cG9ydCBjb25zdCBSVENQdWJsaXNoZXIgPSBwdWJsaXNoZXJMaWIuUlRDUHVibGlzaGVyXG5leHBvcnQgeyBQdWJsaXNoZXJWaWV3IH1cblxuLyoqXG4gKiBQbGF5YmFjayBjb250cm9scyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCB7IFBsYXliYWNrQ29udHJvbHMgYXMgUGxheWJhY2tDb250cm9scyB9IGZyb20gJy4vc3Vic2NyaWJlci9jb250cm9scy9pbmRleCdcblxuLyoqXG4gKiBTaGFyZWQgT2JqZWN0IHJlZmVyZW5jZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWQ1UHJvU2hhcmVkT2JqZWN0ID0gc2hhcmVkT2JqZWN0TGliLlJlZDVQcm9TaGFyZWRPYmplY3RcblxuLyoqXG4gKiBFdmVudHNcbiAqL1xuZXhwb3J0IHsgY29tbW9uIGFzIFB1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3B1Ymxpc2hlci1ldmVudCdcbmV4cG9ydCB7IHJ0YyBhcyBSVENQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBmYWlsb3ZlciBhcyBGYWlsb3ZlclB1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3B1Ymxpc2hlci1ldmVudCdcbmV4cG9ydCB7IGNvbW1vbiBhcyBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IHJ0YyBhcyBSVENTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IGZhaWxvdmVyIGFzIEZhaWxvdmVyU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBjb21tb24gYXMgU2hhcmVkT2JqZWN0RXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvc2hhcmVkb2JqZWN0LWV2ZW50J1xuXG4vKlxuICogRW51bXNcbiovXG5leHBvcnQgeyBQbGF5YmFja0F1ZGlvRW5jb2RlciBhcyBQbGF5YmFja0F1ZGlvRW5jb2RlciB9IGZyb20gJy4vZW51bS9wbGF5YmFjaydcbmV4cG9ydCB7IFBsYXliYWNrVmlkZW9FbmNvZGVyIGFzIFBsYXliYWNrVmlkZW9FbmNvZGVyIH0gZnJvbSAnLi9lbnVtL3BsYXliYWNrJ1xuXG5lc3RhYmxpc2hMb2dnZXIoYCR7TE9HX0xFVkVMfWAgfHwgTEVWRUxTLkRFQlVHKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5nZXRMb2dnZXIoKS5kZWJ1ZyhgUmVkNSBQcm8gU0RLIFZlcnNpb24gJHtTREtfVkVSU0lPTn1gKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbmV4cG9ydCBjb25zdCBzZXRMb2dMZXZlbCA9IChsZXZlbCkgPT4ge1xuICBpZiAoTEVWRUxTLmhhc093blByb3BlcnR5KGxldmVsLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgZXN0YWJsaXNoTG9nZ2VyKGxldmVsKVxuICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlO1xuXG52YXIgREVGSU5FX1BST1BFUlRZID0gXCJkZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gZGVmaW5lKE8sIGtleSwgdmFsdWUpIHtcbiAgT1trZXldIHx8IE9iamVjdFtERUZJTkVfUFJPUEVSVFldKE8sIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZExlZnRcIiwgXCJcIi5wYWRTdGFydCk7XG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRSaWdodFwiLCBcIlwiLnBhZEVuZCk7XG5cblwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBbXVtrZXldICYmIGRlZmluZShBcnJheSwga2V5LCBGdW5jdGlvbi5jYWxsLmJpbmQoW11ba2V5XSkpO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IGpzb25BdHRyID0gL1snXCJdKC4qPylbJ1wiXTovZ2lcbmNvbnN0IGpzb25WYWwgPSAvOlsnXCJdKC4qPylbJ1wiXS9naVxuXG5mdW5jdGlvbiByZWFkVVRGIChkYXRhLHN0YXJ0LGxlbikge1xuICBsZXQgcmVzdWx0ID0gJycsIG9mZnNldCA9IHN0YXJ0LCBlbmQgPSBzdGFydCArIGxlblxuICBkbyB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtvZmZzZXQrK10pXG4gIH1cbiAgd2hpbGUob2Zmc2V0IDwgZW5kKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHBhcnNlSlNPTkZvck9yaWVudGF0aW9uICh0ZXh0KSB7XG4gIHRyeSB7XG4gICAgbGV0IHZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0KVxuICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnb3JpZW50YXRpb24nKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZW50YXRpb246IHBhcnNlSW50KHZhbHVlLm9yaWVudGF0aW9uKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICBsZXQgbWF0Y2ggPSBqc29uQXR0ci5leGVjKHRleHQpXG4gICAgbGV0IG1hdGNoMlxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICBtYXRjaDIgPSBqc29uVmFsLmV4ZWModGV4dClcbiAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ29yaWVudGF0aW9uJyAmJiBtYXRjaDIgJiYgbWF0Y2gyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvcmllbnRhdGlvbjogcGFyc2VJbnQobWF0Y2gyWzFdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb25PcmllbnRhdGlvbk1ldGFkYXRhID0gKHBsYXllciwgY2FsbGJhY2spID0+IHtcblxuICBjb25zdCB0ZXh0VHJhY2tzID0gdHlwZW9mIHBsYXllci50ZXh0VHJhY2tzID09PSAnZnVuY3Rpb24nID8gcGxheWVyLnRleHRUcmFja3MoKSA6IHBsYXllci50ZXh0VHJhY2tzXG5cbiAgaWYgKHRleHRUcmFja3MpIHtcblxuICAgIHBsYXllci5hZGRUZXh0VHJhY2soJ21ldGFkYXRhJylcblxuICAgIHRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCBhZGRUcmFja0V2ZW50ID0+IHtcblxuICAgICAgbGV0IHRyYWNrID0gYWRkVHJhY2tFdmVudC50cmFja1xuICAgICAgdHJhY2subW9kZSA9ICdoaWRkZW4nXG4gICAgICAvKipcbiAgICAgIHZhciBjdWUgPSBuZXcgVlRUQ3VlKDEuMCwgMCwgJ1Rlc3RpbmcnKVxuICAgICAgY3VlLmlkID0gMVxuICAgICAgY3VlLnBhdXNlT25FeGl0ID0gZmFsc2VcbiAgICAgIHRyYWNrLmFkZEN1ZShjdWUpXG4gICAgICAqL1xuXG4gICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCBjdWVDaGFuZ2VFdmVudCA9PiB7XG4gICAgICAgIGxldCBjdWVzXG4gICAgICAgIGxldCBpXG4gICAgICAgIC8vIE1vc3RseSBDaHJvbWUuXG4gICAgICAgIGlmIChjdWVDaGFuZ2VFdmVudCAmJiBjdWVDaGFuZ2VFdmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgY3VlcyA9IGN1ZUNoYW5nZUV2ZW50LmN1cnJlbnRUYXJnZXQuY3Vlc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuZGVmaW5lZCA9PT0gdGhpcykge1xuICAgICAgICAgIGN1ZXMgPSB0cmFjay5jdWVzXG4gICAgICAgICAgY3VlcyA9IGN1ZXMgJiYgY3Vlcy5sZW5ndGggPiAwID8gY3VlcyA6IHRyYWNrLmFjdGl2ZUN1ZXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bmRlZmluZWQgIT09IHRoaXMpIHtcbiAgICAgICAgICAvLyBNb3N0bHkgRmlyZWZveCAmIFNhZmFyaS5cbiAgICAgICAgICBjdWVzID0gY3VlcyAmJiBjdWVzLmxlbmd0aCA+IDAgPyBjdWVzIDogdGhpcy5hY3RpdmVDdWVzXG4gICAgICAgIH1cbiAgICAgICAgLy8gTW9zdGx5IGZhaWx1cmUuXG4gICAgICAgIGN1ZXMgPSBjdWVzIHx8IFtdXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBjdWVzW2ldXG4gICAgICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIGRhdGEudmFsdWUuZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhLnZhbHVlLmRhdGEgOiByZWFkVVRGKCBkYXRhLnZhbHVlLmRhdGEgLCAwICwgZGF0YS5zaXplKVxuICAgICAgICAgICAgbGV0IG9yaWVudGF0aW9uID0gcGFyc2VKU09ORm9yT3JpZW50YXRpb24odGV4dClcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG9yaWVudGF0aW9uKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIH0pXG5cbiAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZW52L21ldGFkYXRhLXV0aWwuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGNsYXNzIE5vRWxlbWVudEZvdW5kRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdOb0VsZW1lbnRGb3VuZCdcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vU3VwcG9ydGVkQ2FtZXJhUmVzb2x1dGlvbnNFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gJ05vU3VwcG9ydGVkQ2FtZXJhUmVzb2x1dGlvbnNFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9leGNlcHRpb24vZXJyb3JzLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBTb2NrZXRIZWxwZXIgZnJvbSAnLi9zb2NrZXQtaGVscGVyJ1xuaW1wb3J0IHsgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoZXJTb2NrZXQnXG5cbmNsYXNzIFB1Ymxpc2hlclNvY2tldEhlbHBlciBleHRlbmRzIFNvY2tldEhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlcikge1xuICAgIHN1cGVyKHJlc3BvbmRlciwgTkFNRSlcbiAgfVxuXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXN1cGVyLnJlc3BvbmQobWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zZHAudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBBbnN3ZXIoanNvbi5kYXRhKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFkZEljZUNhbmRpZGF0ZShqc29uLmRhdGEuY2FuZGlkYXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLklDRS5UcmljbGVDb21wbGV0ZWQnIHx8XG4gICAgICAgICAgICAgICAgIGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5JQ0UuVHJpY2tsZUNvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblB1Ymxpc2hlclN0YXR1cyhqc29uLmRhdGEpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoTkFNRSwgYFt3cy5vbm1lc3NhZ2VdIC0gRXJyb3IgaW4gYWNjZXNzaW5nIG1lc3NhZ2UgZGF0YSBhcyBKU09OLiAke2UubWVzc2FnZX1gKVxuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25Tb2NrZXRNZXNzYWdlRXJyb3IoYFt3cy5vbm1lc3NhZ2VdIC0gRXJyb3IgaW4gYWNjZXNzaW5nIG1lc3NhZ2UgZGF0YSBhcyBKU09OLiAke2UubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKE5BTUUsICdbd3Mub25tZXNzYWdlXSAtIE5vIE1lc3NhZ2UgRGF0YS4nKVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFB1Ymxpc2hlclNvY2tldEhlbHBlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2hlbHBlci9zb2NrZXQtaGVscGVyLXB1Yi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgU29ja2V0SGVscGVyIGZyb20gJy4vc29ja2V0LWhlbHBlcidcbmltcG9ydCB7IHdhcm4sIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvU3Vic2NyaXB0aW9uU29ja2V0J1xuXG5jbGFzcyBTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIgZXh0ZW5kcyBTb2NrZXRIZWxwZXIge1xuXG4gIGNvbnN0cnVjdG9yIChyZXNwb25kZXIpIHtcbiAgICBzdXBlcihyZXNwb25kZXIsIE5BTUUpXG4gIH1cblxuICByZXNwb25kIChtZXNzYWdlKSB7XG4gICAgLy8gICAgY29uc29sZS5sb2cobWVzc2FnZSlcbiAgICBpZiAobWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXN1cGVyLnJlc3BvbmQobWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zZHAudHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUE9mZmVyKGpzb24uZGF0YSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jYW5kaWRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25BZGRJY2VDYW5kaWRhdGUoanNvbi5kYXRhLmNhbmRpZGF0ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5JQ0UuVHJpY2xlQ29tcGxldGVkJyB8fFxuICAgICAgICAgICAgICAgICBqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uSUNFLlRyaWNrbGVDb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0SWNlQ2FuZGlkYXRlRW5kKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldFN0cmVhbS5QbGF5LlVucHVibGlzaE5vdGlmeScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25VbnB1Ymxpc2goKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5Db25uZWN0LkNsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TdWJzY3JpYmVyU3RhdHVzKGpzb24uZGF0YSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5oYXNPd25Qcm9wZXJ0eSgnc3RhdHVzJykpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdOZXRTdHJlYW0uUGxheS5VbnB1Ymxpc2hOb3RpZnknKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uVW5wdWJsaXNoKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChqc29uLnR5cGUgPT09ICdtZXRhZGF0YScpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBhIGBzZW5kYCBBUEkgaW52b2NhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoanNvbi5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU2VuZFJlY2VpdmVkKGpzb24ubWV0aG9kLCBqc29uLmRhdGEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsc2UgaXQgaXMgbm9ybWFsIG1ldGFkYXRhLlxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uTWV0YURhdGEoanNvbi5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoanNvbi50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChqc29uLnR5cGUgPT09ICdtZXRhZGF0YScpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uTWV0YURhdGEoanNvbi5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKE5BTUUsIGBbd3Mub25tZXNzYWdlXSAtIEVycm9yIGluIGFjY2Vzc2luZyBtZXNzYWdlIGRhdGEgYXMgSlNPTi4gJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0TWVzc2FnZUVycm9yKGBbd3Mub25tZXNzYWdlXSAtIEVycm9yIGluIGFjY2Vzc2luZyBtZXNzYWdlIGRhdGEgYXMgSlNPTi4gJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihOQU1FLCAnW3dzLm9ubWVzc2FnZV0gLSBObyBNZXNzYWdlIERhdGEuJylcbiAgICB9XG4gIH1cblxufVxuZXhwb3J0IGRlZmF1bHQgU3Vic2NyaXB0aW9uU29ja2V0SGVscGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItc3ViLmpzIiwiJ3VzZSBzdHJpY3QnXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1B1Ymxpc2hQZWVyJ1xuXG5jbGFzcyBQdWJsaXNoZXJQZWVySGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9hZGRDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24sIHByb21pc2UpIHtcblxuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbcGVlcmNvbm5lY3Rpb246b3Blbl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcgfHxcbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgJ1twZWVyY29ubmVjdGlvbjplcnJvcl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlYnVnKE5BTUUsIGBbcGVlcmNvbm5lY3Rpb246JHtjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZX1dYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25pY2VjYW5kaWRhdGVdIC0gUGVlciBDYW5kaWRhdGU6ICR7ZXZlbnQuY2FuZGlkYXRlfWApXG4gICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkljZUNhbmRpZGF0ZShldmVudC5jYW5kaWRhdGUpXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmNhbmRpZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBudWxsIG1lYW5zIHRoZXkgaGF2ZSBmaW5pc2hlZCBzZW5kaW5nIGNhbmRpZGF0ZXMgYmFjayBhbmQgZm9ydGg/XG4gICAgICAgIC8vIE1vdmVkIHRvIG5vdGlmaWNhdGlvbiBmcm9tIHNlcnZlciBvbiB0cmlja2xlIGVuZCBldmVudC5cbiAgICAgICAgLy8gdGhpcy5fcmVzcG9uZGVyLm9uSWNlQ2FuZGlkYXRlVHJpY2tsZUVuZCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSBldmVudC5jdXJyZW50VGFyZ2V0LmljZUNvbm5lY3Rpb25TdGF0ZVxuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlXSAtIFN0YXRlOiAke3N0YXRlfWApXG4gICAgICBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QZWVyQ29ubmVjdGlvbkNsb3NlKGV2ZW50KVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgZ2V0VXNlck1lZGlhIChjb25zdHJhaW50cykge1xuICAgIHJldHVybiB3ZWJydGMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICB9XG5cbiAgZm9yY2VVc2VyTWVkaWEgKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIHdlYnJ0Yy5mb3JjZVVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgfVxuXG4gIGNyZWF0ZU9mZmVyIChiYW5kd2lkdGggPSBudWxsLCBvZmZlclByb21pc2UgPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVvZmZlcl0nKVxuICAgIGNvbnN0IHAgPSBvZmZlclByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIoKVxuICAgICAgLnRoZW4oKHNlc3Npb25EZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICB0aGlzLnNldExvY2FsRGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uLCBiYW5kd2lkdGgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb24uc2RwID0gd2VicnRjLnVwZGF0ZUJhbmR3aWR0aChiYW5kd2lkdGgsIHNlc3Npb25EZXNjcmlwdGlvbi5zZHApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBTdWNjZXNzKClcbiAgICAgICAgICAgIHAucmVzb2x2ZShzZXNzaW9uRGVzY3JpcHRpb24pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQRXJyb3IoZXJyKVxuICAgICAgICAgICAgcC5yZWplY3QoZXJyKVxuICAgICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbY3JlYXRlb2ZmZXI6ZXJyb3JdJylcbiAgICAgICAgcC5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgc2V0TG9jYWxEZXNjcmlwdGlvbiAoc2Vzc2lvbkRlc2NyaXB0aW9uLCBiYW5kd2lkdGggPSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldGxvY2FsZGVzY3JpcHRpb25dJylcbiAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24pXG4gIH1cblxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbiAoc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZXRyZW1vdGVkZXNjcmlwdGlvbl0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihzZHApKVxuICB9XG5cbiAgYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2FkZGNhbmRpZGF0ZV0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICB9XG5cbiAgc2V0VXAgKGljZVNlcnZlcnMsIHNldFVwUHJvbWlzZSA9IHVuZGVmaW5lZCwgcnRjcE11eFBvbGljeSA9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudGVhckRvd24oKVxuICAgIGNvbnN0IHAgPSBzZXRVcFByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdHJ5IHtcbiAgICAgIGxldCBwZWVyQ29uZmlnID0ge1xuICAgICAgICBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzLFxuICAgICAgICBydGNwTXV4UG9saWN5OiAnbmVnb3RpYXRlJ1xuICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcnRjcE11eFBvbGljeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGVlckNvbmZpZy5ydGNwTXV4UG9saWN5ID0gcnRjcE11eFBvbGljeVxuICAgICAgfVxuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyY29ubmVjdGlvbjpzZXR1cF06ICR7SlNPTi5zdHJpbmdpZnkocGVlckNvbmZpZywgbnVsbCwgMil9YClcbiAgICAgIGxldCBwZWVyID0gbmV3IHdlYnJ0Yy5SVENQZWVyQ29ubmVjdGlvbihwZWVyQ29uZmlnLFxuICAgICAgICB7XG4gICAgICAgICAgb3B0aW9uYWw6IFtcbiAgICAgICAgICAgIHtEdGxzU3J0cEtleUFncmVlbWVudDogdHJ1ZX0sXG4gICAgICAgICAgICB7UnRwRGF0YUNoYW5uZWxzOiBmYWxzZX0sXG4gICAgICAgICAgICB7Z29vZ0NwdU92ZXJ1c2VEZXRlY3Rpb246IHRydWV9XG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbkhhbmRsZXJzKHBlZXIpXG4gICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHBlZXJcbiAgICAgIHAucmVzb2x2ZShwZWVyKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oTkFNRSwgYENvdWxkIG5vdCBlc3RhYmxpc2ggYSBQZWVyQ29ubmVjdGlvbi4gJHtlLm1lc3NhZ2V9YClcbiAgICAgIHAucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHRlYXJEb3duICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3RlYXJkb3duXScpXG4gICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLl9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnModGhpcy5fcGVlckNvbm5lY3Rpb24pXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jbG9zZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwZWVyY29ubmVjdGlvbi5jbG9zZV0gZXJyb3I6ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHVibGlzaGVyUGVlckhlbHBlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXB1Yi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9TdWJzY3JpcHRpb25QZWVyJ1xuXG5jb25zdCBpc0VtcHR5Q2FuZGlkYXRlID0gKGNhbmRpZGF0ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAodHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLmxlbmd0aCA9PT0gMClcbn1cblxuY2xhc3MgU3Vic2NyaXB0aW9uUGVlckhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlcikge1xuICAgIHRoaXMuX3Jlc3BvbmRlciA9IHJlc3BvbmRlclxuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gIH1cblxuICBfcmVtb3ZlQ29ubmVjdGlvbkhhbmRsZXJzIChjb25uZWN0aW9uKSB7XG4gICAgY29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub250cmFjayA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX2FkZENvbm5lY3Rpb25IYW5kbGVycyAoY29ubmVjdGlvbiwgcHJvbWlzZSkge1xuXG4gICAgY29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgZGVidWcoTkFNRSwgJ1twZWVyY29ubmVjdGlvbjpvcGVuXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnIHx8XG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICB3YXJuKE5BTUUsICdbcGVlcmNvbm5lY3Rpb246ZXJyb3JdJylcbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICBwcm9taXNlLnJlamVjdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgW3BlZXIub25pY2VjYW5kaWRhdGVdIC0gUGVlciBDYW5kaWRhdGU6ICR7ZXZlbnQuY2FuZGlkYXRlfWApXG4gICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkljZUNhbmRpZGF0ZShldmVudC5jYW5kaWRhdGUpXG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmNhbmRpZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBudWxsIG1lYW5zIHRoZXkgaGF2ZSBmaW5pc2hlZCBzZW5kaW5nIGNhbmRpZGF0ZXMgYmFjayBhbmQgZm9ydGg/XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkljZUNhbmRpZGF0ZVRyaWNrbGVFbmQodGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtKVxuICAgICAgICB0aGlzLl9wZW5kaW5nTWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9uYWRkc3RyZWFtID0gKGV2ZW50KSA9PiB7XG4gICAgICBkZWJ1ZyhOQU1FLCBgUGVlciBBZGQgU3RyZWFtOiAke2V2ZW50LnN0cmVhbX1gKVxuICAgICAgaWYgKGV2ZW50LnN0cmVhbSkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nTWVkaWFTdHJlYW0gPSBldmVudC5zdHJlYW1cbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uQW5zd2VyTWVkaWFTdHJlYW0oZXZlbnQuc3RyZWFtKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub250cmFjayA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFBlZXIgQWRkIFN0cmVhbTogJHtldmVudC5zdHJlYW1zfWApXG4gICAgICBpZiAoZXZlbnQuc3RyZWFtcyAmJiBldmVudC5zdHJlYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gZXZlbnQuc3RyZWFtc1swXVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZXZlbnQuY3VycmVudFRhcmdldC5pY2VDb25uZWN0aW9uU3RhdGVcbiAgICAgIGRlYnVnKE5BTUUsIGBbcGVlci5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZV0gLSBTdGF0ZTogJHtzdGF0ZX1gKVxuICAgICAgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCBzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uUGVlckNvbm5lY3Rpb25DbG9zZShldmVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHNldFVwIChpY2VTZXJ2ZXJzLCBzZXRVcFByb21pc2UgPSB1bmRlZmluZWQsIHJ0Y3BNdXhQb2xpY3kgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICBjb25zdCBwID0gc2V0VXBQcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICBsZXQgcGVlckNvbmZpZyA9IHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgcnRjcE11eFBvbGljeTogJ25lZ290aWF0ZSdcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcnRjcE11eFBvbGljeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGVlckNvbmZpZy5ydGNwTXV4UG9saWN5ID0gcnRjcE11eFBvbGljeVxuICAgICAgfVxuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyY29ubmVjdGlvbjpzZXR1cF06ICR7SlNPTi5zdHJpbmdpZnkocGVlckNvbmZpZywgbnVsbCwgMil9YClcbiAgICAgIGxldCBwZWVyID0gbmV3IHdlYnJ0Yy5SVENQZWVyQ29ubmVjdGlvbihwZWVyQ29uZmlnLFxuICAgICAgICB7XG4gICAgICAgICAgb3B0aW9uYWw6IFtcbiAgICAgICAgICAgIHtEdGxzU3J0cEtleUFncmVlbWVudDogdHJ1ZX0sXG4gICAgICAgICAgICB7UnRwRGF0YUNoYW5uZWxzOiBmYWxzZX0sXG4gICAgICAgICAgICB7Z29vZ0NwdU92ZXJ1c2VEZXRlY3Rpb246IHRydWV9XG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSBwZWVyXG4gICAgICB0aGlzLl9hZGRDb25uZWN0aW9uSGFuZGxlcnMocGVlcilcbiAgICAgIHAucmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihOQU1FLCBgQ291bGQgbm90IGNyZWF0ZSBhIFJUQ1BlZXJDb25uZWN0aW9uLiBFcnJvcjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIHAucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHRlYXJEb3duICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3RlYXJkb3duXScpXG4gICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLl9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnModGhpcy5fcGVlckNvbm5lY3Rpb24pXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jbG9zZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwZWVyY29ubmVjdGlvbi5jbG9zZV0gZXJyb3I6ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uID0gdW5kZWZpbmVkXG4gIH1cblxuICBjcmVhdGVBbnN3ZXIgKHNkcCkge1xuICAgIGRlYnVnKE5BTUUsICdbY3JlYXRlYW5zd2VyXScpXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcblxuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcClcbiAgICAgIC50aGVuKHRoaXMuX3Jlc3BvbmRlci5vblNEUFN1Y2Nlc3MpXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBFcnJvcihlcnIpXG4gICAgICB9KVxuXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKClcbiAgICAgIC50aGVuKHNlc3Npb25EZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgICAgIC50aGVuKHRoaXMuX3Jlc3BvbmRlci5vblNEUFN1Y2Nlc3MpXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUEVycm9yKGVycilcbiAgICAgICAgICB9KVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNlc3Npb25EZXNjcmlwdGlvbilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZGVmZXJyZWQucmVqZWN0KVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGFkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgaWYgKGlzRW1wdHlDYW5kaWRhdGUoY2FuZGlkYXRlKSkge1xuICAgICAgZGVidWcoTkFNRSwgJ1thZGRpY2VjYW5kaWRhdGVdOjogZW1wdHknKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbYWRkaWNlY2FuZGlkYXRlXScpXG4gICAgICBsZXQgaWNlQ2FuZGlkYXRlID0gbmV3IHdlYnJ0Yy5SVENJY2VDYW5kaWRhdGUoe1xuICAgICAgICBzZHBNTGluZUluZGV4OiBjYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgY2FuZGlkYXRlOiBjYW5kaWRhdGUuY2FuZGlkYXRlXG4gICAgICB9KVxuICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIC8vIG5hZGFcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXJyb3IoTkFNRSwgYEVycm9yIGluIGFkZCBvZiBJQ0UgQ2FuZGlkaWF0ZSArICR7ZXJyfWApXG4gICAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3Vic2NyaXB0aW9uUGVlckhlbHBlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXN1Yi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBuYW1lRnJvbUxldmVsIH0gZnJvbSAnYnJvd3Nlci1idW55YW4nXG5cbmV4cG9ydCBjbGFzcyBSYXdTdHJlYW0ge1xuICB3cml0ZSAocmVjKSB7XG4gICAgY29uc29sZS5sb2coJ1slc10gJXM6ICVzJyxcbiAgICAgIC8vICAgICAgICAgICAgICAgIHJlYy50aW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICByZWMubmFtZSxcbiAgICAgIG5hbWVGcm9tTGV2ZWxbcmVjLmxldmVsXSxcbiAgICAgIHJlYy5tc2dcbiAgICApXG4gIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xvZy9idW55YW4td3JpdGVyLmpzIiwiLyoqXG4gKiBNYWluIGVudHJ5IGZvciBmYWlsb3ZlciBzdXBwb3J0IG9mIGFsbCBwdWJsaXNoZXIgaW1wbGVtZW50YXRpb25zLlxuICovXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEltcGxGYWN0b3J5T3JkZXIgZnJvbSAnLi4vdXRpbC9pbXBsLWZhY3Rvcnktb3JkZXInXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBSVE1QUHVibGlzaGVyIGZyb20gJy4vcmVkNXByby1ydG1wJ1xuaW1wb3J0IFJUQ1B1Ymxpc2hlciBmcm9tICcuL3JlZDVwcm8tcnRjJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgUHVibGlzaFR5cGVzIH0gZnJvbSAnLi4vZW51bS9wdWJsaXNoJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoZXInXG5jb25zdCBwdWJsaXNoRmFjdG9yeSA9IG5ldyBJbXBsRmFjdG9yeU9yZGVyKClcbmNvbnN0IHB1Ymxpc2hlckltcGwgPSAoZnVuY3Rpb24gKCkge1xuICBsZXQgbWFwID0gbmV3IE1hcCgpXG4gIG1hcC5zZXQoUHVibGlzaFR5cGVzLlJUQywgUlRDUHVibGlzaGVyKVxuICBtYXAuc2V0KFB1Ymxpc2hUeXBlcy5SVE1QLCBSVE1QUHVibGlzaGVyKVxuICByZXR1cm4gbWFwXG59KCkpXG5cbmNsYXNzIFJlZDVQcm9QdWJsaXNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYm91bmRCdWJibGVQdWJsaXNoZXJFdmVudCA9IHRoaXMuYnViYmxlUHVibGlzaGVyRXZlbnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX29yZGVyID0gW1xuICAgICAgUHVibGlzaFR5cGVzLlJUQyxcbiAgICAgIFB1Ymxpc2hUeXBlcy5SVE1QXG4gICAgXVxuICB9XG5cbiAgZ2V0UHVibGlzaE9yZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkZXJcbiAgfVxuXG4gIHNldFB1Ymxpc2hPcmRlciAob3JkZXIpIHtcbiAgICAvLyBBbGxvdyBmb3Igc3RyaW5nIHZhbHVlIHRvIGRlZmluZSBzaW5nbGUgaXRlbSBpbiBvcmRlci5cbiAgICBvcmRlciA9IHR5cGVvZiBvcmRlciA9PT0gJ3N0cmluZycgPyBbb3JkZXJdIDogb3JkZXJcblxuICAgIC8vIEZpbHRlciBvdXQgdmFsdWVzIG5vdCBhdmFpbGFibGUgaW4gZW51bWVyYXRpb24gb2YgcGxheWJhY2sgdHlwZXMuXG4gICAgY29uc3QgdCA9IG9yZGVyLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICBsZXQga2V5XG4gICAgICBmb3IgKGtleSBpbiBQdWJsaXNoVHlwZXMpIHtcbiAgICAgICAgaWYgKFB1Ymxpc2hUeXBlc1trZXldLnRvTG93ZXJDYXNlKCkgPT09IGVudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KS5tYXAoZW50cnkgPT4gZW50cnkudG9Mb3dlckNhc2UoKSlcblxuICAgIC8vIERlZmluZSBuZXcgb3JkZXIuXG4gICAgdGhpcy5fb3JkZXIgPSBbLi4ubmV3IFNldCh0KV1cbiAgICBkZWJ1ZyhOQU1FLCBgW29yZGVydXBkYXRlXTogJHt0aGlzLl9vcmRlcn1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzZXRWaWV3IChwdWJsaXNoVmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSBwdWJsaXNoVmlld1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRQdWJsaXNoZXJGcm9tT3JkZXIgKG9yZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHB1Ymxpc2hGYWN0b3J5LmNyZWF0ZShvcmRlciwgcHVibGlzaGVySW1wbCwgb3B0aW9ucywgJ2luaXQnKVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgZGVidWcoTkFNRSwgJ1twdWJsaXNoXScpXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmdldFB1Ymxpc2hlckZyb21PcmRlcih0aGlzLl9vcmRlciwgdGhpcy5fb3B0aW9ucylcbiAgICAgIC50aGVuKHB1Ymxpc2hlciA9PiB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIgPSBwdWJsaXNoZXJcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXcpIHtcbiAgICAgICAgICB0aGlzLl92aWV3LmF0dGFjaFB1Ymxpc2hlcih0aGlzLl9jdXJyZW50UHVibGlzaGVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIub24oJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVB1Ymxpc2hlckV2ZW50KVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwdWJsaXNoZXJyb3JdOiBDb3VsZCBub3QgaW1wbGVtZW50IGEgcHVibGlzaGVyOiAke2Vycn1gKVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRQdWJsaXNoZXIpIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1tzdG9wXTogQ291bGQgbm90IGludm9rZSBzdG9wKCkgb24gdW5kZWZpbmVkIHB1Ymxpc2hlci4nKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KCdBIGN1cnJlbnQgcHVibGlzaGVyIGlzIG5vdCBhdmFpbGFibGUgdG8gaXNzdWUgYSA6c3RvcCgpIGNvbW1hbmQgdG8uJylcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoTkFNRSwgJ1tzdG9wXTogSW52b2tpbmcgc3RvcCBvbiBoZWxkIHB1Ymxpc2hlcicpXG4gICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyLnVucHVibGlzaCgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BzdWNjZXNzXScpXG4gICAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVB1Ymxpc2hlckV2ZW50KVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgYFtzdG9wZXJyb3JdOiAke2Vycn1gKVxuICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50UHVibGlzaGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlUHVibGlzaGVyRXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgYnViYmxlUHVibGlzaGVyRXZlbnQgKHB1Ymxpc2hlckV2ZW50KSB7XG4gICAgdGhpcy50cmlnZ2VyLmNhbGwodGhpcywgcHVibGlzaGVyRXZlbnQpXG4gIH1cblxuICBnZXQgcHVibGlzaFR5cGVzICgpIHtcbiAgICByZXR1cm4gUHVibGlzaFR5cGVzXG4gIH1cblxuICBnZXQgY3VycmVudFB1Ymxpc2hlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXJcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlZDVQcm9QdWJsaXNoZXIsIFJUTVBQdWJsaXNoZXIsIFJUQ1B1Ymxpc2hlciB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvcHVibGlzaGVyL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAqIGFzIGVtYmVkIGZyb20gJy4uL2Vudi9lbWJlZCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlciBmcm9tICcuLi9oZWxwZXIvc2hhcmVkb2JqZWN0LWhlbHBlci1ydG1wJ1xuaW1wb3J0IHsgdG9JbnQgfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IHsgZGVlcENvcHkgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUHVibGlzaGVyU291cmNlSGFuZGxlcidcblxuY29uc3QgY29udmVydERpbWVuc2lvbk9wdGlvbnMgPSAodm8pID0+IHtcbiAgcmV0dXJuIHZvLmV4YWN0IHx8IHZvLmlkZWFsIHx8IHZvLm1heCB8fCB2by5taW4gfHwgdm9cbn1cbmNvbnN0IG1lZGlhQ29uc3RyYWludHNUb0ZsYXNodmFycyA9IChjb25zdHJhaW50cywgZmxhc2h2YXJzKSA9PiB7XG4gIGxldCBmdiA9IGRlZXBDb3B5KGZsYXNodmFycylcbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgZnYudmlkZW8gPSBjb25zdHJhaW50cy52aWRlb1xuICB9XG4gIGVsc2Uge1xuICAgIGxldCBrZXlcbiAgICBmb3IgKGtleSBpbiBjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgZnZba2V5XSA9IGNvbnZlcnREaW1lbnNpb25PcHRpb25zKGNvbnN0cmFpbnRzLnZpZGVvW2tleV0pXG4gICAgfVxuICB9XG4gIGZ2LmF1ZGlvID0gY29uc3RyYWludHMuYXVkaW9cbiAgcmV0dXJuIGZ2XG59XG5cbmNsYXNzIFB1Ymxpc2hlclNvdXJjZUhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yICh2aWRlbywgdHlwZSwgc29SZXNwb25kZXIgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnZpZGVvID0gdmlkZW9cbiAgICB0aGlzLmNsb25lID0gdGhpcy52aWRlby5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlciA9IHRoaXMudmlkZW8ucGFyZW50Tm9kZVxuICAgIHRoaXMucHVibGlzaGVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9zd2ZJZCA9IG51bGxcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvUmVzcG9uZGVyID0gc29SZXNwb25kZXIgfHwgbmV3IFJUTVBTaGFyZWRPYmplY3RIYW5kbGVyKClcbiAgfVxuXG4gIGdldEVtYmVkT3BlcmF0aW9uICgpIHtcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2VtYmVkRnV0dXJlKVxuICAgIHJldHVybiB0aGlzLl9lbWJlZEZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBjbGVhblVwICgpIHtcbiAgICAvLyBSZXR1cm4gdG8gcHJpb3IgRE9NIG1hbmlwdWxhdGlvbi5cbiAgICB0aGlzLnZpZGVvLnJlbW92ZSgpXG4gICAgdGhpcy52aWRlbyA9IHRoaXMuY2xvbmUuY2xvbmVOb2RlKHRydWUpXG4gICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlbylcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgYWRkU291cmNlIChzd2ZJZCwgb3B0aW9ucywgc3dmVXJsID0gbnVsbCwgbWluRmxhc2hWZXJzaW9uID0gbnVsbCkge1xuICAgIGRlYnVnKE5BTUUsICdbYWRkc291cmNlXScpXG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICB0aGlzLl9zd2ZJZCA9IHN3ZklkO1xuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fZW1iZWRGdXR1cmUpXG4gICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl9lbWJlZEZ1dHVyZVxuICAgIG9wdGlvbnMuc3dmID0gc3dmVXJsIHx8IG9wdGlvbnMuc3dmXG4gICAgb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gPSBtaW5GbGFzaFZlcnNpb24gfHwgb3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICBlbWJlZC5kZWZpbmVFbWJlZEVsZW1lbnQodGhpcy52aWRlbywgdGhpcy5ob2xkZXIpXG4gICAgICAudGhlbihlbGVtZW50SWQgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2VsZW1lbnQ6Y29tcGxldGVdJylcbiAgICAgICAgbGV0IGZsYXNodmFycyA9IHtcbiAgICAgICAgICBidWZmZXI6IG9wdGlvbnMuYnVmZmVyICE9IG51bGwgPyBvcHRpb25zLmJ1ZmZlciA6IDEsXG4gICAgICAgICAgc3RyZWFtTW9kZTogb3B0aW9ucy5zdHJlYW1Nb2RlLFxuICAgICAgICAgIHN0cmVhbU5hbWU6IG9wdGlvbnMuc3RyZWFtTmFtZSxcbiAgICAgICAgICBhcHBOYW1lOiBvcHRpb25zLmFwcCxcbiAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3RcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgZmxhc2h2YXJzLnJvb21OYW1lID0gb3B0aW9ucy5jb250ZXh0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW1iZWRXaWR0aCA9PT0gJzEwMCUnIHx8IG9wdGlvbnMuZW1iZWRIZWlnaHQgPT09ICcxMDAlJykge1xuICAgICAgICAgIGZsYXNodmFycy5hdXRvc2l6ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuY29ubmVjdGlvblBhcmFtcyA9IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMpKVxuICAgICAgICB9XG4gICAgICAgIGZsYXNodmFycyA9IG1lZGlhQ29uc3RyYWludHNUb0ZsYXNodmFycyhvcHRpb25zLm1lZGlhQ29uc3RyYWludHMsIGZsYXNodmFycylcbiAgICAgICAgcmV0dXJuIGVtYmVkLmVtYmVkU3dmT2JqZWN0KHN3ZklkLCBvcHRpb25zLCBmbGFzaHZhcnMsIGVudmlyb25tZW50LmdldFN3Zk9iamVjdCgpLCBlbGVtZW50SWQpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2VtYmVkOmNvbXBsZXRlXScpXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2VsZilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IGRlZmVycmVkLnJlamVjdChlcnIpKVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBjb25uZWN0IChwdWJsaXNoT3B0aW9ucykge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdF0nKVxuICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fc3dmSWQpXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5jb25uZWN0KHB1Ymxpc2hPcHRpb25zKVxuICAgICAgdGhpcy5fc29SZXNwb25kZXIuY29ubmVjdCh0aGlzLl9zd2ZJZClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3YXJuKE5BTUUsICdDb3VsZCBub3QgZGV0ZXJtaW5lIGVtYmVkZGVkIGVsZW1lbnQgd2l0aCBzd2YgaWQ6ICcgKyB0aGlzLl9zd2ZJZCArICcuJylcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3RdJylcbiAgICB0cnkge1xuICAgICAgLy8gTm8gaW52b2NhYmxlIEFQSSBmb3IgY3VzdG9tIGxpdmUgZmxhc2ggcHVibGlzaGVyIGZyb20gUmVkNSBQcm8gYXQgdGhlIHRpbWUuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gICAgdGhpcy5jbGVhblVwKClcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5kaXNjb25uZWN0KClcbiAgfVxuXG4gIHNlbmQgKG1ldGhvZE5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBlbCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHRoaXMuX3N3ZklkKVxuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2VuZChtZXRob2ROYW1lLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmFkZFJlc3BvbnNlSGFuZGxlcihoYW5kbGVyKVxuICB9XG5cbiAgcmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIucmVtb3ZlUmVzcG9uc2VIYW5kbGVyKGhhbmRsZXIpXG4gIH1cblxuICBzZW5kVG9TaGFyZWRPYmplY3QgKG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuc2VuZFRvU2hhcmVkT2JqZWN0KG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKVxuICB9XG5cbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5zZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdChuYW1lLCBrZXksIHZhbHVlKVxuICB9XG5cbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuZ2V0UmVtb3RlU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gIH1cblxuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5jb25uZWN0VG9TaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIGNsb3NlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuY2xvc2VTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIHNldE1lZGlhUXVhbGl0eSAocXVhbGl0eSkge1xuICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fc3dmSWQpXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAocXVhbGl0eS52aWRlbyAmJiB0eXBlb2YgcXVhbGl0eS52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0IHcgPSAhaXNOYU4ocXVhbGl0eS52aWRlby53aWR0aCkgPyB0b0ludChxdWFsaXR5LnZpZGVvLndpZHRoKSA6IE51bWJlci5pc05hTjtcbiAgICAgICAgY29uc3QgaCA9ICFpc05hTihxdWFsaXR5LnZpZGVvLmhlaWdodCkgPyB0b0ludChxdWFsaXR5LnZpZGVvLmhlaWdodCkgOiBOdW1iZXIuaXNOYU47XG4gICAgICAgIGVsLnVwZGF0ZVJlc29sdXRpb24odywgaClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXJUeXBlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQdWJsaXNoZXJTb3VyY2VIYW5kbGVyXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9wdWJsaXNoZXIvcHViLXNvdXJjZS1oYW5kbGVyLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0ICogYXMgd2VicnRjIGZyb20gJy4uL2FkYXB0ZXIvd2VicnRjJ1xuaW1wb3J0ICogYXMgd2Vic29ja2V0IGZyb20gJy4uL2FkYXB0ZXIvd2Vic29ja2V0J1xuaW1wb3J0IFB1Ymxpc2hlclNvY2tldEhlbHBlciBmcm9tICcuLi9oZWxwZXIvc29ja2V0LWhlbHBlci1wdWInXG5pbXBvcnQgUHVibGlzaGVyUGVlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvd2VicnRjLWhlbHBlci1wdWInXG5pbXBvcnQgUHVibGlzaFZpZXcgZnJvbSAnLi4vdmlldy9wdWJsaXNoJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFB1Ymxpc2hNb2RlVHlwZXMgfSBmcm9tICcuLi9lbnVtL3B1Ymxpc2gnXG5pbXBvcnQgeyBQdWJsaXNoVHlwZXMgfSBmcm9tICcuLi9lbnVtL3B1Ymxpc2gnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UsIEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFB1Ymxpc2hlckV2ZW50VHlwZXMsIFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFJUQ01lZGlhQ29uc3RyYWludCB9IGZyb20gJy4vY29uc3RyYWludCdcbmltcG9ydCB7IHJ0Y1NvY2tldEVuZHBvaW50RnJvbU9wdGlvbnMgYXMgZW5kcG9pbnRGcm9tT3B0aW9ucyB9IGZyb20gJy4uL3V0aWwvdXJsLWVuZHBvaW50J1xuaW1wb3J0IHsgZGVidWcgYXMgZGVidWdMb2cgfSBmcm9tICcuLi9sb2cnXG5pbXBvcnQgeyBlcnJvciBhcyBlcnJvckxvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IHdhcm4gYXMgd2FybkxvZyB9IGZyb20gJy4uL2xvZydcblxuLy8gRGVmYXVsdCB0byBzZWN1cmUgc2V0dGluZ3MuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICd3c3MnLFxuICBwb3J0OiA4MDgzLFxuICBhcHA6ICdsaXZlJyxcbiAgc3RyZWFtTW9kZTogUHVibGlzaE1vZGVUeXBlcy5MSVZFLFxuICBtZWRpYUVsZW1lbnRJZDogJ3JlZDVwcm8tcHVibGlzaGVyJyxcbiAgYmFuZHdpZHRoOiB7XG4gICAgYXVkaW86IDU2LFxuICAgIHZpZGVvOiA1MTJcbiAgfSxcbiAgbWVkaWFDb25zdHJhaW50czogbmV3IFJUQ01lZGlhQ29uc3RyYWludCgpLFxuICBvbkdldFVzZXJNZWRpYTogdW5kZWZpbmVkXG59XG5cbmNvbnN0IHB1YlN0YXJ0UmVnZXggPSAvKC4qKSBzdGFydGluZy9pXG5jb25zdCBwdWJTdG9wUmVnZXggPSAvKC4qKSBzdG9wcGluZy9pXG5jb25zdCBOQU1FID0gJ1JUQ1B1Ymxpc2hlcidcbmNvbnN0IGRlYnVnID0gKG1lc3NhZ2UpID0+IHtcbiAgZGVidWdMb2coTkFNRSwgbWVzc2FnZSlcbn1cbmNvbnN0IHdhcm4gPSAobWVzc2FnZSkgPT4ge1xuICB3YXJuTG9nKE5BTUUsIG1lc3NhZ2UpXG59XG5jb25zdCBlcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gIGVycm9yTG9nKE5BTUUsIG1lc3NhZ2UpXG59XG5cbmNsYXNzIFJUQ1B1Ymxpc2hlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJIZWxwZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5fc3RyZWFtRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9ndW0gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5vbkdldFVzZXJNZWRpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWJ1ZygnUmVxdWVzdGluZyBnVU0gZnJvbSB1c2VyLWRlZmluZWQgY29uZmlndXJhdGlvbjpvbkdldFVzZXJNZWRpYS4nKVxuICAgICAgb3B0aW9ucy5vbkdldFVzZXJNZWRpYSgpXG4gICAgICAgIC50aGVuKG1lZGlhID0+IHtcbiAgICAgICAgICB0aGlzLl9zdHJlYW1GdXR1cmUucmVzb2x2ZShtZWRpYSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZXJyb3IoYENvdWxkIG5vdCByZXNvbHZlIE1lZGlhQXNzZXQgZnJvbSBwcm92aWRlZCBnVU0uIEVycm9yIC0gJHtlcnJ9YClcbiAgICAgICAgICB0aGlzLl9zdHJlYW1GdXR1cmUucmVqZWN0KGVycilcbiAgICAgICAgfSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkZWJ1ZyhgUmVxdWVzdGluZyBnVU0gdXNpbmcgbWVkaWFDb25zdHJhaW50czogJHtKU09OLnN0cmluZ2lmeShvcHRpb25zLm1lZGlhQ29uc3RyYWludHMsIG51bGwsIDIpfWApXG4gICAgICB0aGlzLl9wZWVySGVscGVyLmdldFVzZXJNZWRpYShvcHRpb25zLm1lZGlhQ29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgZGVidWcoYEZvdW5kIHZhbGlkIGNvbnN0cmFpbnRzOiAke0pTT04uc3RyaW5naWZ5KHJlcy5jb25zdHJhaW50cywgbnVsbCwgMil9YClcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuRElNRU5TSU9OX0NIQU5HRSwgdGhpcywgcmVzLmNvbnN0cmFpbnRzKSlcbiAgICAgICAgICB0aGlzLl9zdHJlYW1GdXR1cmUucmVzb2x2ZShyZXMubWVkaWEpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWogPT4ge1xuICAgICAgICAgIGRlYnVnKGBDb3VsZCBub3QgZmluZCB2YWxpZCBjb25zdHJhaW50IHJlc29sdXRpb25zIGZyb206ICR7SlNPTi5zdHJpbmdpZnkocmVqLmNvbnN0cmFpbnRzLCBudWxsLCAyKX1gKVxuICAgICAgICAgIGVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSBNZWRpYUFzc2V0IGZyb20gcHJvdmlkZWQgbWVkaWFDb25zdHJhaW50cy4gRXJyb3IgLSAke3Jlai5lcnJvcn1gKVxuICAgICAgICAgIGRlYnVnKGBBdHRlbXB0aW5nIHRvIGZpbmQgcmVzb2x1dGlvbnMgZnJvbSBvcmlnaW5hbCBwcm92aWRlZCBjb25zdHJhaW50czogJHtKU09OLnN0cmluZ2lmeShyZWouY29uc3RyYWludHMsIG51bGwsIDIpfWApXG4gICAgICAgICAgLy8gYWxsb3dpbmcgdG8gdHJ5IG9yaWdpbmFsIGNvbnN0cmFpbnQgcmVxdWVzdGVkLlxuICAgICAgICAgIG9wdGlvbnMub25HZXRVc2VyTWVkaWEgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVlckhlbHBlci5mb3JjZVVzZXJNZWRpYShyZWouY29uc3RyYWludHMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2d1bShvcHRpb25zKVxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIF9vbk1lZGlhU3RyZWFtUmVjZWl2ZWQgKG1lZGlhU3RyZWFtKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW0gPSBtZWRpYVN0cmVhbVxuICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5NRURJQV9TVFJFQU1fQVZBSUxBQkxFLCB0aGlzLCBtZWRpYVN0cmVhbSkpXG4gICAgaWYgKHRoaXMuX3ZpZXcpIHtcbiAgICAgIHRoaXMuX3ZpZXcucHJldmlldyh0aGlzLl9tZWRpYVN0cmVhbSlcbiAgICB9XG4gIH1cblxuICBfZ2V0TWVkaWFTdHJlYW0gKCkge1xuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3N0cmVhbUZ1dHVyZSlcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIF9nZXRUcmlja2xlRW5kICgpIHtcbiAgICByZXR1cm4gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSlcbiAgfVxuXG4gIF9zZXRWaWV3SWZOb3RFeGlzdCAoY3VycmVudFZpZXcsIG1lZGlhRWxlbWVudElkID0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWaWV3ID09PSAndW5kZWZpbmVkJyAmJiBtZWRpYUVsZW1lbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IFB1Ymxpc2hWaWV3KG1lZGlhRWxlbWVudElkKVxuICAgICAgICB2aWV3LmF0dGFjaFB1Ymxpc2hlcih0aGlzKVxuICAgICAgfVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCF3ZWJydGMuaXNTdXBwb3J0ZWQoKSB8fCAhd2Vic29ja2V0LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdCgnQ2Fubm90IGNyZWF0ZSBXZWJSVEMgcGxheWJhY2sgaW5zdGFuY2UuIFlvdXIgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBXZWJSVEMgYW5kL29yIFdlYlNvY2tldHMuJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICB0aGlzLl9wZWVySGVscGVyID0gbmV3IFB1Ymxpc2hlclBlZXJIZWxwZXIodGhpcylcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IG5ldyBQdWJsaXNoZXJTb2NrZXRIZWxwZXIodGhpcylcbiAgICAgIHRoaXMuX2dldE1lZGlhU3RyZWFtKClcbiAgICAgICAgLnRoZW4odGhpcy5fb25NZWRpYVN0cmVhbVJlY2VpdmVkLmJpbmQodGhpcykpXG4gICAgICB0aGlzLl9ndW0ob3B0aW9ucylcbiAgICAgIC8vIGF1dG8gcHJldmlldy5cbiAgICAgIHRoaXMuX3NldFZpZXdJZk5vdEV4aXN0KHRoaXMuX3ZpZXcsIHRoaXMuX29wdGlvbnMubWVkaWFFbGVtZW50SWQpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICBpZiAodGhpcy5fbWVkaWFTdHJlYW0gJiYgdGhpcy5fdmlldykge1xuICAgICAgdGhpcy5fdmlldy5wcmV2aWV3KHRoaXMuX21lZGlhU3RyZWFtKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXR0YWNoU3RyZWFtIChtZWRpYSkge1xuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3N0cmVhbUZ1dHVyZSlcbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUucmVzb2x2ZShtZWRpYSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZGV0YWNoU3RyZWFtICgpIHtcbiAgICBpZiAodGhpcy5fbWVkaWFTdHJlYW0gJiYgdGhpcy5fbWVkaWFTdHJlYW0uc3RvcCkge1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW0uc3RvcCgpXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX21lZGlhU3RyZWFtICYmIHRoaXMuX21lZGlhU3RyZWFtLmdldFRyYWNrcykge1xuICAgICAgY29uc3QgdHJhY2tzID0gdGhpcy5fbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClcbiAgICAgIGxldCB0cmFja0xlbmd0aCA9IHRyYWNrcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoLS10cmFja0xlbmd0aCA+IC0xKSB7XG4gICAgICAgIGlmICh0cmFja3NbdHJhY2tMZW5ndGhdLnN0b3ApIHtcbiAgICAgICAgICB0cmFja3NbdHJhY2tMZW5ndGhdLnN0b3AoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlcXVlc3RBdmFpbGFiaWxpdHkgKHN0cmVhbU5hbWUsIHR5cGUpIHtcbiAgICBkZWJ1ZygnW3JlcXVlc3RhdmFpbGFiaWxpdHldJylcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9hdmFpbGFibGVGdXR1cmUpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmV0dXJucyAtPiBvblN0cmVhbShVbilBdmFpbGFibGVcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBpc0F2YWlsYWJsZTogc3RyZWFtTmFtZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBidW5kbGU6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmxlRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIGNyZWF0ZVBlZXJDb25uZWN0aW9uIChpY2VTZXJ2ZXJzKSB7XG4gICAgZGVidWcoJ1tjcmVhdGVwZWVlcl0nKVxuICAgIHRoaXMuX3BlZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fcGVlckZ1dHVyZSlcbiAgICB0aGlzLl9wZWVySGVscGVyLnNldFVwKGljZVNlcnZlcnMsIHRoaXMuX3BlZXJGdXR1cmUsIHRoaXMuX29wdGlvbnMucnRjcE11eFBvbGljeSlcbiAgICByZXR1cm4gdGhpcy5fcGVlckZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBjcmVhdGVPZmZlciAoYmFuZHdpZHRoID0gbnVsbCkge1xuICAgIGRlYnVnKCdbY3JlYXRlb2ZmZXJdJylcbiAgICB0aGlzLl9vZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29mZmVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fb2ZmZXJGdXR1cmUpXG4gICAgdGhpcy5fcGVlckhlbHBlci5jcmVhdGVPZmZlcihiYW5kd2lkdGgsIHRoaXMuX29mZmVyRnV0dXJlKVxuICAgIHJldHVybiB0aGlzLl9vZmZlckZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbiAoc2RwKSB7XG4gICAgZGVidWcoJ1tzZXRyZW1vdGVkZXNjcmlwdGlvbl0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVySGVscGVyLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcClcbiAgfVxuXG4gIHNlbmRPZmZlciAoc2RwLCBzdHJlYW1OYW1lKSB7XG4gICAgZGVidWcoJ1tzZW5kb2ZmZXJdJylcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9zZW5kT2ZmRnV0dXJlKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIGhhbmRsZU9mZmVyOiBzdHJlYW1OYW1lLFxuICAgICAgZGF0YToge1xuICAgICAgICBzZHA6IHNkcFxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuX3NlbmRPZmZlckZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBzZW5kQ2FuZGlkYXRlIChjYW5kaWRhdGUsIHN0cmVhbU5hbWUpIHtcbiAgICBkZWJ1ZygnW3NlbmRjYW5kaWRhdGVdJylcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVDYW5kaWRhdGU6IHN0cmVhbU5hbWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJlcXVlc3RQdWJsaXNoIChzdHJlYW1OYW1lLCBzdHJlYW1Nb2RlKSB7XG4gICAgZGVidWcoJ1tyZXF1ZXN0cHVibGlzaF0nKVxuICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fcHVibGlzaEZ1dHVyZSlcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBwdWJsaXNoOiBzdHJlYW1OYW1lLFxuICAgICAgbW9kZTogc3RyZWFtTW9kZVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuX3B1Ymxpc2hGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgcmVxdWVzdFVucHVibGlzaCAoc3RyZWFtTmFtZSkge1xuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3VucHVibGlzaEZ1dHVyZSlcbiAgICAvLyBJZiB3ZSBnZXQgYSBmYWxzZSByZXNwb25zZSBmcm9tIHR5cmluZyB0byBzZW5kIGEgY2xvc2UgUE9TVCxcbiAgICAvLyAgaXQgbWVhbnMgdGhhdCB0aGUgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IGFub3RoZXIgaW1wZXR1cyAtXG4gICAgLy8gIG1vc3QgbGlrbGV5IGxvc3Mgb2YgbmV0d29yayBvciBzZXJ2ZXIgZmFpbHVyZS5cbiAgICBpZiAoIXRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgICAgICB1bnB1Ymxpc2g6IHN0cmVhbU5hbWVcbiAgICAgICAgfSkpIHtcbiAgICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZS5yZXNvbHZlKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VucHVibGlzaEZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBwcmV2aWV3ICgpIHtcbiAgICBkZWJ1ZygnW3ByZXZpZXddJylcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgcmVzKHRoaXMpXG4gICAgfSlcbiAgICB0aGlzLl9zZXRWaWV3SWZOb3RFeGlzdCh0aGlzLl92aWV3LCB0aGlzLl9vcHRpb25zLm1lZGlhRWxlbWVudElkKVxuICAgIHJldHVybiBwXG4gIH1cblxuICBwdWJsaXNoIChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHtcbiAgICBkZWJ1ZygnW3B1Ymxpc2hdJylcbiAgICB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUgPSBzdHJlYW1OYW1lIHx8IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHNvY2tldFByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBzb2NrZXR1cmwgPSBlbmRwb2ludEZyb21PcHRpb25zKHRoaXMuX29wdGlvbnMsIHtcbiAgICAgIGlkOiB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICB9KVxuICAgIHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUgPSB0aGlzLl9nZXRUcmlja2xlRW5kKClcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIuc2V0VXAoc29ja2V0dXJsLCBzb2NrZXRQcm9taXNlKVxuLy8gMC4gRXN0YWJsaXNoIHNvY2tldCBjb25uZWN0aW9uLlxuICAgIHNvY2tldFByb21pc2UucHJvbWlzZVxuLy8gMS4gV2FpdCBmb3Igc3RyZWFtIGF0dGFjaFxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUywgdGhpcykpXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRNZWRpYVN0cmVhbSgpXG4gICAgICB9KVxuLy8gMi4gUmVxdWVzdCBhdmFpbGFibGUgc3RyZWFtIHRvIHB1Ymxpc2ggb25cbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEF2YWlsYWJpbGl0eSh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtVHlwZSlcbiAgICAgIH0pXG4vLyAzLiBDcmVhdGUgUGVlciBDb25uZWN0aW9uXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uKHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgICAgIH0pXG4vLyA0LiBNYWtlIE9mZmVyIG9uIFBlZXIgQ29ubmVjdGlvblxuICAgICAgLnRoZW4oY29ubmVjdGlvbiA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uYWRkU3RyZWFtKHRoaXMuX21lZGlhU3RyZWFtKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRSwgdGhpcywgY29ubmVjdGlvbikpXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9mZmVyKHRoaXMuX29wdGlvbnMuYmFuZHdpZHRoKVxuICAgICAgfSlcbi8vIDUuIFNlbmQgT2ZmZXJcbiAgICAgIC50aGVuKHNlc3Npb25EZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5PRkZFUl9TVEFSVCwgdGhpcywgc2Vzc2lvbkRlc2NyaXB0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE9mZmVyKHNlc3Npb25EZXNjcmlwdGlvbiwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKVxuICAgICAgfSlcbi8vIDYuIFNldCB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiByZW1vdGVseVxuICAgICAgLnRoZW4oc2RwID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwLnNkcClcbiAgICAgIH0pXG4vLyA3LiBXYWl0IHVudGlsIGljZSB0cmlja2xlIGVuZFxuICAgICAgLnRoZW4oc2RwID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLk9GRkVSX0VORCwgdGhpcywgc2RwKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyaWNrbGVFbmQoKS5wcm9taXNlXG4gICAgICB9KVxuLy8gOC4gUmVxdWVzdCB0byBwdWJsaXNoIHN0cmVhbVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuSUNFX1RSSUNLTEVfQ09NUExFVEUsIHRoaXMpKVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UHVibGlzaCh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtTW9kZSlcbiAgICAgIH0pXG4vLyA5LiBSZXN1bHRzIGluIHNvY2tldCBtZXNzYWdlIG9mIHB1Ymxpc2ggKHNlZSA6b25QdWJsaXNoU3RhdHVzKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBwLnJlc29sdmUodGhpcylcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfU1RBUlQsIHRoaXMpKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgcC5yZWplY3QoZXJyb3IpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMsIGVycm9yKSlcbiAgICAgIH0pXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHVucHVibGlzaCAoKSB7XG4gICAgZGVidWcoJ1t1bnB1Ymxpc2hdJylcbiAgICBjb25zdCBjbGVhckhlbHBlcnMgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0SGVscGVyKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldEhlbHBlci50ZWFyRG93bigpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGVlckhlbHBlcikge1xuICAgICAgICB0aGlzLl9wZWVySGVscGVyLnRlYXJEb3duKClcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICBjb25zdCBmID0gdGhpcy5yZXF1ZXN0VW5wdWJsaXNoKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSlcbiAgICBmLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgICBjbGVhckhlbHBlcnMoKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlVOUFVCTElTSF9TVUNDRVNTLCB0aGlzKSlcbiAgICB9KVxuICAgIHJldHVybiBmXG4gIH1cblxuICBtdXRlICgpIHtcbiAgICAvLyBiYWNrd2FyZCBjb21hdGliaWxpdHkgLSB0byBiZSBkZXByZWNhdGVkLlxuICAgIHRoaXMubXV0ZUF1ZGlvKClcbiAgfVxuXG4gIHVubXV0ZSAoKSB7XG4gICAgLy8gYmFja3dhcmQgY29tYXRpYmlsaXR5IC0gdG8gYmUgZGVwcmVjYXRlZC5cbiAgICB0aGlzLnVubXV0ZUF1ZGlvKClcbiAgfVxuXG4gIG11dGVBdWRpbyAoKSB7XG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgbXV0ZToge1xuICAgICAgICBtdXRlQXVkaW86IHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdW5tdXRlQXVkaW8gKCkge1xuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZUF1ZGlvOiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBtdXRlVmlkZW8gKCkge1xuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIG11dGU6IHtcbiAgICAgICAgbXV0ZVZpZGVvOiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHVubXV0ZVZpZGVvICgpIHtcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIG11dGVWaWRlbzogZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZCAobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIHNlbmQ6IHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2ROYW1lLFxuICAgICAgICBkYXRhOiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSA/IEpTT04ucGFyc2UoZGF0YSkgOiBkYXRhXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uU3RyZWFtQXZhaWxhYmxlIChyZWNlaXB0KSB7XG4gICAgZGVidWcoJ1tvbnN0cmVhbWF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9hdmFpbGFibGVGdXR1cmUpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlLnJlamVjdChgU3RyZWFtIHdpdGggbmFtZSAke3RoaXMuX29wdGlvbnMuc3RyZWFtTmFtZX0gYWxyZWFkeSBoYXMgYSBicm9hZGNhc3Qgc2Vzc2lvbi5gKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0lOVkFMSURfTkFNRSwgdGhpcykpXG4gIH1cblxuICBvblN0cmVhbVVuYXZhaWxhYmxlIChyZWNlaXB0KSB7XG4gICAgLy8gQmVpbmcgdW5hdmFpbGFibGUsIGlzIGEgZ29vZCB0aGluZyBmb3IgYWxsb3dpbmcgdG8gcHVibGlzaCB1c2luZyBgb3B0aW9ucy5zdHJlYW1OYW1lYFxuICAgIGRlYnVnKGBTdHJlYW0gJHt0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWV9IGRvZXMgbm90IGV4aXN0LmApXG4gICAgZGVidWcoJ1tvbnN0cmVhbXVuYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSlcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUucmVzb2x2ZSh0cnVlKVxuICB9XG5cbiAgb25Tb2NrZXRNZXNzYWdlRXJyb3IgKG1lc3NhZ2UsIGRldGFpbCA9IG51bGwpIHtcbiAgICBlcnJvcihgRXJyb3IgaW4gc3RyZWFtIHBsYXliYWNrOiAke21lc3NhZ2V9LlxcbltPcHRpb25hbCBkZXRhaWxdOiAke2RldGFpbH1gKVxuICAgIGlmICh0aGlzLl9wdWJsaXNoRnV0dXJlKSB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9GQUlMLCB0aGlzKSlcbiAgICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUucmVqZWN0KG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgb25Tb2NrZXRDbG9zZSAoY2xvc2VFdmVudCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zb2NrZXRjbG9zZV0nKVxuICAgIGlmICh0aGlzLl9wZWVySGVscGVyKSB7XG4gICAgICB0aGlzLl9wZWVySGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RJT05fQ0xPU0VELCB0aGlzLCBjbG9zZUV2ZW50KSlcbiAgfVxuXG4gIG9uUGVlckNvbm5lY3Rpb25DbG9zZSAoZXZlbnQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29ucGVlcmNvbm5lY3Rpb25jbG9zZV0nKVxuICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIHRoaXMub25Tb2NrZXRDbG9zZShldmVudClcbiAgfVxuXG4gIG9uU0RQU3VjY2VzcyAocmVjZWlwdCkge1xuICAgIGxldCBpbmZvID0gcmVjZWlwdCA/ICc6ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSA6ICcnXG4gICAgZGVidWcoYFtvbnNkcHN1Y2Nlc3NdJHtpbmZvfWApXG4gIH1cblxuICBvblNEUEVycm9yIChyZWNlaXB0KSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfRkFJTCwgdGhpcykpXG4gICAgbGV0IGVycm9yID0gcmVjZWlwdCA/ICc6ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSA6ICcnXG4gICAgZXJyb3IoYFtvbnNkcGVycm9yXSR7ZXJyb3J9YClcbiAgfVxuXG4gIG9uU0RQQW5zd2VyIChzZHApIHtcbiAgICBkZWJ1ZygnW3NkcGFuc3dlcl06OiAnICsgSlNPTi5zdHJpbmdpZnkoc2RwLCBudWxsLCAyKSlcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9zZW5kT2ZmZXJGdXR1cmUpXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlLnJlc29sdmUoc2RwKVxuICB9XG5cbiAgb25BZGRJY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKCdbYWRkaWNlY2FuZGlkYXRlXScpXG4gICAgdGhpcy5fcGVlckhlbHBlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWJ1ZygnW2FkZGljZWNhbmRpZGF0ZTpzdWNjZXNzXScpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHdhcm4oYFthZGRpY2VjYW5kaWRhdGU6ZXJyb3JdIC0gJHtlcnJ9YClcbiAgICAgIH0pXG4gIH1cblxuICBvbkljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgZGVidWcoJ1tpY2VjYW5kaWRhdGV0cmlja2xlXScpXG4gICAgdGhpcy5zZW5kQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKVxuICB9XG5cbiAgb25JY2VDYW5kaWRhdGVUcmlja2xlRW5kICgpIHtcbiAgICBkZWJ1ZygnW2ljZWNhbmRpZGF0ZXRyaWNrbGU6ZW5kXScpXG4gIH1cblxuICBvblNvY2tldEljZUNhbmRpZGF0ZUVuZCAoKSB7XG4gICAgZGVidWcoJ1tzb2NrZXRpY2VjYW5kaWRhdGU6ZW5kXScpXG4gICAgdGhpcy5fZ2V0VHJpY2tsZUVuZCgpLnJlc29sdmUoKVxuICAgIC8vIHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIG9uUHVibGlzaGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICBkZWJ1ZygnW3B1Ymxpc2hlcnN0YXR1c10gLSAnICsgSlNPTi5zdHJpbmdpZnkoc3RhdHVzLCBudWxsLCAyKSlcbiAgICBjb25zdCBzdG9wUmVzdWx0ID0gcHViU3RvcFJlZ2V4LmV4ZWMoc3RhdHVzLm1lc3NhZ2UpXG4gICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBwdWJTdGFydFJlZ2V4LmV4ZWMoc3RhdHVzLm1lc3NhZ2UpXG4gICAgaWYgKHN0b3BSZXN1bHQgJiYgc3RvcFJlc3VsdFsxXSA9PT0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKSB7XG4gICAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUucmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChzdGFydFJlc3VsdCAmJiBzdGFydFJlc3VsdFsxXSA9PT0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKSB7XG4gICAgICB0aGlzLl9wdWJsaXNoRnV0dXJlLnJlc29sdmUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKCdQdWJsaXNoZXIgc3RhdHVzIHJlY2VpdmVkLCBidXQgY291bGQgbm90IGhhbmRsZS4nKVxuICAgIH1cbiAgfVxuXG4gIG92ZXJsYXlPcHRpb25zIChuZXdPcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gIH1cblxuICBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SGVscGVyXG4gIH1cblxuICBnZXRQZWVyQ29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJIZWxwZXIgPyB0aGlzLl9wZWVySGVscGVyLmNvbm5lY3Rpb24gOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldE1lZGlhU3RyZWFtICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1cbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gUHVibGlzaFR5cGVzLlJUQy50b1VwcGVyQ2FzZSgpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVENQdWJsaXNoZXJcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3B1Ymxpc2hlci9yZWQ1cHJvLXJ0Yy5qcyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBQdWJsaXNoZXJTb3VyY2VIYW5kbGVyIGZyb20gJy4vcHViLXNvdXJjZS1oYW5kbGVyJ1xuaW1wb3J0IFB1Ymxpc2hWaWV3IGZyb20gJy4uL3ZpZXcvcHVibGlzaCdcbmltcG9ydCB7IFB1Ymxpc2hlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBQdWJsaXNoVHlwZXMgfSBmcm9tICcuLi9lbnVtL3B1Ymxpc2gnXG5pbXBvcnQgeyBQdWJsaXNoZXJFdmVudFR5cGVzLCBSVE1QUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgUlRNUE1lZGlhQ29uc3RyYWludCB9IGZyb20gJy4vY29uc3RyYWludCdcbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSVE1QUHVibGlzaGVyJ1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAncnRtcCcsXG4gIHBvcnQ6IDE5MzUsXG4gIHN0cmVhbU1vZGU6ICdsaXZlJyxcbiAgbWVkaWFFbGVtZW50SWQ6ICdyZWQ1cHJvLXB1Ymxpc2hlcicsXG4gIGVtYmVkV2lkdGg6ICcxMDAlJywgLy8gRE9NIGRpc3BsYXkgc3R5bGVcbiAgZW1iZWRIZWlnaHQ6ICcxMDAlJywgLy8gRE9NIGRpc3BsYXkgc3R5bGVcbiAgbWluRmxhc2hWZXJzaW9uOiAnMTAuMC4wJyxcbiAgc3dmOiAnbGliL3JlZDVwcm8vcmVkNXByby1wdWJsaXNoZXIuc3dmJyxcbiAgc3dmb2JqZWN0VVJMOiAnbGliL3N3Zm9iamVjdC9zd2ZvYmplY3QuanMnLFxuICBwcm9kdWN0SW5zdGFsbFVSTDogJ2xpYi9zd2ZvYmplY3QvcGxheWVyUHJvZHVjdEluc3RhbGwuc3dmJyxcbiAgbWVkaWFDb25zdHJhaW50czogbmV3IFJUTVBNZWRpYUNvbnN0cmFpbnQoKVxufVxuXG5jbGFzcyBSVE1QUHVibGlzaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2VsZW1lbnRJZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2Nvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9zZXRWaWV3SWZOb3RFeGlzdCAoY3VycmVudFZpZXcsIG1lZGlhRWxlbWVudElkID0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWaWV3ID09PSAndW5kZWZpbmVkJyAmJiBtZWRpYUVsZW1lbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IFB1Ymxpc2hWaWV3KG1lZGlhRWxlbWVudElkKVxuICAgICAgICB2aWV3LmF0dGFjaFB1Ymxpc2hlcih0aGlzKVxuICAgICAgfVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gfHwgZGVmYXVsdE9wdGlvbnMubWluRmxhc2hWZXJzaW9uXG4gICAgaWYgKCFlbnZpcm9ubWVudC5zdXBwb3J0c0ZsYXNoVmVyc2lvbih2ZXJzaW9uKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgcmVzb2x2ZSBSVE1QUHVibGlzaGVyIGluc3RhbmNlLiBSZXF1aXJlcyBtaW5pbXVtIEZsYXNoIFBsYXllciBpbnN0YWxsIG9mICR7dmVyc2lvbn1gKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIHRyeSB7XG4gICAgICAgIGVudmlyb25tZW50LmluamVjdFNjcmlwdCh0aGlzLl9vcHRpb25zLnN3Zm9iamVjdFVSTClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnU1dGT2JqZWN0IGVtYmVkZGVkLicpXG4gICAgICAgICAgICBpZiAoc2VsZi5fc291cmNlSGFuZGxlcikge1xuICAgICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnUHVibGlzaCBoYW5kbGVyIGVzdGFibGlzaGVkLicpXG4gICAgICAgICAgICAgIHJldHVybiBzZWxmLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZShzZWxmLl9lbGVtZW50SWQsIHNlbGYuX29wdGlvbnMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnUHVibGlzaCBoYW5kbGVyIG5vdCBlc3RhYmxpc2hlZC4nKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5fc2V0Vmlld0lmTm90RXhpc3Qoc2VsZi5fdmlldywgc2VsZi5fb3B0aW9ucy5tZWRpYUVsZW1lbnRJZClcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2VsZilcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBlbWJlZCBGbGFzaC1iYXNlZCBSVE1QIFB1Ymxpc2hlci4gUmVhc29uOiAke2Vycn1gKVxuICAgICAgICAgICAgaWYgKHNlbGYuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgc2VsZi5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuICAgICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChgQ291bGQgbm90IGluamVjdCBGbGFzaC1iYXNlZCBQdWJsaXNoZXIgaW50byB0aGUgcGFnZS4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgICBzZWxmLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgX3NldFVwQ29ubmVjdENhbGxiYWNrIChwcm9taXNlKSB7XG4gICAgd2luZG93LnNldEFjdGl2ZUlkID0gKHN1Y2Nlc3NJZCkgPT4ge1xuICAgICAgLy8gc3VjY2Vzc0lkID09PSBfb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgICBkZWJ1ZyhOQU1FLCBgRW1iZWQgYW5kIGNvbm5lY3QoKSBjb21wbGV0ZSBmb3IgcHVibGlzaGVyIHN3Zi4gc3VjY2Vzc0lkKCR7c3VjY2Vzc0lkfSkuYClcbiAgICAgIHByb21pc2UucmVzb2x2ZShzdWNjZXNzSWQpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX1NVQ0NFU1MsIHRoaXMpKVxuICAgICAgdGhpcy5fdGVhckRvd25Db25uZWN0Q2FsbGJhY2soKVxuICAgIH1cbiAgICAvLyBUT0RPOiBTZXR1cCB0aW1lb3V0IHRvIHJlamVjdD9cbiAgfVxuXG4gIF90ZWFyRG93bkNvbm5lY3RDYWxsYmFjayAoKSB7XG4gICAgd2luZG93LnNldEFjdGl2ZUlkID0gdW5kZWZpbmVkXG4gIH1cblxuICBfZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMgKCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgY29uc3QgaW52b2tlRm4gPSAobGFiZWwpID0+IHtcbiAgICAgIHJldHVybiBbJ3B1Ymxpc2hlcicsIGxhYmVsLCBpZF0uam9pbignXycpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0Q2xvc2VkJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RJT05fQ0xPU0VELCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RTdWNjZXNzJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUywgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1VucHVibGlzaFN1Y2Nlc3MnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuVU5QVUJMSVNIX1NVQ0NFU1MsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9QdWJsaXNoU3RhcnQnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0RnV0dXJlLnJlc29sdmUodGhpcylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX1NUQVJULCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hNZXRhZGF0YScpXSA9IChtZXRhZGF0YSkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfTUVUQURBVEEsIHRoaXMsIG1ldGFkYXRhKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvQ29ubmVjdEZhaWx1cmUnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0RnV0dXJlLnJlamVjdChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaEZhaWwnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0RnV0dXJlLnJlamVjdChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfRkFJTClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0ZBSUwsIHRoaXMpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaEludmFsaWROYW1lJyldID0oKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0RnV0dXJlLnJlamVjdChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfSU5WQUxJRF9OQU1FKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfSU5WQUxJRF9OQU1FLCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBwdWJsaXNoIChzdHJlYW1OYW1lID0gdW5kZWZpbmVkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCBkZmQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9zZXRVcENvbm5lY3RDYWxsYmFjayhkZmQpXG4gICAgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lID0gc3RyZWFtTmFtZSB8fCB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBjb25zdCBwdWJsaXNoT3B0aW9ucyA9IHRoaXMuX29wdGlvbnNcbiAgICB0cnkge1xuICAgICAgbGV0IHNyY0hhbmRsZXIgPSB0aGlzLl9zb3VyY2VIYW5kbGVyXG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmdldEVtYmVkT3BlcmF0aW9uKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsICdbaGFuZGxlcjplbWJlZDpjb21wbGV0ZV0nKVxuICAgICAgICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fZWxlbWVudElkKVxuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgdGhpcy5fZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY291bnQgPSAwXG4gICAgICAgICAgY29uc3QgbGltaXQgPSAxMDBcbiAgICAgICAgICBsZXQgdHJ5Q29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgICAgICAgICAgc3JjSGFuZGxlci5jb25uZWN0KEpTT04uc3RyaW5naWZ5KHB1Ymxpc2hPcHRpb25zKSlcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCsrID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJ5Q29ubmVjdCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeUNvbm5lY3QoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBkZmQucmVqZWN0KGVycilcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgICAgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCAnW2hhbmRsZXI6ZW1iZWQ6ZXJyb3JdJylcbiAgICAgIGRmZC5yZWplY3QoYENvdWxkIG5vdCBpbml0aWF0ZSBjb25uZWN0aW9uIHNlcXVlbmNlLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgIHRoaXMuX3RlYXJEb3duQ29ubmVjdENhbGxiYWNrKClcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdEZ1dHVyZSA9IGRmZFxuICAgIHJldHVybiBkZmQucHJvbWlzZVxuICB9XG5cbiAgdW5wdWJsaXNoICgpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9lbGVtZW50SWQpLmRpc2Nvbm5lY3QoKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGluaXRpYXRlIGRpc2Nvbm5lY3Rpb24gc2VxdWVuY2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIGRlZmVycmVkLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc2VuZCAobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuc2VuZChtZXRob2ROYW1lLCB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3LCBlbGVtZW50SWQpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIHRoaXMuX2VsZW1lbnRJZCA9IGVsZW1lbnRJZFxuICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmICh0aGlzLl92aWV3KSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gbmV3IFB1Ymxpc2hlclNvdXJjZUhhbmRsZXIodGhpcy5fdmlldy52aWV3LCB0aGlzLmdldFR5cGUoKSlcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fc291cmNlSGFuZGxlcikge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5hZGRTb3VyY2UodGhpcy5fZWxlbWVudElkLCB0aGlzLl9vcHRpb25zKVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGVzdGFibGlzaCBwcm9wZXIgUlRNUCBwdWJsaXNoZXI6ICR7ZXJyfWApXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVE1QUHVibGlzaGVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldE1lZGlhUXVhbGl0eSAocXVhbGl0eSkge1xuICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLnNldE1lZGlhUXVhbGl0eShxdWFsaXR5KVxuICAgIH1cbiAgfVxuXG4gIG92ZXJsYXlPcHRpb25zIChuZXdPcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gIH1cblxuICBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlSGFuZGxlclxuICB9XG5cbiAgZ2V0T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBQdWJsaXNoVHlwZXMuUlRNUC50b1VwcGVyQ2FzZSgpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVE1QUHVibGlzaGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRtcC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IFNoYXJlZE9iamVjdEV2ZW50IH0gZnJvbSAnLi4vZXZlbnQvaW5kZXgnXG5pbXBvcnQgeyBjb21tb24gYXMgU2hhcmVkT2JqZWN0RXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50L3NoYXJlZG9iamVjdC1ldmVudCdcblxuaW1wb3J0IHsgZGVidWcgYXMgZGVidWdMb2cgfSBmcm9tICcuLi9sb2cnXG5pbXBvcnQgeyB3YXJuIGFzIHdhcm5Mb2cgfSBmcm9tICcuLi9sb2cnXG5pbXBvcnQgeyBlcnJvciBhcyBlcnJvckxvZyB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSZWQ1UHJvU2hhcmVkT2JqZWN0J1xuY29uc3QgZGVidWcgPSAoc29OYW1lLCBtZXNzYWdlKSA9PiB7XG4gIGRlYnVnTG9nKFtOQU1FLCBzb05hbWVdLmpvaW4oJzonKSwgbWVzc2FnZSlcbn1cbmNvbnN0IHdhcm4gPSAoc29OYW1lLCBtZXNzYWdlKSA9PiB7XG4gIHdhcm5Mb2coW05BTUUsIHNvTmFtZV0uam9pbignOicpLCBtZXNzYWdlKVxufVxuY29uc3QgZXJyb3IgPSAoc29OYW1lLCBtZXNzYWdlKSA9PiB7XG4gIGVycm9yTG9nKFtOQU1FLCBzb05hbWVdLmpvaW4oJzonKSwgbWVzc2FnZSlcbn1cblxuY29uc3QgU09fU1VCVFlQRV9QUk9QRVJUWSA9IDRcbmNvbnN0IFNPX1NVQlRZUEVfTUVUSE9EID0gNlxuXG5jb25zdCBkZWNvZGVNZXNzYWdlSWZKU09OU3RyaW5nID0gKG1lc3NhZ2UpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWVzc2FnZSkgOiBtZXNzYWdlXG59XG5cbmNsYXNzIFByb3BlcnR5RGF0YSB7XG5cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgdG9PYmplY3QgKCkge1xuICAgIGxldCBvYmogPSAge31cbiAgICBvYmpbdGhpcy5rZXldID0gdGhpcy52YWx1ZVxuICAgIHJldHVybiBvYmpcbiAgfVxuXG59XG5cbmNsYXNzIE1ldGhvZERhdGEge1xuXG4gIGNvbnN0cnVjdG9yIChtZXRob2ROYW1lLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXRob2ROYW1lID0gbWV0aG9kTmFtZVxuICAgIGxldCBtZXNzYWdlTGlzdFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGxldCBpXG4gICAgICBsZXQgbXNnXG4gICAgICBsZXQgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGhcbiAgICAgIG1lc3NhZ2VMaXN0ID0gW11cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBtc2cgPSBkZWNvZGVNZXNzYWdlSWZKU09OU3RyaW5nKG1lc3NhZ2VbaV0pXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICBtZXNzYWdlTGlzdCA9IG1lc3NhZ2VMaXN0LmNvbmNhdChtc2cpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbWVzc2FnZUxpc3QucHVzaChtc2cpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBtZXNzYWdlTGlzdCA9IFtkZWNvZGVNZXNzYWdlSWZKU09OU3RyaW5nKG1lc3NhZ2UpXVxuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlTGlzdC5sZW5ndGggPT09IDEgPyBtZXNzYWdlTGlzdFswXSA6IG1lc3NhZ2VMaXN0XG4gIH1cblxuICB0b09iamVjdCAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZE5hbWU6IHRoaXMubWV0aG9kTmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIFJlZDVQcm9TaGFyZWRPYmplY3QgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX25hbWUgPSBuYW1lXG4gICAgdGhpcy5fc29ja2V0ID0gY29ubmVjdGlvbi5nZXRDb25uZWN0aW9uKClcbiAgICB0aGlzLl9zb2NrZXQuYWRkU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyKHRoaXMpXG4gICAgdGhpcy5fb25jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuICAgIHRyeSB7XG4gICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCAnW3NoYXJlZG9iamVjdDpjb25uZWN0OmF0dGVtcHRdJylcbiAgICAgIHRoaXMuX3NvY2tldC5nZXRSZW1vdGVTaGFyZWRPYmplY3QodGhpcy5fbmFtZSlcbiAgICAgIGVudmlyb25tZW50LmFkZENsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlLCAwKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IodGhpcy5fbmFtZSwgJ1tzaGFyZWRvYmplY3Q6Y29ubmVjdDplcnJvcl06ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlIChtZXNzYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZS5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKSA6IG1lc3NhZ2UuZGF0YVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2Fybih0aGlzLl9uYW1lLCAnQ291bGQgbm90IHBhcnNlIG1lc3NhZ2UgYXMgSlNPTi4gTWVzc2FnZT0gJyArIG1lc3NhZ2UuZGF0YSArICcuIEVycm9yPSAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbm90aWZ5T2ZQcm9wZXJ0eVZhbHVlcyAodmFsdWVPYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModmFsdWVPYmplY3QpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuUFJPUEVSVFlfVVBEQVRFLCB0aGlzLl9uYW1lLCB7fSkpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGV0IGtleVxuICAgICAgZm9yIChrZXkgaW4gdmFsdWVPYmplY3QpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLlBST1BFUlRZX1VQREFURSwgdGhpcy5fbmFtZSwgbmV3IFByb3BlcnR5RGF0YShrZXksIHZhbHVlT2JqZWN0W2tleV0pLnRvT2JqZWN0KCkpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU9mRXZlbnRzIChldmVudHMpIHtcbiAgICBsZXQgaSwgZXZlbnRcbiAgICBjb25zdCBsZW5ndGggPSBldmVudHMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBldmVudCA9IGV2ZW50c1tpXVxuICAgICAgc3dpdGNoIChldmVudC5zdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgU09fU1VCVFlQRV9QUk9QRVJUWTpcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuUFJPUEVSVFlfVVBEQVRFLCB0aGlzLl9uYW1lLCBuZXcgUHJvcGVydHlEYXRhKGV2ZW50LmF0dHJpYnV0ZSwgZXZlbnQudmFsdWUpLnRvT2JqZWN0KCkpKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGNhc2UgU09fU1VCVFlQRV9NRVRIT0Q6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLk1FVEhPRF9VUERBVEUsIHRoaXMuX25hbWUsIG5ldyBNZXRob2REYXRhKGV2ZW50Lm1ldGhvZCwgZXZlbnQudmFsdWUpLnRvT2JqZWN0KCkpKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmVzcG9uZCAobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLmRhdGEpIHtcbiAgICAgIGxldCBqc29uID0gdGhpcy5nZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UobWVzc2FnZSlcbiAgICAgIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgICAgIHdhcm4odGhpcy5fbmFtZSwgJ0RldGVybWluZWQgd2Vic29ja2V0IHJlc3BvbnNlIG5vdCBpbiBjb3JyZWN0IGZvcm1hdC4gQWJvcnRpbmcgbWVzc2FnZSBoYW5kbGUuJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZGF0YS5uYW1lID09PSB0aGlzLl9uYW1lKSB7XG4gICAgICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1tzaGFyZWRvYmplY3QtcmVzcG9uc2VdOiAnICsgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikpXG4gICAgICAgICAgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdTaGFyZWRPYmplY3QuU3RhdHVzLkdldFJlbW90ZScgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdTdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0LmNvbm5lY3RUb1NoYXJlZE9iamVjdCh0aGlzLl9uYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ1NoYXJlZE9iamVjdC5TdGF0dXMuR2V0UmVtb3RlJyAmJlxuICAgICAgICAgICAgICBqc29uLmRhdGEubWVzc2FnZSA9PT0gJ0ZhaWwnKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzLl9uYW1lKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdTaGFyZWRPYmplY3QuU3RhdHVzLkNvbm5lY3QnICYmXG4gICAgICAgICAgICAgIGpzb24uZGF0YS5tZXNzYWdlID09PSAnU3VjY2VzcycpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMuX25hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ1NoYXJlZE9iamVjdC5TdGF0dXMuQ29ubmVjdCcgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdGYWlsJykge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcy5fbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEudHlwZSA9PT0gJ3NoYXJlZG9iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuaGFzT3duUHJvcGVydHkoJ2V2ZW50cycpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGlmeU9mRXZlbnRzKGpzb24uZGF0YS5ldmVudHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5T2ZQcm9wZXJ0eVZhbHVlcyhqc29uLmRhdGEudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdVbmhhbmRsZWQgU29ja2V0IGV4Y2hhbmdlOiAnICsgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgc2VuZCAobWVzc2FnZU5hbWUsIGRhdGEpIHtcbiAgICB0aGlzLl9zb2NrZXQuc2VuZFRvU2hhcmVkT2JqZWN0KHRoaXMuX25hbWUsIG1lc3NhZ2VOYW1lLCBkYXRhKVxuICB9XG5cbiAgc2V0UHJvcGVydHkgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9zb2NrZXQuc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QodGhpcy5fbmFtZSwga2V5LCB2YWx1ZSlcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBpZiAodGhpcy5fc29ja2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHdhcm4oJ1NvY2tldCBubyBsb25nZXIgZXhpc3QgdG8gY2xvc2Ugc2hhcmVkIG9iamVjdCBwcm9wZXJseS4nKVxuICAgIH1cbiAgICB0aGlzLl9zb2NrZXQuY2xvc2VTaGFyZWRPYmplY3QodGhpcy5fbmFtZSlcbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuX3NvY2tldCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX25hbWUgPSB1bmRlZmluZWRcbiAgICBlbnZpcm9ubWVudC5yZW1vdmVDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgfVxuXG4gIGdldE5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lXG4gIH1cblxufVxuXG5leHBvcnQgeyBSZWQ1UHJvU2hhcmVkT2JqZWN0IH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9zaGFyZWRvYmplY3QvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi8uLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBTbGlkZXJFdmVudCwgU2xpZGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQnXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZydcblxubGV0IE5BTUUgPSAnQ29udHJvbFNsaWRlcidcblxuY2xhc3MgQ29udHJvbFNsaWRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKHR5cGUpIHtcbiAgICBzdXBlcigpXG4gICAgTkFNRSA9IFtOQU1FLCB0eXBlXS5qb2luKCc6OicpXG4gICAgZGVidWcoTkFNRSwgJ1tpbml0XScpXG4gICAgdGhpcy5fY29udGFpbmVyID0gZW52aXJvbm1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLl9idXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbigpXG4gICAgdGhpcy5fdHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKClcbiAgICB0aGlzLl9wcm9ncmVzc0JhciA9IHRoaXMuY3JlYXRlUHJvZ3Jlc3NCYXIoKVxuICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl90cmFjaylcbiAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcHJvZ3Jlc3NCYXIpXG4gICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2J1dHRvbilcbiAgICB0aGlzLl92YWx1ZSA9IDAgLy8gMCAtIDFcbiAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlXG4gICAgdGhpcy5fZXZlbnRTdGFydFBvc2l0aW9uID0gMFxuICAgIHRoaXMuX2xheW91dCgpXG4gICAgdGhpcy5fbW91c2V1cEhhbmRsZXIgPSB0aGlzLl9tb3VzZXVwLmJpbmQodGhpcylcbiAgICB0aGlzLl9tb3VzZWRvd25IYW5kbGVyID0gdGhpcy5fbW91c2Vkb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9tb3VzZW1vdmVIYW5kbGVyID0gdGhpcy5fbW91c2Vtb3ZlLmJpbmQodGhpcylcbiAgICB0aGlzLl91cGRhdGVIYW5kbGVycyh0aGlzLl9kaXNhYmxlZClcbiAgfVxuXG4gIF9tb3VzZXVwICgpIHtcbiAgICB0aGlzLl9ldmVudFN0YXJ0UG9zaXRpb24gPSAwXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fbW91c2Vtb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2V1cEhhbmRsZXIpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTbGlkZXJFdmVudChTbGlkZXJFdmVudFR5cGVzLkNIQU5HRV9DT01QTEVURSwgdGhpcykpXG4gIH1cblxuICBfbW91c2Vtb3ZlIChldmVudCkge1xuICAgICAgY29uc3QgcG9zaXRpb25PZmZzZXQgPSAoZW52aXJvbm1lbnQuZ2V0TW91c2VYRnJvbUV2ZW50KGV2ZW50KSAtIHRoaXMuX2V2ZW50U3RhcnRQb3NpdGlvbilcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLl9idXR0b24ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgbGV0IHBvc2l0aW9uID0gKHRoaXMuX2V2ZW50U3RhcnRQb3NpdGlvbiArIHBvc2l0aW9uT2Zmc2V0KSAtIHJlY3QubGVmdCAvLyAtIGVudmlyb25tZW50LmdldFNjcm9sbFgoKVxuICAgICAgcG9zaXRpb24gPSBNYXRoLm1heCgwLCBwb3NpdGlvbilcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5taW4ocG9zaXRpb24sIHJlY3Qud2lkdGgpXG4gICAgICBsZXQgcGVyY2VudGFnZSA9IHBvc2l0aW9uIC8gcmVjdC53aWR0aFxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTbGlkZXJFdmVudChTbGlkZXJFdmVudFR5cGVzLkNIQU5HRSwgdGhpcywgcGVyY2VudGFnZSkpXG4gICAgfVxuXG4gIF9tb3VzZWRvd24gKGV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudFN0YXJ0UG9zaXRpb24gPSBlbnZpcm9ubWVudC5nZXRNb3VzZVhGcm9tRXZlbnQoZXZlbnQpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFNsaWRlckV2ZW50KFNsaWRlckV2ZW50VHlwZXMuQ0hBTkdFX1NUQVJULCB0aGlzKSlcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fbW91c2V1cEhhbmRsZXIpXG4gICAgfVxuXG4gIF91cGRhdGVIYW5kbGVycyAoaXNEaXNhYmxlZCkge1xuICAgIHRoaXMuX2V2ZW50U3RhcnRQb3NpdGlvbiA9IDBcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9tb3VzZW1vdmVIYW5kbGVyKVxuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9tb3VzZW1vdmVIYW5kbGVyKVxuICAgICAgdGhpcy5fYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlZG93bkhhbmRsZXIpXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3VzZW1vdmVIYW5kbGVyKVxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX21vdXNldXBIYW5kbGVyKVxuICAgICAgdGhpcy5fdHJhY2suY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1zbGlkZXItZGlzYWJsZWQnKVxuICAgICAgdGhpcy5fcHJvZ3Jlc3NCYXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1zbGlkZXItZGlzYWJsZWQnKVxuICAgICAgdGhpcy5fYnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLWRpc2FibGVkJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90cmFjay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICB0aGlzLl9wcm9ncmVzc0Jhci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX21vdXNlbW92ZUhhbmRsZXIpXG4gICAgICB0aGlzLl9idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2Vkb3duSGFuZGxlcilcbiAgICAgIHRoaXMuX3RyYWNrLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLWRpc2FibGVkJylcbiAgICAgIHRoaXMuX3Byb2dyZXNzQmFyLmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLWRpc2FibGVkJylcbiAgICAgIHRoaXMuX2J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLXNsaWRlci1kaXNhYmxlZCcpXG4gICAgfVxuICB9XG5cbiAgX2xheW91dCAoKSB7XG4gICAgbGV0IHBvc2l0aW9uID0gdGhpcy5fcHJvZ3Jlc3NCYXIucGFyZW50Tm9kZS5jbGllbnRXaWR0aCAqIHRoaXMuX3ZhbHVlXG4gICAgdGhpcy5fcHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSBwb3NpdGlvbiArICdweCdcbiAgICB0aGlzLl9idXR0b24uc3R5bGUubGVmdCA9IChwb3NpdGlvbiAtICh0aGlzLl9idXR0b24uY2xpZW50V2lkdGggKiAwLjUpKSArICdweCdcbiAgfVxuXG4gIGNyZWF0ZUJ1dHRvbiAoKSB7XG4gICAgbGV0IHNwYW4gPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLWJ1dHRvbicpXG4gICAgcmV0dXJuIHNwYW5cbiAgfVxuXG4gIGNyZWF0ZVByb2dyZXNzQmFyICgpIHtcbiAgICBsZXQgc3BhbiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgIHNwYW4uY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1zbGlkZXItcHJvZ3Jlc3MnKVxuICAgIHJldHVybiBzcGFuXG4gIH1cblxuICBjcmVhdGVUcmFjayAoKSB7XG4gICAgbGV0IHNwYW4gPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICBzcGFuLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtc2xpZGVyLXRyYWNrJylcbiAgICByZXR1cm4gc3BhblxuICB9XG5cbiAgZ2V0IHZhbHVlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVcbiAgfVxuXG4gIHNldCB2YWx1ZSAocGVyY2VudFZhbHVlIC8qIDAgLSAxICovKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBwZXJjZW50VmFsdWVcbiAgICB0aGlzLl9sYXlvdXQoKVxuICB9XG5cbiAgZ2V0IGRpc2FibGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWRcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCAoYm9vbCkge1xuICAgIHRoaXMuX2Rpc2FibGVkID0gYm9vbFxuICAgIHRoaXMuX3VwZGF0ZUhhbmRsZXJzKGJvb2wpXG4gIH1cblxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sU2xpZGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvc3Vic2NyaWJlci9jb250cm9scy9zbGlkZXIuanMiLCIvKipcbiAqIE1haW4gZW50cnkgZm9yIGZhaWxvdmVyIHN1cHBvcnQgb2YgYWxsIHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb25zLlxuICovXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgUlRDU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRjJ1xuaW1wb3J0IFJUTVBTdWJzY3JpYmVyIGZyb20gJy4vcmVkNXByby1ydG1wJ1xuaW1wb3J0IEhMU1N1YnNjcmliZXIgZnJvbSAnLi9yZWQ1cHJvLWhscydcblxuaW1wb3J0IEltcGxGYWN0b3J5T3JkZXIgZnJvbSAnLi4vdXRpbC9pbXBsLWZhY3Rvcnktb3JkZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBQbGF5YmFja1R5cGVzIH0gZnJvbSAnLi4vZW51bS9wbGF5YmFjaydcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvU3Vic2NyaWJlcidcbmNvbnN0IHBsYXliYWNrRmFjdG9yeSA9IG5ldyBJbXBsRmFjdG9yeU9yZGVyKClcblxuY29uc3QgcGxheWJhY2tJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgbGV0IG1hcCA9IG5ldyBNYXAoKVxuICBtYXAuc2V0KFBsYXliYWNrVHlwZXMuUlRDLCBSVENTdWJzY3JpYmVyKVxuICBtYXAuc2V0KFBsYXliYWNrVHlwZXMuUlRNUCwgUlRNUFN1YnNjcmliZXIpXG4gIG1hcC5zZXQoUGxheWJhY2tUeXBlcy5ITFMsIEhMU1N1YnNjcmliZXIpXG4gIHJldHVybiBtYXBcbn0oKSlcblxuY2xhc3MgUmVkNVByb1N1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgLy8gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIC8vIFRoZSBwbGF5YmFjayB2aWV3XG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIC8vIFNlbGVjdGVkIGZhaWxvdmVyIHN1YnNjcmliZXIuXG4gICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIgPSB1bmRlZmluZWRcbiAgICAvLyBEZWZhdWx0IG9yZGVyLlxuICAgIHRoaXMuX29yZGVyID0gW1xuICAgICAgUGxheWJhY2tUeXBlcy5SVEMsXG4gICAgICBQbGF5YmFja1R5cGVzLlJUTVAsXG4gICAgICBQbGF5YmFja1R5cGVzLkhMU1xuICAgIF1cbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudCA9IHRoaXMuYnViYmxlU3Vic2NyaWJlckV2ZW50LmJpbmQodGhpcylcbiAgfVxuXG4gIGdldFBsYXliYWNrT3JkZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRlclxuICB9XG5cbiAgc2V0UGxheWJhY2tPcmRlciAob3JkZXIpIHtcbiAgICAvLyBBbGxvdyBmb3Igc3RyaW5nIHZhbHVlIHRvIGRlZmluZSBzaW5nbGUgaXRlbSBpbiBvcmRlci5cbiAgICBvcmRlciA9IHR5cGVvZiBvcmRlciA9PT0gJ3N0cmluZycgPyBbb3JkZXJdIDogb3JkZXJcblxuICAgIC8vIEZpbHRlciBvdXQgdmFsdWVzIG5vdCBhdmFpbGFibGUgaW4gZW51bWVyYXRpb24gb2YgcGxheWJhY2sgdHlwZXMuXG4gICAgY29uc3QgdCA9IG9yZGVyLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICBsZXQga2V5XG4gICAgICBmb3IgKGtleSBpbiBQbGF5YmFja1R5cGVzKSB7XG4gICAgICAgIGlmIChQbGF5YmFja1R5cGVzW2tleV0udG9Mb3dlckNhc2UoKSA9PT0gZW50cnkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pLm1hcChlbnRyeSA9PiBlbnRyeS50b0xvd2VyQ2FzZSgpKVxuXG4gICAgLy8gRGVmaW5lIG5ldyBvcmRlci5cbiAgICB0aGlzLl9vcmRlciA9IFsuLi5uZXcgU2V0KHQpXVxuICAgIGRlYnVnKE5BTUUsIGBbb3JkZXJ1cGRhdGVdOiAke3RoaXMuX29yZGVyfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldFZpZXcgKHBsYXliYWNrVmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSBwbGF5YmFja1ZpZXdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0UGxheWJhY2tGcm9tT3JkZXIgKG9yZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHBsYXliYWNrRmFjdG9yeS5jcmVhdGUob3JkZXIsIHBsYXliYWNrSW1wbCwgb3B0aW9ucywgJ2luaXQnKVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBkZWJ1ZyhOQU1FLCAnW2luaXRdJylcbiAgICB0aGlzLmdldFBsYXliYWNrRnJvbU9yZGVyKHRoaXMuX29yZGVyLCB0aGlzLl9vcHRpb25zKVxuICAgICAgLnRoZW4oc3Vic2NyaWJlciA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsIGBbaW5pdDpzdWNjZXNzXTogc3Vic2NyaWJlciBmb3VuZCAke3N1YnNjcmliZXIuZ2V0VHlwZSgpfWApXG4gICAgICAgIHN1YnNjcmliZXIub24oJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudClcbiAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIgPSBzdWJzY3JpYmVyXG4gICAgICAgIGlmICh0aGlzLl92aWV3KSB7XG4gICAgICAgICAgdGhpcy5fdmlldy5hdHRhY2hTdWJzY3JpYmVyKHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyKVxuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcy5fY3VycmVudFN1YnNjcmliZXIpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwbGF5ZXJyb3JdOiBDb3VsZCBub3QgaW1wbGVtZW50IGEgc3Vic2NyaWJlcjogJHtlcnJ9YClcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGNhbmNlbCAoKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyKSB7XG4gICAgICB3YXJuKE5BTUUsICdbY2FuY2VsXTogQ291bGQgbm90IGludm9rZSBjYW5jZWwoKSBvbiB1bmRlZmluZWQgc3Vic2NyaWJlci4nKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KCdBIGN1cnJlbnQgc3Vic2NyaWJlciBpcyBub3QgYXZhaWxhYmxlIHRvIGlzc3VlIGEgOmNhbmNlbCgpIGNvbW1hbmQgdG8uJylcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoTkFNRSwgJ1tjYW5jZWxdOiBJbnZva2luZyBjYW5jZWwgb24gaGVsZCBzdWJzY3JpYmVyLicpXG4gICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlci5jYW5jZWwoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgJ1tzdG9wc3VjY2Vzc10nKVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50KVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyID0gdW5kZWZpbmVkXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsIGBbc3RvcGVycm9yXTogJHtlcnJ9YClcbiAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlciA9IHVuZGVmaW5lZFxuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBidWJibGVTdWJzY3JpYmVyRXZlbnQgKHN1YnNjcmliZXJFdmVudCkge1xuICAgIHRoaXMudHJpZ2dlci5jYWxsKHRoaXMsIHN1YnNjcmliZXJFdmVudClcbiAgfVxuXG4gIGdldCBwbGF5YmFja1R5cGVzICgpIHtcbiAgICByZXR1cm4gUGxheWJhY2tUeXBlc1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRTdWJzY3JpYmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFN1YnNjcmliZXJcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlZDVQcm9TdWJzY3JpYmVyLCBSVENTdWJzY3JpYmVyLCBITFNTdWJzY3JpYmVyLCBSVE1QU3Vic2NyaWJlciB9XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9zdWJzY3JpYmVyL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IEhMU1NvdXJjZUhhbmRsZXIgZnJvbSAnLi9yZWQ1cHJvLXNvdXJjZS1oYW5kbGVyLWhscydcbmltcG9ydCBQbGF5YmFja1ZpZXcgZnJvbSAnLi4vdmlldy9wbGF5YmFjaydcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudCB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ0hMU1N1YnNjcmliZXInXG5cbi8vIERlZmF1bHQgdG8gc2VjdXJlIHNldHRpbmdzLlxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAnaHR0cHMnLFxuICBwb3J0OiA0NDMsXG4gIGFwcDogJ2xpdmUnLFxuICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3gtbXBlZ1VSTCcsXG4gIG1lZGlhRWxlbWVudElkOiAncmVkNXByby1zdWJzY3JpYmVyJ1xufVxuXG5jb25zdCBvcHRpb25zVG9IbHNVUkwgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMuaGxzcHJvdG9jb2wgPyBvcHRpb25zLmhsc3Byb3RvY29sIDogb3B0aW9ucy5wcm90b2NvbFxuICBjb25zdCBwb3J0ID0gb3B0aW9ucy5obHNwb3J0ID8gb3B0aW9ucy5obHNwb3J0IDogb3B0aW9ucy5wb3J0XG4gIGNvbnN0IGFwcEVuZHBvaW50ID0gb3B0aW9ucy5jb250ZXh0ID8gW29wdGlvbnMuYXBwLCBvcHRpb25zLmNvbnRleHRdLmpvaW4oJy8nKSA6IG9wdGlvbnMuYXBwXG4gIHJldHVybiBgJHtwcm90b2NvbH06Ly8ke29wdGlvbnMuaG9zdH06JHtwb3J0fS8ke2FwcEVuZHBvaW50fS8ke29wdGlvbnMuc3RyZWFtTmFtZX0ubTN1OGBcbn1cblxuY2xhc3MgUjVQcm9ITFNTdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXdSZXNvbHZlciA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzID0gdGhpcy5idWJibGVTdWJzY3JpYmVyRXZlbnRzLmJpbmQodGhpcylcbiAgfVxuXG4gIF9nZXRWaWV3UmVzb2x2ZXJQcm9taXNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld1Jlc29sdmVyLnByb21pc2VcbiAgfVxuXG4gIF9nZXRTdWJzY3JpcHRpb25SZXNvbHZlclByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyLnByb21pc2VcbiAgfVxuXG4gIF9nbG9tU291cmNlSGFuZGxlckFQSSAoaGFuZGxlcikge1xuICAgIHRoaXMucGxheSA9IGhhbmRsZXIucGxheS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5wYXVzZSA9IGhhbmRsZXIucGF1c2UuYmluZChoYW5kbGVyKVxuICAgIHRoaXMucmVzdW1lID0gaGFuZGxlci5yZXN1bWUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc3RvcCA9IGhhbmRsZXIuc3RvcC5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5tdXRlID0gaGFuZGxlci5tdXRlLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnVubXV0ZSA9IGhhbmRsZXIudW5tdXRlLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnNldFZvbHVtZSA9IGhhbmRsZXIuc2V0Vm9sdW1lLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnNlZWtUbyA9IGhhbmRsZXIuc2Vla1RvLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnRvZ2dsZUZ1bGxTY3JlZW4gPSBoYW5kbGVyLnRvZ2dsZUZ1bGxTY3JlZW4uYmluZChoYW5kbGVyKVxuICAgIGhhbmRsZXIub24oJyonLCAoZXZlbnQpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KGV2ZW50LnR5cGUsIHRoaXMsIGV2ZW50LmRhdGEpKVxuICAgIH0pXG4gIH1cblxuICBfc2V0Vmlld0lmTm90RXhpc3QgKGN1cnJlbnRWaWV3LCBtZWRpYUVsZW1lbnRJZCA9IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmlldyA9PT0gJ3VuZGVmaW5lZCcgJiYgbWVkaWFFbGVtZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdmlldyA9IG5ldyBQbGF5YmFja1ZpZXcobWVkaWFFbGVtZW50SWQpXG4gICAgICAgIHZpZXcuYXR0YWNoU3Vic2NyaWJlcih0aGlzKVxuICAgICAgfVxuICB9XG5cbiAgYnViYmxlU3Vic2NyaWJlckV2ZW50cyAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUQVJUKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KGV2ZW50LnR5cGUsIHRoaXMsIGV2ZW50LmRhdGEpKVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCFlbnZpcm9ubWVudC5zdXBwb3J0c0hMUygpKSB7XG4gICAgICB3YXJuKE5BTUUsIGBDb3VsZCBub3QgcmVzb2x2ZSBITFNTdWJzY3JpYmVyIGluc3RhbmNlLmApXG4gICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCByZXNvbHZlIEhMU1N1YnNjcmliZXIgaW5zdGFuY2UuYClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICB0aGlzLl9zZXRWaWV3SWZOb3RFeGlzdCh0aGlzLl92aWV3LCB0aGlzLl9vcHRpb25zLm1lZGlhRWxlbWVudElkKVxuICAgICAgdGhpcy5fZ2V0Vmlld1Jlc29sdmVyUHJvbWlzZSgpXG4gICAgICAgIC50aGVuKHZpZXcgPT4ge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgSExTU291cmNlSGFuZGxlcih2aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgICAgICAgIHRoaXMuX2dsb21Tb3VyY2VIYW5kbGVyQVBJKHRoaXMuX3NvdXJjZUhhbmRsZXIpXG4gICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEhhbmRsZXIodGhpcy5fb3B0aW9ucylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBpbml0SGFuZGxlciAob3B0aW9ucykge1xuICAgIGNvbnN0IHVybFJlZ2V4ID0gL15odHRwKHxzKS4qXFwubTN1OC9nXG4gICAgbGV0IHVybCA9IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZS5tYXRjaCh1cmxSZWdleCkgPyB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUgOiBvcHRpb25zVG9IbHNVUkwodGhpcy5fb3B0aW9ucylcbiAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLm9uKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHVybCwgb3B0aW9ucy5taW1lVHlwZSwgb3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBlcnJvcihOQU1FLCAnQ291bGQgbm90IGVzdGFibGlzaCBhbiBITFMgU3Vic2NyaWJlcjogJyArIGVycm9yKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUpKVxuICAgICAgfSlcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIHRoaXMuX3ZpZXdSZXNvbHZlci5yZXNvbHZlKHZpZXcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN1YnNjcmliZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN1YnNjcmlwdGlvblJlc29sdmVyUHJvbWlzZSgpXG4gIH1cblxuICB1bnN1YnNjcmliZSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1t1bnNjdWJzY3JpYmVdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLnN0b3AoKVxuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5jbGVhblVwKClcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0Q29udHJvbHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VIYW5kbGVyID8gdGhpcy5fc291cmNlSGFuZGxlci5nZXRDb250cm9scygpIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXRQbGF5ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3LnZpZXdcbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiAnSExTJ1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUjVQcm9ITFNTdWJzY3JpYmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLWhscy5qcyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCAqIGFzIHdlYnJ0YyBmcm9tICcuLi9hZGFwdGVyL3dlYnJ0YydcbmltcG9ydCAqIGFzIHdlYnNvY2tldCBmcm9tICcuLi9hZGFwdGVyL3dlYnNvY2tldCdcbmltcG9ydCBSVENTb3VyY2VIYW5kbGVyIGZyb20gJy4vcmVkNXByby1zb3VyY2UtaGFuZGxlci1ydGMnXG5pbXBvcnQgU3Vic2NyaXB0aW9uU29ja2V0SGVscGVyIGZyb20gJy4uL2hlbHBlci9zb2NrZXQtaGVscGVyLXN1YidcbmltcG9ydCBTdWJzY3JpcHRpb25QZWVySGVscGVyIGZyb20gJy4uL2hlbHBlci93ZWJydGMtaGVscGVyLXN1YidcbmltcG9ydCBQbGF5YmFja1ZpZXcgZnJvbSAnLi4vdmlldy9wbGF5YmFjaydcbmltcG9ydCB7IHJ0Y1NvY2tldEVuZHBvaW50RnJvbU9wdGlvbnMgYXMgZW5kcG9pbnRGcm9tT3B0aW9ucyB9IGZyb20gJy4uL3V0aWwvdXJsLWVuZHBvaW50J1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnRUeXBlcywgUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IGRlYnVnLCB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3Qgc3ViU3RhcnRSZWdleCA9IC8oLiopIHN0YXJ0aW5nL2lcblxuY29uc3QgTkFNRSA9ICdSVENTdWJzY3JpYmVyJ1xuXG5jb25zdCBnZW5lcmF0ZVN1YnNjcmlwdGlvbklkID0gKCkgPT4ge1xuICBjb25zdCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gYHN1YnNjcmliZXItJHtpZH1gXG59XG5cbi8vIERlZmF1bHQgdG8gc2VjdXJlIHNldHRpbmdzLlxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAnd3NzJyxcbiAgcG9ydDogODA4MyxcbiAgYXBwOiAnbGl2ZScsXG4gIG1lZGlhRWxlbWVudElkOiAncmVkNXByby1zdWJzY3JpYmVyJ1xufVxuXG5jbGFzcyBSVENTdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3UmVzb2x2ZXIgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9hdmFpbGFiaWxpdHlSZXNvbHZlciA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSAwXG4gIH1cblxuICBfZ2V0Vmlld1Jlc29sdmVyUHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdSZXNvbHZlci5wcm9taXNlXG4gIH1cblxuICBfZ2V0QXZhaWxhYmlsaXR5UmVzb2x2ZXJQcm9taXNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmlsaXR5UmVzb2x2ZXIucHJvbWlzZVxuICB9XG5cbiAgX2dldFN1YnNjcmlwdGlvblJlc29sdmVyUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uUmVzb2x2ZXIucHJvbWlzZVxuICB9XG5cbiAgX2dsb21Tb3VyY2VIYW5kbGVyQVBJIChoYW5kbGVyKSB7XG4gICAgdGhpcy5wbGF5ID0gaGFuZGxlci5wbGF5LmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLnBhdXNlID0gaGFuZGxlci5wYXVzZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5yZXN1bWUgPSBoYW5kbGVyLnJlc3VtZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zdG9wID0gaGFuZGxlci5zdG9wLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLm11dGUgPSBoYW5kbGVyLm11dGUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMudW5tdXRlID0gaGFuZGxlci51bm11dGUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc2V0Vm9sdW1lID0gaGFuZGxlci5zZXRWb2x1bWUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc2Vla1RvID0gaGFuZGxlci5zZWVrVG8uYmluZChoYW5kbGVyKVxuICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbiA9IGhhbmRsZXIudG9nZ2xlRnVsbFNjcmVlbi5iaW5kKGhhbmRsZXIpXG4gICAgaGFuZGxlci5vbignKicsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoZXZlbnQudHlwZSwgdGhpcywgZXZlbnQuZGF0YSkpXG4gICAgfSlcbiAgfVxuXG4gIF9zZXRWaWV3SWZOb3RFeGlzdCAoY3VycmVudFZpZXcsIG1lZGlhRWxlbWVudElkID0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWaWV3ID09PSAndW5kZWZpbmVkJyAmJiBtZWRpYUVsZW1lbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IFBsYXliYWNrVmlldyhtZWRpYUVsZW1lbnRJZClcbiAgICAgICAgdmlldy5hdHRhY2hTdWJzY3JpYmVyKHRoaXMpXG4gICAgICB9XG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXdlYnJ0Yy5pc1N1cHBvcnRlZCgpIHx8ICF3ZWJzb2NrZXQuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KCdDYW5ub3QgY3JlYXRlIFdlYlJUQyBwbGF5YmFjayBpbnN0YW5jZS4gWW91ciBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQyBhbmQvb3IgV2ViU29ja2V0cy4nKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkIHx8IGdlbmVyYXRlU3Vic2NyaXB0aW9uSWQoKVxuXG4gICAgICB0aGlzLl9wZWVySGVscGVyID0gbmV3IFN1YnNjcmlwdGlvblBlZXJIZWxwZXIodGhpcylcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IG5ldyBTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIodGhpcylcbiAgICAgIGNvbnN0IHNvY2tldFByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICAgIGNvbnN0IHNvY2tldHVybCA9IGVuZHBvaW50RnJvbU9wdGlvbnModGhpcy5fb3B0aW9ucywge1xuICAgICAgICBpZDogdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZFxuICAgICAgfSlcblxuICAgICAgc29ja2V0UHJvbWlzZS5wcm9taXNlXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTLCB0aGlzKSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzLCBlcnJvcikpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuX3NvY2tldEhlbHBlci5zZXRVcChzb2NrZXR1cmwsIHNvY2tldFByb21pc2UpXG5cbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGluaXRIYW5kbGVyIChvcHRpb25zLCBoYW5kbGVyKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaGFuZGxlcikge1xuICAgICAgaGFuZGxlci5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cylcbiAgICAgIGhhbmRsZXIuYWRkU291cmNlKG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgc2V0VmlldyAodmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSB2aWV3XG4gICAgdGhpcy5fdmlld1Jlc29sdmVyLnJlc29sdmUodGhpcy5fdmlldylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVxdWVzdEF2YWlsYWJpbGl0eSAoc3RyZWFtTmFtZSkge1xuICAgIGRlYnVnKE5BTUUsICdbcmVxdWVzdGF2YWlsYWJpbGl0eV0nKVxuICAgIC8vIG1lc3NhZ2Ugb24gc29ja2V0IHJldHVybnMgLT4gb25TdHJlYW0oVW4pQXZhaWxhYmxlXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaXNBdmFpbGFibGU6IHN0cmVhbU5hbWVcbiAgICB9KVxuICB9XG5cbiAgcmVxdWVzdE9mZmVyIChzdHJlYW1OYW1lLCBzdWJzY3JpcHRpb25JZCwgdkVuY29kaW5nID0gdW5kZWZpbmVkLCBhRW5jb2RpbmcgPSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3JlcXVlc3RvZmZlcl0nKVxuICAgIGxldCBvZmZlciA9IHtcbiAgICAgIHJlcXVlc3RPZmZlcjogc3RyZWFtTmFtZSxcbiAgICAgIHJlcXVlc3RJZDogc3Vic2NyaXB0aW9uSWRcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2RW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZlci52aWRlb0VuY29kaW5nID0gdkVuY29kaW5nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFFbmNvZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZmVyLmF1ZGlvRW5jb2RpbmcgPSBhRW5jb2Rpbmc7XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLk9GRkVSX1NUQVJULCB0aGlzKSlcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXR1cm5zIC0+IG9uU0RQT2ZmZXJcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdChvZmZlcilcbiAgfVxuXG4gIHJlcXVlc3RBbnN3ZXIgKHNkcCkge1xuICAgIGRlYnVnKE5BTUUsICdbcmVxdWVzdGFuc3dlcl0nKVxuICAgIC8vIGludm9rZXMgLT4gc2VuZEFuc3dlclxuICAgIHRoaXMuX3BlZXJIZWxwZXIuY3JlYXRlQW5zd2VyKHNkcClcbiAgICAgICAgLnRoZW4oc2Vzc2lvbkRlc2NyaXB0aW9uID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW29uYW5zd2VyY3JlYXRlZF0nKVxuICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJhbmR3aWR0aCkge1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCA9IHdlYnJ0Yy51cGRhdGVCYW5kd2lkdGgodGhpcy5fb3B0aW9ucy5iYW5kd2lkdGgsIHNlc3Npb25EZXNjcmlwdGlvbi5zZHApXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnKE5BTUUsICdbPiBzZW5kYW5zd2VyXScpXG4gICAgICAgICAgdGhpcy5zZW5kQW5zd2VyKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCwgc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMub25TRFBFcnJvcihlcnJvcilcbiAgICAgICAgfSlcbiAgfVxuXG4gIHNlbmRBbnN3ZXIgKHN0cmVhbU5hbWUsIHN1YnNjcmlwdGlvbklkLCBzZHApIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW3NlbmRhbnN3ZXJdOiBzdHJlYW1uYW1lKCR7c3RyZWFtTmFtZX0pLCBzdWJzY3JpcHRpb25pZCgke3N1YnNjcmlwdGlvbklkfSlgKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkFOU1dFUl9TVEFSVCwgdGhpcywgc2RwKSlcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXNwb25zZSAtPiBvbkFkZEljZUNhbmRpZGF0ZVxuICAgIC8vIG1lc3NhZ2Ugb24gcGVlciByZXNwb25zZSAtPiBvbmFkZHN0cmVhbVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIGhhbmRsZUFuc3dlcjogc3RyZWFtTmFtZSxcbiAgICAgIHJlcXVlc3RJZDogc3Vic2NyaXB0aW9uSWQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNkcDogc2RwXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmRDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKE5BTUUsICdbc2VuZGNhbmRpZGF0ZV0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkNBTkRJREFURV9TVEFSVCwgdGhpcywgY2FuZGlkYXRlKSlcbiAgICAvLyBtZXNzYWdlIG9uIHBlZXIgcmVzcG9uc2UgLT4gb25pY2VjYW5kaWRhdGVcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVDYW5kaWRhdGU6IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSxcbiAgICAgIHJlcXVlc3RJZDogdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2FuZGlkYXRlOiBjYW5kaWRhdGVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZFN1YnNjcmliZSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZW5kc3Vic2NyaWJlXScpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgc3Vic2NyaWJlOiB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWRcbiAgICB9KVxuICB9XG5cbiAgb25TdHJlYW1BdmFpbGFibGUgKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uc3RyZWFtYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMuX2F2YWlsYWJpbGl0eVJlc29sdmVyLnJlc29sdmUodGhpcylcbiAgfVxuXG4gIG9uU3RyZWFtVW5hdmFpbGFibGUgKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgU3RyZWFtICR7dGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lfSBkb2VzIG5vdCBleGlzdC5gKVxuICAgIGRlYnVnKE5BTUUsICdbb25zdHJlYW11bmF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfSU5WQUxJRF9OQU1FLCB0aGlzKSlcbiAgICB0aGlzLl9hdmFpbGFiaWxpdHlSZXNvbHZlci5yZWplY3QoYFN0cmVhbSAke3RoaXMuX29wdGlvbnMuc3RyZWFtTmFtZX0gZG9lcyBub3QgZXhpc3QuYClcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5yZWplY3QoYFN0cmVhbSAke3RoaXMuX29wdGlvbnMuc3RyZWFtTmFtZX0gZG9lcyBub3QgZXhpc3QuYClcbiAgICB0aGlzLl9kaXNjb25uZWN0KClcbiAgfVxuXG4gIG9uU0RQU3VjY2VzcyAocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zZHBzdWNjZXNzXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICB9XG5cbiAgb25TRFBPZmZlciAocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zZHBvZmZlcl06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICBjb25zdCBzZHAgPSBuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihyZWNlaXB0LnNkcClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMpKVxuICAgIHRoaXMucmVxdWVzdEFuc3dlcihzZHApXG4gIH1cblxuICBvblNEUEVycm9yIChyZWNlaXB0KSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0ZBSUwsIHRoaXMsIHJlY2VpcHQpKVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyLnJlamVjdCgnSW52YWxpZCBTRFAuJylcbiAgICBlcnJvcihOQU1FLCAnW29uc2RwZXJyb3JdJylcbiAgICBlcnJvcihyZWNlaXB0KVxuICB9XG5cbiAgb25BbnN3ZXJNZWRpYVN0cmVhbSAoc3RyZWFtID0gdW5kZWZpbmVkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5BTlNXRVJfRU5ELCB0aGlzKSlcbiAgfVxuXG4gIG9uSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uaWNlY2FuZGlkYXRlXScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuQ0FORElEQVRFX0VORCwgdGhpcykpXG4gICAgdGhpcy5zZW5kQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgfVxuXG4gIG9uSWNlQ2FuZGlkYXRlVHJpY2tsZUVuZCAoc3RyZWFtKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbmljZXRyaWNrbGVlbmRdJylcbiAgICB0aGlzLl9nZXRWaWV3UmVzb2x2ZXJQcm9taXNlKClcbiAgICAgIC50aGVuKHZpZXcgPT4ge1xuICAgICAgICB2aWV3LmF0dGFjaFN0cmVhbShzdHJlYW0pXG4gICAgICB9KVxuICB9XG5cbiAgb25BZGRJY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKE5BTUUsICdbb25hZGRpY2VjYW5kaWRhdGVdJylcbiAgICB0aGlzLl9wZWVySGVscGVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gIH1cblxuICBvblNvY2tldEljZUNhbmRpZGF0ZUVuZCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnNvY2tldGljZWNhbmRpZGF0ZWVuZF0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLklDRV9UUklDS0xFX0NPTVBMRVRFLCB0aGlzKSlcbiAgICB0aGlzLnNlbmRTdWJzY3JpYmUoKVxuICB9XG5cbiAgb25Tb2NrZXRNZXNzYWdlRXJyb3IgKG1lc3NhZ2UsIGRldGFpbCA9IHVuZGVmaW5lZCkge1xuICAgIGVycm9yKE5BTUUsIGBFcnJvciBpbiBzdHJlYW0gc3Vic2NyaXB0aW9uOiAke21lc3NhZ2V9LlxcbltPcHRpb25hbCBkZXRhaWxdOiAke2RldGFpbH1gKVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyLnJlamVjdChgRXJyb3IgaW4gc3RyZWFtIHN1YnNjcmlwdGlvbjogJHttZXNzYWdlfS5gKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9GQUlMLCB0aGlzLCBtZXNzYWdlKSlcbiAgfVxuXG4gIG9uU29ja2V0Q2xvc2UgKGNsb3NlRXZlbnQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uc29ja2V0Y2xvc2VdJylcbiAgICBpZiAodGhpcy5fcGVlckhlbHBlcikge1xuICAgICAgdGhpcy5fcGVlckhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RJT05fQ0xPU0VELCB0aGlzLCBjbG9zZUV2ZW50KSlcbiAgfVxuXG4gIG9uUGVlckNvbm5lY3Rpb25DbG9zZSAoZXZlbnQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29ucGVlcmNvbm5lY3Rpb25jbG9zZV0nKVxuICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIHRoaXMub25Tb2NrZXRDbG9zZShldmVudClcbiAgfVxuXG4gIG9uVW5wdWJsaXNoICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29udW5wdWJsaXNoXScpXG4gICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIudW5wdWJsaXNoKClcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWV9VTlBVQkxJU0gsIHRoaXMpKVxuICB9XG5cbiAgb25Db25uZWN0aW9uQ2xvc2VkICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uY29ubmVjdGlvbmNsb3NlZF0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RJT05fQ0xPU0VELCB0aGlzKSlcbiAgfVxuXG4gIG9uU2VuZFJlY2VpdmVkIChtZXRob2ROYW1lLCBkYXRhKSB7XG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdvbk1ldGFEYXRhJykge1xuICAgICAgdGhpcy5vbk1ldGFEYXRhKGRhdGEpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZW52aXJvbm1lbnQuaW52b2tlKG1ldGhvZE5hbWUsIGRhdGEpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU0VORF9JTlZPS0UsIHRoaXMsIHtcbiAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSkpXG4gICAgfVxuICB9XG5cbiAgb25TdWJzY3JpYmVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3N1YnNjcmliZXJzdGF0dXNdIC0gJyArIEpTT04uc3RyaW5naWZ5KHN0YXR1cywgbnVsbCwgMikpXG4gICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdWJTdGFydFJlZ2V4LmV4ZWMoc3RhdHVzLm1lc3NhZ2UpXG4gICAgaWYgKHN0YXJ0UmVzdWx0ICYmIHN0YXJ0UmVzdWx0WzFdID09PSB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyLnJlc29sdmUodGhpcylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVEFSVCwgdGhpcykpXG4gICAgICB0aGlzLnBsYXlJZkF1dG9wbGF5U2V0KHRoaXMuX29wdGlvbnMsIHRoaXMuX3ZpZXcpXG4gICAgfVxuICB9XG5cbiAgb25NZXRhRGF0YSAobWV0YWRhdGEpIHtcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLm9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAmJiBtZXRhZGF0YS5vcmllbnRhdGlvbiAhPT0gdGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gbWV0YWRhdGEub3JpZW50YXRpb25cbiAgICAgIGVudmlyb25tZW50LmFwcGx5T3JpZW50YXRpb24odGhpcy5fdmlldy52aWV3LCBtZXRhZGF0YS5vcmllbnRhdGlvbilcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuaGFuZGxlT3JpZW50YXRpb25DaGFuZ2UocGFyc2VJbnQobWV0YWRhdGEub3JpZW50YXRpb24pKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuT1JJRU5UQVRJT05fQ0hBTkdFLCB0aGlzLCB7XG4gICAgICAgIG9yaWVudGF0aW9uOiBwYXJzZUludChtZXRhZGF0YS5vcmllbnRhdGlvbiksXG4gICAgICAgIHZpZXdFbGVtZW50OiB0aGlzLl92aWV3LnZpZXdcbiAgICAgIH0pKVxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHRoaXMsIG1ldGFkYXRhKSlcbiAgfVxuXG4gIF9jb25uZWN0IChpY2VTZXJ2ZXJzKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgdGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzID0gaWNlU2VydmVyc1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wZWVySGVscGVyLnNldFVwKHRoaXMuX29wdGlvbnMuaWNlU2VydmVycywgdW5kZWZpbmVkLCB0aGlzLl9vcHRpb25zLnJ0Y3BNdXhQb2xpY3kpXG4gICAgcC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdE9mZmVyKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCwgdGhpcy5fb3B0aW9ucy52aWRlb0VuY29kaW5nLCB0aGlzLl9vcHRpb25zLmF1ZGlvRW5jb2RpbmcpXG4gICAgfSlcbiAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgd2FybihOQU1FLCAnQ291bGQgbm90IGVzdGFibGlzaCBSVENQZWVyQ29ubmVjdGlvbi4nKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICB9KVxuICAgIC8vICBUT0RPOiBOb3JtYWxpemUgcmV0dXJucyB0byBlaXRoZXIgYWxsIGJlIGNoYWluYWJsZSBvciBub3QgYmUgY2hhaW5hYmxlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF9kaXNjb25uZWN0ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3RdJylcbiAgICBpZiAodGhpcy5fc29ja2V0SGVscGVyKSB7XG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIudGVhckRvd24oKVxuICAgIH1cbiAgICBpZiAodGhpcy5fcGVlckhlbHBlcikge1xuICAgICAgdGhpcy5fcGVlckhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICB9XG5cbiAgcGxheUlmQXV0b3BsYXlTZXQgKG9wdGlvbnMsIHZpZXcpIHtcbiAgICBpZiAob3B0aW9ucyAmJiB2aWV3KSB7XG4gICAgICBvcHRpb25zLmF1dG9wbGF5ID0gZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh2aWV3LnZpZXcsICdhdXRvcGxheScpXG4gICAgICBpZiAob3B0aW9ucy5hdXRvcGxheSkge1xuICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN1YnNjcmliZSAoKSB7XG4gICAgdGhpcy5fZ2V0Vmlld1Jlc29sdmVyUHJvbWlzZSgpXG4gICAgICAudGhlbih2aWV3ID0+IHtcbiAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlciA9IG5ldyBSVENTb3VyY2VIYW5kbGVyKHZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgICAgIHRoaXMuX2dsb21Tb3VyY2VIYW5kbGVyQVBJKHRoaXMuX3NvdXJjZUhhbmRsZXIpXG4gICAgICAgIHRoaXMuaW5pdEhhbmRsZXIodGhpcy5fb3B0aW9ucywgdGhpcy5fc291cmNlSGFuZGxlcilcbiAgICAgIH0pXG4gICAgdGhpcy5fZ2V0QXZhaWxhYmlsaXR5UmVzb2x2ZXJQcm9taXNlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3QodGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzKVxuICAgICAgfSlcbiAgICB0aGlzLl9zZXRWaWV3SWZOb3RFeGlzdCh0aGlzLl92aWV3LCB0aGlzLl9vcHRpb25zLm1lZGlhRWxlbWVudElkKVxuICAgIHRoaXMucmVxdWVzdEF2YWlsYWJpbGl0eSh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtVHlwZSlcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3Vic2NyaXB0aW9uUmVzb2x2ZXJQcm9taXNlKClcbiAgfVxuXG4gIHVuc3Vic2NyaWJlICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3Vuc3Vic2NyaWJlXScpXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLnN0b3AoKVxuICAgIHRoaXMuX2Rpc2Nvbm5lY3QoKVxuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuY2xlYW5VcCgpXG4gICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVE9QLCB0aGlzKSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgZ2V0Q29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEhlbHBlclxuICB9XG5cbiAgZ2V0UGVlckNvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZWVySGVscGVyID8gdGhpcy5fcGVlckhlbHBlci5jb25uZWN0aW9uIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUhhbmRsZXIgPyB0aGlzLl9zb3VyY2VIYW5kbGVyLmdldENvbnRyb2xzKCkgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gJ1JUQydcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUQ1N1YnNjcmliZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRjLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IFJUTVBTb3VyY2VIYW5kbGVyIGZyb20gJy4vcmVkNXByby1zb3VyY2UtaGFuZGxlci1ydG1wJ1xuaW1wb3J0IFBsYXliYWNrVmlldyBmcm9tICcuLi92aWV3L3BsYXliYWNrJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UsIEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzLCBSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFBsYXliYWNrU3RhdGVSZWFkYWJsZSB9IGZyb20gJy4vY29udHJvbHMvc3RhdGUnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUlRNUFN1YmNyaWJlcidcblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAncnRtcCcsXG4gIHBvcnQ6IDE5MzUsXG4gIHdpZHRoOiAzMjAsIC8vIG1lZGlhIHBsYXliYWNrXG4gIGhlaWdodDogMjQwLCAvLyBtZWRpYSBwbGF5YmFja1xuICBlbWJlZFdpZHRoOiAnMTAwJScsIC8vIERPTSBkaXNwbGF5IHN0eWxlXG4gIGVtYmVkSGVpZ2h0OiAnMTAwJScsIC8vIERPTSBkaXNwbGF5IHN0eWxlXG4gIG1pbkZsYXNoVmVyc2lvbjogJzEwLjAuMCcsXG4gIHN3ZjogJ2xpYi9yZWQ1cHJvL3JlZDVwcm8tc3Vic2NyaWJlci5zd2YnLFxuICBzd2ZvYmplY3RVUkw6ICdsaWIvc3dmb2JqZWN0L3N3Zm9iamVjdC5qcycsXG4gIHByb2R1Y3RJbnN0YWxsVXJsOiAnbGliL3N3Zm9iamVjdC9wbGF5ZXJQcm9kdWN0SW5zdGFsbC5zd2YnLFxuICBtZWRpYUVsZW1lbnRJZDogJ3JlZDVwcm8tc3Vic2NyaWJlcidcbn1cblxuY2xhc3MgUlRNUFN1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fZWxlbWVudElkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fZW1iZWRQcm9taXNlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fZ2V0RW1iZWRQcm9taXNlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5vbkVtYmVkQ29tcGxldGUoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5vbkVtYmVkRmFpbHVyZShlcnIpKVxuICAgIHRoaXMuX3ZpZXdSZXNvbHZlciA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gIH1cblxuICBfZ2V0Vmlld1Jlc29sdmVyUHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdSZXNvbHZlci5wcm9taXNlXG4gIH1cblxuICBfZ2V0U3Vic2NyaXB0aW9uUmVzb2x2ZXJQcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5wcm9taXNlXG4gIH1cblxuICBfZ2xvbVNvdXJjZUhhbmRsZXJBUEkgKGhhbmRsZXIpIHtcbiAgICB0aGlzLnBhdXNlID0gaGFuZGxlci5wYXVzZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5yZXN1bWUgPSBoYW5kbGVyLnJlc3VtZS5iaW5kKGhhbmRsZXIpXG4gICAgdGhpcy5zdG9wID0gaGFuZGxlci5zdG9wLmJpbmQoaGFuZGxlcilcbiAgICB0aGlzLm11dGUgPSBoYW5kbGVyLm11dGUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMudW5tdXRlID0gaGFuZGxlci51bm11dGUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc2V0Vm9sdW1lID0gaGFuZGxlci5zZXRWb2x1bWUuYmluZChoYW5kbGVyKVxuICAgIHRoaXMuc2Vla1RvID0gaGFuZGxlci5zZWVrVG8uYmluZChoYW5kbGVyKVxuICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbiA9IGhhbmRsZXIudG9nZ2xlRnVsbFNjcmVlbi5iaW5kKGhhbmRsZXIpXG4gICAgaGFuZGxlci5vbignKicsIChldmVudCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoZXZlbnQudHlwZSwgdGhpcywgZXZlbnQuZGF0YSkpXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRFbWJlZFByb21pc2UgKCkge1xuICAgIHRoaXMuX2VtYmVkUHJvbWlzZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2VtYmVkUHJvbWlzZSlcbiAgICByZXR1cm4gdGhpcy5fZW1iZWRQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIF9zZXRWaWV3SWZOb3RFeGlzdCAoY3VycmVudFZpZXcsIG1lZGlhRWxlbWVudElkID0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWaWV3ID09PSAndW5kZWZpbmVkJyAmJiBtZWRpYUVsZW1lbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IFBsYXliYWNrVmlldyhtZWRpYUVsZW1lbnRJZClcbiAgICAgICAgdmlldy5hdHRhY2hTdWJzY3JpYmVyKHRoaXMpXG4gICAgICB9XG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gfHwgZGVmYXVsdE9wdGlvbnMubWluRmxhc2hWZXJzaW9uXG4gICAgaWYgKCFlbnZpcm9ubWVudC5zdXBwb3J0c0ZsYXNoVmVyc2lvbih2ZXJzaW9uKSkge1xuICAgICAgd2FybihOQU1FLCBgQ291bGQgbm90IHJlc29sdmUgUlRNUFN1YnNjcmliZXIgaW5zdGFuY2UuIFJlcXVpcmVzIG1pbmltdW0gRmxhc2ggUGxheWVyIGluc3RhbGwgb2YgJHt2ZXJzaW9ufS5gKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgcmVzb2x2ZSBSVE1QU3Vic2NyaWJlciBpbnN0YW5jZS4gUmVxdWlyZXMgbWluaW11bSBGbGFzaCBQbGF5ZXIgaW5zdGFsbCBvZiAke3ZlcnNpb259LmApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuXG4gICAgICBjb25zdCBlc3RhYmxpc2hTb3VyY2VIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgIHRoaXMuX2dldFZpZXdSZXNvbHZlclByb21pc2UoKVxuICAgICAgICAudGhlbih2aWV3ID0+IHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gbmV3IFJUTVBTb3VyY2VIYW5kbGVyKHRoaXMsIHZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgICAgICAgdGhpcy5fZ2xvbVNvdXJjZUhhbmRsZXJBUEkodGhpcy5fc291cmNlSGFuZGxlcilcbiAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGZkID0gdGhpcy5fZW1iZWRQcm9taXNlXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZSh0aGlzLl9lbGVtZW50SWQsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgICAgICAgIC50aGVuKHN1YnNjcmliZXJJZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMoc3Vic2NyaWJlcklkKVxuICAgICAgICAgICAgICAgIGRmZC5yZXNvbHZlKHRoaXMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gZGZkLnJlamVjdChlcnIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgZW52aXJvbm1lbnQuaW5qZWN0U2NyaXB0KHRoaXMuX29wdGlvbnMuc3dmb2JqZWN0VVJMKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkRGZkID0gdGhpcy5fZW1iZWRQcm9taXNlXG4gICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnU1dGT2JqZWN0IGVtYmVkZGVkLicpXG4gICAgICAgICAgICBpZiAodGhpcy5fc291cmNlSGFuZGxlcikge1xuICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZSh0aGlzLl9lbGVtZW50SWQsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oc3Vic2NyaWJlcklkID0+IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2VzdGFibGlzaEV4dEludEhhbmRsZXJzKHN1YnNjcmliZXJJZClcbiAgICAgICAgICAgICAgICAgIGVtYmVkRGZkLnJlc29sdmUodGhpcylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgZW1iZWREZmQucmVqZWN0KGVycilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RW1iZWRQcm9taXNlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzdGFibGlzaFNvdXJjZUhhbmRsZXIoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NldFZpZXdJZk5vdEV4aXN0KHRoaXMuX3ZpZXcsIHRoaXMuX29wdGlvbnMubWVkaWFFbGVtZW50SWQpXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgZW1iZWQgRmxhc2gtYmFzZWQgUlRNUCBQbGF5ZXIuIFJlYXNvbjogJHtlcnJ9YClcbiAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgdGhpcykpXG4gICAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgaW5qZWN0IEZsYXNoLWJhc2VkIFBsYXllciBpbnRvIHRoZSBwYWdlLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCB0aGlzKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIF9lc3RhYmxpc2hFeHRJbnRIYW5kbGVycyAoaWQpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgU3Vic2NyaWJlciBJRCBwcm92aWRlZCB0byBjbGllbnQ6ICgke2lkfSkuYClcbiAgICBjb25zdCBpbnZva2VGbiA9IChsYWJlbCkgPT4ge1xuICAgICAgcmV0dXJuIFsnc3Vic2NyaWJlcicsIGxhYmVsLCBpZF0uam9pbignXycpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0Q2xvc2VkJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVElPTl9DTE9TRUQsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0U3VjY2VzcycpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUywgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RGYWlsdXJlJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVN0b3AnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RPUCwgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZU1ldGFkYXRhJyldID0gKG1ldGFkYXRhKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHRoaXMsIEpTT04ucGFyc2UobWV0YWRhdGEpKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlVW5wdWJsaXNoJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWV9VTlBVQkxJU0gsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVTZW5kSW52b2tlJyldID0gKHBheWxvYWQpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TRU5EX0lOVk9LRSwgdGhpcywgdHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShwYXlsb2FkKSA6IHBheWxvYWQpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlUGxheVJlcXVlc3QnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLnBsYXkoKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlU3RhcnQnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5yZXNvbHZlKHRoaXMpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RBUlQsIHRoaXMpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlSW52YWxpZE5hbWUnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25SZXNvbHZlci5yZWplY3QodGhpcylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9JTlZBTElEX05BTUUsIHRoaXMpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlRmFpbCcpXSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvblJlc29sdmVyLnJlamVjdCh0aGlzKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0ZBSUwsIHRoaXMpKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlVm9sdW1lQ2hhbmdlJyldID0gKHBheWxvYWQpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIHRoaXMsIHtcbiAgICAgICAgdm9sdW1lOiBKU09OLnBhcnNlKHBheWxvYWQpLnZvbHVtZVxuICAgICAgfSkpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVQbGF5YmFja1RpbWVDaGFuZ2UnKV0gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocGF5bG9hZClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1RJTUVfVVBEQVRFLCB0aGlzLCB7XG4gICAgICAgIHRpbWU6IGRhdGEudmFsdWUsXG4gICAgICAgIGR1cmF0aW9uOiBkYXRhLmR1cmF0aW9uXG4gICAgICB9KSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVBsYXliYWNrU3RhdGVDaGFuZ2UnKV0gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgY29uc3QgY29kZSA9IEpTT04ucGFyc2UocGF5bG9hZCkuY29kZVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB0aGlzLCB7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIHN0YXRlOiBQbGF5YmFja1N0YXRlUmVhZGFibGVbY29kZV1cbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIG9uRW1iZWRDb21wbGV0ZSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tlbWJlZDpjb21wbGV0ZV0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9TVUNDRVNTLCB0aGlzKSlcbiAgfVxuXG4gIG9uRW1iZWRGYWlsdXJlIChlcnIpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW2VtYmVkOmZhaWx1cmVdIC0gJHtlcnJ9YClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgdGhpcykpXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3LCBlbGVtZW50SWQpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIHRoaXMuX2VsZW1lbnRJZCA9IGVsZW1lbnRJZFxuICAgIHRoaXMuX3ZpZXdSZXNvbHZlci5yZXNvbHZlKHRoaXMuX3ZpZXcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgcGxheSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1twbGF5XScpO1xuICAgIHRoaXMuX2dldEVtYmVkUHJvbWlzZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5wbGF5KClcbiAgICB9KVxuICB9XG5cbiAgc3Vic2NyaWJlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3Vic2NyaXB0aW9uUmVzb2x2ZXJQcm9taXNlKClcbiAgfVxuXG4gIHVuc3Vic2NyaWJlICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3Vuc3Vic2NyaWJlXScpO1xuICAgIGNvbnN0IGNiID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5jbGVhblVwKClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShjYilcbiAgfVxuXG4gIGdldENvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VIYW5kbGVyXG4gIH1cblxuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUhhbmRsZXIgPyB0aGlzLl9zb3VyY2VIYW5kbGVyLmdldENvbnRyb2xzKCkgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gJ1JUTVAnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVE1QU3Vic2NyaWJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1ydG1wLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgUGxheWJhY2tDb250cm9sc0ltcGwgfSBmcm9tICcuL2NvbnRyb2xzJ1xuaW1wb3J0IHsgUGxheWJhY2tTdGF0ZSwgUGxheWJhY2tTdGF0ZVJlYWRhYmxlIH0gZnJvbSAnLi9jb250cm9scy9zdGF0ZSdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudCwgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ0hMU1NvdXJjZUhhbmRsZXInXG5cbmNsYXNzIEhMU1NvdXJjZUhhbmRsZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yIChtZWRpYSwgdHlwZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm1lZGlhID0gbWVkaWFcbiAgICB0aGlzLmNsb25lID0gdGhpcy5tZWRpYS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlciA9IHRoaXMuZGV0ZXJtaW5lSG9sZGVyKG1lZGlhKVxuICAgIHRoaXMucGxheWVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9pc1ZPRCA9IGZhbHNlXG4gICAgdGhpcy5fY29udHJvbHMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wbGF5YmFja05vdGlmaWNhdGlvbkNlbnRlciA9IHRoaXMubWVkaWFcbiAgICBlbnZpcm9ubWVudC5vbkZ1bGxTY3JlZW5TdGF0ZUNoYW5nZSh0aGlzLl9oYW5kbGVGdWxsU2NyZWVuQ2hhbmdlLmJpbmQodGhpcykpXG4gIH1cblxuICBkZXRlcm1pbmVIb2xkZXIgKG1lZGlhKSB7XG4gICAgaWYgKG1lZGlhLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lcicpKSB7XG4gICAgICByZXR1cm4gbWVkaWEucGFyZW50Tm9kZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG1lZGlhLnBhcmVudE5vZGVcbiAgICAgIGNvbnN0IGRpdiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXInKVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShkaXYsIG1lZGlhKVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG1lZGlhKVxuICAgICAgZGl2LmFwcGVuZENoaWxkKG1lZGlhKVxuICAgICAgcmV0dXJuIGRpdlxuICAgIH1cbiAgfVxuXG4gIGNsZWFuVXAgKCkge1xuICAgIC8vIFJldHVybiB0byBwcmlvciBET00gbWFuaXB1bGF0aW9uLlxuICAgIHRoaXMubWVkaWEucmVtb3ZlKClcbiAgICB0aGlzLm1lZGlhID0gdGhpcy5jbG9uZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLm1lZGlhKVxuICB9XG5cbiAgZ2V0IGlzVk9EICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWT0RcbiAgfVxuXG4gIHNldCBpc1ZPRCAodmFsdWUpIHtcbiAgICB0aGlzLl9pc1ZPRCA9IHZhbHVlXG4gICAgaWYgKHRoaXMuX2NvbnRyb2xzKSB7XG4gICAgICB0aGlzLl9jb250cm9scy5zZXRBc1ZPRCh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICBfYWRkUGxheWJhY2tIYW5kbGVycyAobm90aWZpZXIpIHtcbiAgICBjb25zdCBjb250cm9scyA9IHRoaXMuZ2V0Q29udHJvbHMoKVxuICAgIGNvbnN0IGhhc0NvbnRyb2xzID0gdHlwZW9mIGNvbnRyb2xzICE9PSAndW5kZWZpbmVkJ1xuXG4gICAgbm90aWZpZXIub25jYW5wbGF5ID0gKCkgPT4ge1xuICAgICAgaWYgKGNvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLmVuYWJsZVBsYXlQYXVzZSh0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEUsXG4gICAgICAgIHN0YXRlOiBQbGF5YmFja1N0YXRlUmVhZGFibGVbUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEVdXG4gICAgICB9KSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICB2b2x1bWU6IG5vdGlmaWVyLnZvbHVtZVxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9uZHVyYXRpb25jaGFuZ2UgPSAoZXZlbnQpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaWYgKCFpc05hTihub3RpZmllci5kdXJhdGlvbikgJiYgTnVtYmVyLmlzRmluaXRlKG5vdGlmaWVyLmR1cmF0aW9uKSkge1xuICAgICAgICB0aGlzLmlzVk9EID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFBsYXliYWNrRHVyYXRpb24obm90aWZpZXIuZHVyYXRpb24pXG4gICAgICB9XG4gICAgfVxuICAgIG5vdGlmaWVyLm9uZW5kZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY29udHJvbHMuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5JRExFKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5JRExFLFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuSURMRV1cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnRpbWV1cGRhdGUgPSAoZXZlbnQpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFNlZWtUaW1lKG5vdGlmaWVyLmN1cnJlbnRUaW1lLCBzZWxmLmlzVk9EID8gbm90aWZpZXIuZHVyYXRpb24gOiB1bmRlZmluZWQpXG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19USU1FX1VQREFURSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHRpbWU6IG5vdGlmaWVyLmN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogbm90aWZpZXIuZHVyYXRpb25cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnNlZWtlZCA9IChldmVudCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4vLyAgICAgIGRlYnVnKE5BTUUsICdTZWVrZWQuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25zZWVraW5nID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbi8vICAgICAgZGVidWcoTkFNRSwgJ1NlZWtpbmcuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25wbGF5ID0gKCkgPT4ge1xuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuUExBWUlORylcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUExBWUlORyxcbiAgICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLlBMQVlJTkddXG4gICAgICB9KSlcbiAgICB9XG4gICAgbm90aWZpZXIub25wYXVzZSA9ICgpID0+IHtcbiAgICAgIGlmIChoYXNDb250cm9scykge1xuICAgICAgICBjb250cm9scy5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLlBBVVNFRClcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUEFVU0VELFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuUEFVU0VEXVxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9udm9sdW1lY2hhbmdlID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGlmIChoYXNDb250cm9scyAmJiBjb250cm9scy5nZXRWb2x1bWUoKSAhPT0gdGhpcy5tZWRpYS52b2x1bWUpIHtcbiAgICAgICAgY29udHJvbHMuc2V0Vm9sdW1lKHRoaXMubWVkaWEudm9sdW1lKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVk9MVU1FX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHZvbHVtZTogbm90aWZpZXIubXV0ZWQgPyAwIDogbm90aWZpZXIudm9sdW1lXG4gICAgICB9KSlcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlRnVsbFNjcmVlbkNoYW5nZSAoaXNGdWxsU2NyZWVuKSB7XG4gICAgaWYgKGlzRnVsbFNjcmVlbikge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgdGhpcy5tZWRpYS5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgdGhpcy5tZWRpYS5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkZVTExfU0NSRUVOX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCBpc0Z1bGxTY3JlZW4pKVxuICB9XG5cbiAgZW1iZWRNZWRpYVNvdXJjZSAodXJsLCB0eXBlLCBvcHRpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdHJ5IHtcbiAgICAgIGxldCBzb3VyY2UgPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKVxuICAgICAgc291cmNlLnR5cGUgPSB0eXBlXG4gICAgICBzb3VyY2Uuc3JjID0gdXJsXG4gICAgICBpZiAodGhpcy5tZWRpYS5maXJzdENoaWxkKSB7XG4gICAgICAgIHRoaXMubWVkaWEuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgdGhpcy5tZWRpYS5maXJzdENoaWxkKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubWVkaWEuYXBwZW5kQ2hpbGQoc291cmNlKVxuICAgICAgfVxuICAgICAgc2VsZi5vcmllbnRhdGlvbiA9IDBcbiAgICAgIGVudmlyb25tZW50Lm9uT3JpZW50YXRpb25NZXRhZGF0YSh0aGlzLm1lZGlhLCAobWV0YWRhdGEpID0+IHtcbiAgICAgICAgZGVidWcoTkFNRSwgJ01ldGFkYXRhIHJlY2VpdmVkOiAnICsgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEsIG51bGwsIDIpKVxuICAgICAgICBpZiAoc2VsZi5vcmllbnRhdGlvbiAhPT0gbWV0YWRhdGEub3JpZW50YXRpb24pIHtcbiAgICAgICAgICBzZWxmLm9yaWVudGF0aW9uID0gbWV0YWRhdGEub3JpZW50YXRpb25cbiAgICAgICAgICBlbnZpcm9ubWVudC5hcHBseU9yaWVudGF0aW9uKHNlbGYubWVkaWEsIG1ldGFkYXRhLm9yaWVudGF0aW9uKVxuICAgICAgICAgIHNlbGYuaGFuZGxlT3JpZW50YXRpb25DaGFuZ2UocGFyc2VJbnQoc2VsZi5vcmllbnRhdGlvbikpXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuT1JJRU5UQVRJT05fQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiBwYXJzZUludChzZWxmLm9yaWVudGF0aW9uKSxcbiAgICAgICAgICAgIHZpZXdFbGVtZW50OiBzZWxmLm1lZGlhXG4gICAgICAgICAgfSkpXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX01FVEFEQVRBLCB1bmRlZmluZWQsIG1ldGFkYXRhKSlcbiAgICAgICAgfVxuICAgICAgICBzZWxmLm9yaWVudGF0aW9uID0gbWV0YWRhdGEub3JpZW50YXRpb25cbiAgICAgICAgfSlcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGFkZFNvdXJjZSAodXJsLCB0eXBlLCBvcHRpb25zKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IGhhc0RlZmluZWRDb250cm9scyA9IG9wdGlvbnMuY29udHJvbHNcbiAgICBjb25zdCBpc011dGVkID0gZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh0aGlzLm1lZGlhLCAnbXV0ZWQnKVxuICAgIGNvbnN0IHVzZVBsYXliYWNrQ29udHJvbHMgPSBlbnZpcm9ubWVudC5oYXNBdHRyaWJ1dGVEZWZpbmVkKHRoaXMubWVkaWEsICdjb250cm9scycpICYmIGVudmlyb25tZW50Lmhhc0NsYXNzRGVmaW5lZCh0aGlzLm1lZGlhLCAncmVkNXByby1tZWRpYScpXG4gICAgdGhpcy5lbWJlZE1lZGlhU291cmNlKHVybCwgdHlwZSwgb3B0aW9ucylcbiAgICAgIC50aGVuKCAoKSA9PiB7XG4gICAgICAgIGlmIChoYXNEZWZpbmVkQ29udHJvbHMgfHwgdXNlUGxheWJhY2tDb250cm9scykge1xuICAgICAgICAgIGlmIChoYXNEZWZpbmVkQ29udHJvbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xzID0gb3B0aW9ucy5jb250cm9sc1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xzID0gbmV3IFBsYXliYWNrQ29udHJvbHNJbXBsKHRoaXMsIHRoaXMuaG9sZGVyKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1lZGlhLmNvbnRyb2xzID0gZmFsc2VcbiAgICAgICAgICB0aGlzLl9jb250cm9scy5zZXRBc1ZPRCh0aGlzLmlzVk9EKVxuICAgICAgICAgIHRoaXMuX2NvbnRyb2xzLnNldE11dGVkU3RhdGUoaXNNdXRlZClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRQbGF5YmFja0hhbmRsZXJzKHRoaXMuX3BsYXliYWNrTm90aWZpY2F0aW9uQ2VudGVyKVxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiBkZWZlcnJlZC5yZWplY3QoZSkpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdF0nKVxuICB9XG5cbiAgcGxheSAoKSB7XG4gICAgdGhpcy5tZWRpYS5wbGF5KClcbiAgfVxuXG5cbiAgcGF1c2UgKCkge1xuICAgIHRoaXMubWVkaWEucGF1c2UoKVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICB0aGlzLm1lZGlhLnBsYXkoKVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubWVkaWEuc3RvcCgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyBvay5cbiAgICB9XG4gIH1cblxuICBtdXRlICgpIHtcbiAgICB0aGlzLm1lZGlhLm11dGVkID0gdHJ1ZVxuICB9XG5cbiAgdW5tdXRlICgpIHtcbiAgICB0aGlzLm1lZGlhLm11dGVkID0gZmFsc2VcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBzZXRWb2x1bWUgKHZhbHVlKSB7XG4gICAgdGhpcy51bm11dGUoKVxuICAgIHRoaXMubWVkaWEudm9sdW1lID0gdmFsdWVcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBzZWVrVG8gKHBlcmNlbnRhZ2UsIGR1cmF0aW9uID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IGR1cmF0aW9uID8gcGVyY2VudGFnZSAqIGR1cmF0aW9uIDogcGVyY2VudGFnZVxuICB9XG5cbiAgdG9nZ2xlRnVsbFNjcmVlbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGVudmlyb25tZW50LnRvZ2dsZUZ1bGxTY3JlZW4odGhpcy5ob2xkZXIpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gIH1cblxuICB1bnB1Ymxpc2ggKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnN0b3AoKVxuICAgICAgdGhpcy5tZWRpYS5vbmVuZGVkLmNhbGwodGhpcy5tZWRpYSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tkaXNjb25uZWN0XScpXG4gICAgdGhpcy5jbGVhblVwKClcbiAgfVxuXG4gIGhhbmRsZU9yaWVudGF0aW9uQ2hhbmdlIChvcmllbnRhdGlvbikge1xuICAgIGlmICh0aGlzLl9jb250cm9scyAmJiAob3JpZW50YXRpb24gJSAxODAgIT09IDApKSB7XG4gICAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWJhY2tncm91bmQnKVxuICAgICAgdGhpcy5tZWRpYS5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWJhY2tncm91bmQnKVxuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgc2VuZFRvU2hhcmVkT2JqZWN0IChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29ubmVjdFRvU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjbG9zZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge31cblxuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBITFNTb3VyY2VIYW5kbGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXNvdXJjZS1oYW5kbGVyLWhscy5qcyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IFBsYXliYWNrQ29udHJvbHNJbXBsIH0gZnJvbSAnLi9jb250cm9scydcbmltcG9ydCB7IFBsYXliYWNrU3RhdGUsIFBsYXliYWNrU3RhdGVSZWFkYWJsZSB9IGZyb20gJy4vY29udHJvbHMvc3RhdGUnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQsIFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSVENTb3VyY2VIYW5kbGVyJ1xuXG5jbGFzcyBSVENTb3VyY2VIYW5kbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAobWVkaWEsIHR5cGUpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhXG4gICAgdGhpcy5jbG9uZSA9IHRoaXMubWVkaWEuY2xvbmVOb2RlKHRydWUpXG4gICAgdGhpcy5ob2xkZXIgPSB0aGlzLmRldGVybWluZUhvbGRlcih0aGlzLm1lZGlhKVxuICAgIHRoaXMucGxheWVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9pc1ZPRCA9IGZhbHNlXG4gICAgdGhpcy5fY29udHJvbHMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wbGF5YmFja05vdGlmaWNhdGlvbkNlbnRlciA9IHRoaXMubWVkaWFcbiAgICBlbnZpcm9ubWVudC5vbkZ1bGxTY3JlZW5TdGF0ZUNoYW5nZSh0aGlzLl9oYW5kbGVGdWxsU2NyZWVuQ2hhbmdlLmJpbmQodGhpcykpXG4gIH1cblxuICBkZXRlcm1pbmVIb2xkZXIgKG1lZGlhKSB7XG4gICAgaWYgKG1lZGlhLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lcicpKSB7XG4gICAgICByZXR1cm4gbWVkaWEucGFyZW50Tm9kZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG1lZGlhLnBhcmVudE5vZGVcbiAgICAgIGNvbnN0IGRpdiA9IGVudmlyb25tZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXInKVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShkaXYsIG1lZGlhKVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG1lZGlhKVxuICAgICAgZGl2LmFwcGVuZENoaWxkKG1lZGlhKVxuICAgICAgcmV0dXJuIGRpdlxuICAgIH1cbiAgfVxuXG4gIGNsZWFuVXAgKCkge1xuICAgIC8vIFJldHVybiB0byBwcmlvciBET00gbWFuaXB1bGF0aW9uLlxuICAgIHRoaXMubWVkaWEucmVtb3ZlKClcbiAgICB0aGlzLm1lZGlhID0gdGhpcy5jbG9uZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLm1lZGlhKVxuICB9XG5cbiAgZ2V0IGlzVk9EICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWT0RcbiAgfVxuXG4gIHNldCBpc1ZPRCAodmFsdWUpIHtcbiAgICB0aGlzLl9pc1ZPRCA9IHZhbHVlXG4gICAgaWYgKHRoaXMuX2NvbnRyb2xzKSB7XG4gICAgICB0aGlzLl9jb250cm9scy5zZXRBc1ZPRCh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICBfYWRkUGxheWJhY2tIYW5kbGVycyAobm90aWZpZXIpIHtcbiAgICBjb25zdCBjb250cm9scyA9IHRoaXMuZ2V0Q29udHJvbHMoKVxuICAgIGNvbnN0IGhhc0NvbnRyb2xzID0gdHlwZW9mIGNvbnRyb2xzICE9PSAndW5kZWZpbmVkJ1xuXG4gICAgbm90aWZpZXIub25jYW5wbGF5ID0gKCkgPT4ge1xuICAgICAgaWYgKGNvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLmVuYWJsZVBsYXlQYXVzZSh0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEUsXG4gICAgICAgIHN0YXRlOiBQbGF5YmFja1N0YXRlUmVhZGFibGVbUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEVdXG4gICAgICB9KSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIHVuZGVmaW5lZCwge1xuICAgICAgICB2b2x1bWU6IG5vdGlmaWVyLnZvbHVtZVxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9uZHVyYXRpb25jaGFuZ2UgPSAoZXZlbnQpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaWYgKCFpc05hTihub3RpZmllci5kdXJhdGlvbikgJiYgTnVtYmVyLmlzRmluaXRlKG5vdGlmaWVyLmR1cmF0aW9uKSkge1xuICAgICAgICB0aGlzLmlzVk9EID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFBsYXliYWNrRHVyYXRpb24obm90aWZpZXIuZHVyYXRpb24pXG4gICAgICB9XG4gICAgfVxuICAgIG5vdGlmaWVyLm9uZW5kZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY29udHJvbHMuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5JRExFKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCB1bmRlZmluZWQsIHtcbiAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5JRExFLFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuSURMRV1cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnRpbWV1cGRhdGUgPSAoZXZlbnQpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFNlZWtUaW1lKG5vdGlmaWVyLmN1cnJlbnRUaW1lLCBzZWxmLmlzVk9EID8gbm90aWZpZXIuZHVyYXRpb24gOiB1bmRlZmluZWQpXG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZQkFDS19USU1FX1VQREFURSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHRpbWU6IG5vdGlmaWVyLmN1cnJlbnRUaW1lLFxuICAgICAgICBkdXJhdGlvbjogbm90aWZpZXIuZHVyYXRpb25cbiAgICAgIH0pKVxuICAgIH1cbiAgICBub3RpZmllci5vbnNlZWtlZCA9IChldmVudCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4vLyAgICAgIGRlYnVnKE5BTUUsICdTZWVrZWQuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25zZWVraW5nID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbi8vICAgICAgZGVidWcoTkFNRSwgJ1NlZWtpbmcuJylcbiAgICB9XG4gICAgbm90aWZpZXIub25wbGF5ID0gKCkgPT4ge1xuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuUExBWUlORylcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUExBWUlORyxcbiAgICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLlBMQVlJTkddXG4gICAgICB9KSlcbiAgICB9XG4gICAgbm90aWZpZXIub25wYXVzZSA9ICgpID0+IHtcbiAgICAgIGlmIChoYXNDb250cm9scykge1xuICAgICAgICBjb250cm9scy5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLlBBVVNFRClcbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGNvZGU6IFBsYXliYWNrU3RhdGUuUEFVU0VELFxuICAgICAgICBzdGF0ZTogUGxheWJhY2tTdGF0ZVJlYWRhYmxlW1BsYXliYWNrU3RhdGUuUEFVU0VEXVxuICAgICAgfSkpXG4gICAgfVxuICAgIG5vdGlmaWVyLm9udm9sdW1lY2hhbmdlID0gKGV2ZW50KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGlmIChoYXNDb250cm9scyAmJiBjb250cm9scy5nZXRWb2x1bWUoKSAhPT0gdGhpcy5tZWRpYS52b2x1bWUpIHtcbiAgICAgICAgY29udHJvbHMuc2V0Vm9sdW1lKHRoaXMubWVkaWEudm9sdW1lKVxuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuVk9MVU1FX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIHZvbHVtZTogbm90aWZpZXIubXV0ZWQgPyAwIDogbm90aWZpZXIudm9sdW1lXG4gICAgICB9KSlcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlRnVsbFNjcmVlbkNoYW5nZSAoaXNGdWxsU2NyZWVuKSB7XG4gICAgaWYgKGlzRnVsbFNjcmVlbikge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgdGhpcy5tZWRpYS5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgdGhpcy5tZWRpYS5jbGFzc0xpc3QucmVtb3ZlKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkZVTExfU0NSRUVOX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCBpc0Z1bGxTY3JlZW4pKVxuIH1cblxuICBhZGRTb3VyY2UgKG9wdGlvbnMpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2FkZHNvdXJjZV0nKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3QgaGFzRGVmaW5lZENvbnRyb2xzID0gb3B0aW9ucy5jb250cm9sc1xuICAgIGNvbnN0IGlzTXV0ZWQgPSBlbnZpcm9ubWVudC5oYXNBdHRyaWJ1dGVEZWZpbmVkKHRoaXMubWVkaWEsICdtdXRlZCcpXG4gICAgY29uc3QgdXNlUGxheWJhY2tDb250cm9scyA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ2NvbnRyb2xzJykgJiYgZW52aXJvbm1lbnQuaGFzQ2xhc3NEZWZpbmVkKHRoaXMubWVkaWEsICdyZWQ1cHJvLW1lZGlhJylcbiAgICBpZiAoaGFzRGVmaW5lZENvbnRyb2xzIHx8IHVzZVBsYXliYWNrQ29udHJvbHMpIHtcbiAgICAgIGlmIChoYXNEZWZpbmVkQ29udHJvbHMpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHMgPSBuZXcgUGxheWJhY2tDb250cm9sc0ltcGwodGhpcywgdGhpcy5ob2xkZXIpXG4gICAgICB9XG4gICAgICB0aGlzLm1lZGlhLmNvbnRyb2xzID0gZmFsc2VcbiAgICAgIHRoaXMuX2NvbnRyb2xzLnNldEFzVk9EKHRoaXMuaXNWT0QpXG4gICAgICB0aGlzLl9jb250cm9scy5zZXRNdXRlZFN0YXRlKGlzTXV0ZWQpXG4gICAgfVxuICAgIHRoaXMuX2FkZFBsYXliYWNrSGFuZGxlcnModGhpcy5fcGxheWJhY2tOb3RpZmljYXRpb25DZW50ZXIpXG4gICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdF0nKVxuICB9XG5cbiAgcGxheSAoKSB7XG4gICAgdGhpcy5tZWRpYS5wbGF5KClcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICB0aGlzLm1lZGlhLnBhdXNlKClcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgdGhpcy5tZWRpYS5wbGF5KClcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm1lZGlhLnN0b3AoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgLy8gb2suXG4gICAgfVxuICB9XG5cbiAgbXV0ZSAoKSB7XG4gICAgdGhpcy5tZWRpYS5tdXRlZCA9IHRydWVcbiAgfVxuXG4gIHVubXV0ZSAoKSB7XG4gICAgdGhpcy5tZWRpYS5tdXRlZCA9IGZhbHNlXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgc2V0Vm9sdW1lICh2YWx1ZSkge1xuICAgIHRoaXMudW5tdXRlKClcbiAgICB0aGlzLm1lZGlhLnZvbHVtZSA9IHZhbHVlXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgc2Vla1RvIChwZXJjZW50YWdlLCBkdXJhdGlvbiA9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubWVkaWEuY3VycmVudFRpbWUgPSBkdXJhdGlvbiA/IHBlcmNlbnRhZ2UgKiBkdXJhdGlvbiA6IHBlcmNlbnRhZ2VcbiAgfVxuXG4gIHRvZ2dsZUZ1bGxTY3JlZW4gKCkge1xuICAgIHRyeSB7XG4gICAgICBlbnZpcm9ubWVudC50b2dnbGVGdWxsU2NyZWVuKHRoaXMuaG9sZGVyKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICB9XG5cbiAgdW5wdWJsaXNoICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zdG9wKClcbiAgICAgIHRoaXMubWVkaWEub25lbmRlZC5jYWxsKHRoaXMubWVkaWEpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyBuYWRhLlxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdF0nKVxuICAgIHRoaXMuY2xlYW5VcCgpXG4gIH1cblxuICBoYW5kbGVPcmllbnRhdGlvbkNoYW5nZSAob3JpZW50YXRpb24pIHtcbiAgICBpZiAodGhpcy5fY29udHJvbHMgJiYgKG9yaWVudGF0aW9uICUgMTgwICE9PSAwKSkge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmFkZCgncmVkNXByby1tZWRpYS1iYWNrZ3JvdW5kJylcbiAgICAgIHRoaXMubWVkaWEuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1iYWNrZ3JvdW5kJylcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgYWRkU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICByZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBnZXRSZW1vdGVTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHt9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGNvbm5lY3RUb1NoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge31cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY2xvc2VTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHt9XG5cbiAgZ2V0Q29udHJvbHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyVHlwZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRDU291cmNlSGFuZGxlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1zb3VyY2UtaGFuZGxlci1ydGMuanMiLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgKiBhcyBlbWJlZCBmcm9tICcuLi9lbnYvZW1iZWQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIgZnJvbSAnLi4vaGVscGVyL3NoYXJlZG9iamVjdC1oZWxwZXItcnRtcCdcbmltcG9ydCB7IFBsYXliYWNrQ29udHJvbHNJbXBsIH0gZnJvbSAnLi9jb250cm9scydcbmltcG9ydCB7IFBsYXliYWNrU3RhdGUsIFBsYXliYWNrU3RhdGVSZWFkYWJsZSB9IGZyb20gJy4vY29udHJvbHMvc3RhdGUnXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQsIFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSVE1QU291cmNlSGFuZGxlcidcblxuY29uc3QgdG9JbnQgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUucGFyc2VJbnQoMTApXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpXG4gIH1cbn1cblxuY29uc3QgaXNWT0RTdHJlYW1OYW1lID0gKHN0cmVhbU5hbWUpID0+IHtcbiAgcmV0dXJuIC9eLipcXC4oZmx2fG1wNHxtcDMpLy50ZXN0KHN0cmVhbU5hbWUpXG59XG5cbmNsYXNzIFJUTVBTb3VyY2VIYW5kbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAobm90aWZpY2F0aW9uQ2VudGVyLCBtZWRpYSwgdHlwZSwgc29SZXNwb25kZXIgPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZWRpYSA9IG1lZGlhXG4gICAgdGhpcy5jbG9uZSA9IHRoaXMubWVkaWEuY2xvbmVOb2RlKHRydWUpXG4gICAgdGhpcy5ob2xkZXIgPSB0aGlzLmRldGVybWluZUhvbGRlcih0aGlzLm1lZGlhKVxuICAgIHRoaXMucGxheWVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9zd2ZJZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2NvbnRyb2xzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc29SZXNwb25kZXIgPSBzb1Jlc3BvbmRlciB8fCBuZXcgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIoKVxuICAgIHRoaXMuX3BsYXliYWNrTm90aWZpY2F0aW9uQ2VudGVyID0gbm90aWZpY2F0aW9uQ2VudGVyXG4gICAgZW52aXJvbm1lbnQub25GdWxsU2NyZWVuU3RhdGVDaGFuZ2UodGhpcy5faGFuZGxlRnVsbFNjcmVlbkNoYW5nZS5iaW5kKHRoaXMpKVxuICB9XG5cbiAgZGV0ZXJtaW5lSG9sZGVyIChtZWRpYSkge1xuICAgIGlmIChtZWRpYS5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygncmVkNXByby1tZWRpYS1jb250YWluZXInKSkge1xuICAgICAgcmV0dXJuIG1lZGlhLnBhcmVudE5vZGVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBtZWRpYS5wYXJlbnROb2RlXG4gICAgICBjb25zdCBkaXYgPSBlbnZpcm9ubWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyJylcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZGl2LCBtZWRpYSlcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChtZWRpYSlcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChtZWRpYSlcbiAgICAgIHJldHVybiBkaXZcbiAgICB9XG4gIH1cblxuICBjbGVhblVwICgpIHtcbiAgICAvLyBSZXR1cm4gdG8gcHJpb3IgRE9NIG1hbmlwdWxhdGlvbi5cbiAgICB0aGlzLm1lZGlhLnJlbW92ZSgpXG4gICAgdGhpcy5tZWRpYSA9IHRoaXMuY2xvbmUuY2xvbmVOb2RlKHRydWUpXG4gICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5tZWRpYSlcbiAgfVxuXG4gIF9hZGRQbGF5YmFja0hhbmRsZXJzIChub3RpZmllcikge1xuICAgIGNvbnN0IGNvbnRyb2xzID0gdGhpcy5nZXRDb250cm9scygpXG4gICAgaWYgKHR5cGVvZiBjb250cm9scyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBub3RpZmllci5vbihTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RBUlQsICgpID0+IHtcbiAgICAgIGNvbnRyb2xzLnNldFN0YXRlKFBsYXliYWNrU3RhdGUuUExBWUlORylcbiAgICB9KVxuICAgIG5vdGlmaWVyLm9uKFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVE9QLCAoKSA9PiB7XG4gICAgICBjb250cm9scy5zZXRTdGF0ZShQbGF5YmFja1N0YXRlLklETEUpXG4gICAgfSlcbiAgICBub3RpZmllci5vbihTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZX1VOUFVCTElTSCwgKCkgPT4ge1xuICAgICAgY29udHJvbHMuc2V0U3RhdGUoUGxheWJhY2tTdGF0ZS5JRExFKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX01FVEFEQVRBLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhLmR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnRyb2xzLnNldFBsYXliYWNrRHVyYXRpb24oZXZlbnQuZGF0YS5kdXJhdGlvbilcbiAgICAgIH1cbiAgICB9KVxuICAgIG5vdGlmaWVyLm9uKFN1YnNjcmliZXJFdmVudFR5cGVzLlZPTFVNRV9DSEFOR0UsIChldmVudCkgPT4ge1xuICAgICAgY29udHJvbHMuc2V0Vm9sdW1lKGV2ZW50LmRhdGEudm9sdW1lKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfU1RBVEVfQ0hBTkdFLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhLmNvZGUgPT09IFBsYXliYWNrU3RhdGUuQVZBSUxBQkxFKSB7XG4gICAgICAgIGNvbnRyb2xzLmVuYWJsZVBsYXlQYXVzZSh0cnVlKVxuICAgICAgfVxuICAgICAgY29udHJvbHMuc2V0U3RhdGUoZXZlbnQuZGF0YS5jb2RlKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuUExBWUJBQ0tfVElNRV9VUERBVEUsIChldmVudCkgPT4ge1xuICAgICAgY29udHJvbHMuc2V0U2Vla1RpbWUoZXZlbnQuZGF0YS50aW1lLCBldmVudC5kYXRhLmR1cmF0aW9uKVxuICAgIH0pXG4gICAgbm90aWZpZXIub24oU3Vic2NyaWJlckV2ZW50VHlwZXMuRlVMTF9TQ1JFRU5fU1RBVEVfQ0hBTkdFLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnRyb2xzLm9uRnVsbFNjcmVlbkNoYW5nZShldmVudC5kYXRhKVxuICAgIH0pXG4gIH1cblxuICBfaGFuZGxlRnVsbFNjcmVlbkNoYW5nZSAoaXNGdWxsU2NyZWVuKSB7XG4gICAgY29uc3Qgc3dmb2JqZWN0ID0gdGhpcy5nZXRFbWJlZGRlZFZpZXcoKVxuICAgIGlmIChpc0Z1bGxTY3JlZW4pIHtcbiAgICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICAgIHN3Zm9iamVjdC5jbGFzc0xpc3QuYWRkKCdyZWQ1cHJvLW1lZGlhLWNvbnRhaW5lci1mdWxsLXNjcmVlbicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnJlbW92ZSgncmVkNXByby1tZWRpYS1jb250YWluZXItZnVsbC1zY3JlZW4nKVxuICAgICAgc3dmb2JqZWN0LmNsYXNzTGlzdC5yZW1vdmUoJ3JlZDVwcm8tbWVkaWEtY29udGFpbmVyLWZ1bGwtc2NyZWVuJylcbiAgICB9XG4gICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5GVUxMX1NDUkVFTl9TVEFURV9DSEFOR0UsIHVuZGVmaW5lZCwgaXNGdWxsU2NyZWVuKSlcbiB9XG5cbiAgX3NldFVwSW5pdENhbGxiYWNrIChwcm9taXNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBlbnZpcm9ubWVudC5hZGRTdWJzY3JpcHRpb25Bc3NpZ25tZW50SGFuZGxlcihzdWNjZXNzSWQgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYEVtYmVkIGFuZCBpbml0KCkgY29tcGxldGUgZm9yIHN1YnNjcmliZXIgc3dmLiBzdWNjZXNzSWQoJHtzdWNjZXNzSWR9KS5gKVxuICAgICAgcHJvbWlzZS5yZXNvbHZlKHN1Y2Nlc3NJZClcbiAgICAgIHNlbGYuX3RlYXJEb3duSW5pdENhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgX3RlYXJEb3duSW5pdENhbGxiYWNrICgpIHt9XG5cbiAgYWRkU291cmNlIChzd2ZJZCwgb3B0aW9ucywgc3dmVXJsID0gbnVsbCwgbWluRmxhc2hWZXJzaW9uID0gbnVsbCkge1xuICAgIGRlYnVnKE5BTUUsICdbYWRkc291cmNlXScpXG4gICAgdGhpcy5fc3dmSWQgPSBzd2ZJZDtcbiAgICBjb25zdCBzb1Jlc3BvbmRlciA9IHRoaXMuX3NvUmVzcG9uZGVyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBoYXNEZWZpbmVkQ29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzXG4gICAgY29uc3QgaXNNdXRlZCA9IGVudmlyb25tZW50Lmhhc0F0dHJpYnV0ZURlZmluZWQodGhpcy5tZWRpYSwgJ211dGVkJylcbiAgICBjb25zdCB1c2VQbGF5YmFja0NvbnRyb2xzID0gZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh0aGlzLm1lZGlhLCAnY29udHJvbHMnKSAmJiBlbnZpcm9ubWVudC5oYXNDbGFzc0RlZmluZWQodGhpcy5tZWRpYSwgJ3JlZDVwcm8tbWVkaWEnKVxuICAgIG9wdGlvbnMuc3dmID0gc3dmVXJsIHx8IG9wdGlvbnMuc3dmXG4gICAgb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gPSBtaW5GbGFzaFZlcnNpb24gfHwgb3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICB0aGlzLl9zZXRVcEluaXRDYWxsYmFjayhkZWZlcnJlZClcbiAgICBjb25zdCBjbGFzc0xpc3QgPSB0aGlzLm1lZGlhLmNsYXNzTGlzdFxuICAgIGVtYmVkLmRlZmluZUVtYmVkRWxlbWVudCh0aGlzLm1lZGlhLCB0aGlzLmhvbGRlcilcbiAgICAgIC50aGVuKGVsZW1lbnRJZCA9PiB7XG4gICAgICAgIGxldCBmbGFzaHZhcnMgPSB7XG4gICAgICAgICAgc3RyZWFtOiBvcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICAgICAgYXBwOiBvcHRpb25zLmNvbnRleHQgPyBgJHtvcHRpb25zLmFwcH0vJHtvcHRpb25zLmNvbnRleHR9YCA6IG9wdGlvbnMuYXBwLFxuICAgICAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdCxcbiAgICAgICAgICBtdXRlZDogZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh0aGlzLm1lZGlhLCAnbXV0ZWQnKSxcbiAgICAgICAgICBhdXRvcGxheTogZW52aXJvbm1lbnQuaGFzQXR0cmlidXRlRGVmaW5lZCh0aGlzLm1lZGlhLCAnYXV0b3BsYXknKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgIGZsYXNodmFycy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvclxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmJ1ZmZlciAmJiAhaXNOYU4oTnVtYmVyKG9wdGlvbnMuYnVmZmVyKSkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuYnVmZmVyID0gb3B0aW9ucy5idWZmZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiAhaXNOYU4ob3B0aW9ucy53aWR0aCkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMud2lkdGggPSB0b0ludChvcHRpb25zLndpZHRoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAmJiAhaXNOYU4ob3B0aW9ucy5oZWlnaHQpKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmhlaWdodCA9IHRvSW50KG9wdGlvbnMuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVtYmVkV2lkdGggPT09ICcxMDAlJyB8fCBvcHRpb25zLmVtYmVkSGVpZ2h0ID09PSAnMTAwJScpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuYXV0b3NpemUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3dmSWQgPSBzd2ZJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmNvbm5lY3Rpb25QYXJhbXMgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1iZWQuZW1iZWRTd2ZPYmplY3Qoc3dmSWQsIG9wdGlvbnMsIGZsYXNodmFycywgZW52aXJvbm1lbnQuZ2V0U3dmT2JqZWN0KCksIGVsZW1lbnRJZClcbiAgICAgIH0pXG4gICAgICAudGhlbiggKCkgPT4ge1xuICAgICAgICBpZiAoaGFzRGVmaW5lZENvbnRyb2xzIHx8IHVzZVBsYXliYWNrQ29udHJvbHMpIHtcbiAgICAgICAgICBpZiAoaGFzRGVmaW5lZENvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9scyA9IG9wdGlvbnMuY29udHJvbHNcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9scyA9IG5ldyBQbGF5YmFja0NvbnRyb2xzSW1wbCh0aGlzLCB0aGlzLmhvbGRlcilcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tZWRpYS5jb250cm9scyA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5fY29udHJvbHMuc2V0QXNWT0QoaXNWT0RTdHJlYW1OYW1lKG9wdGlvbnMuc3RyZWFtTmFtZSkpXG4gICAgICAgICAgdGhpcy5fY29udHJvbHMuc2V0TXV0ZWRTdGF0ZShpc011dGVkKVxuICAgICAgICAgIGNvbnN0IGVtYmVkZGVkID0gdGhpcy5nZXRFbWJlZGRlZFZpZXcoKVxuICAgICAgICAgIGxldCBpbmRleCA9IGNsYXNzTGlzdC5sZW5ndGgsIGNsYXp6XG4gICAgICAgICAgd2hpbGUgKC0taW5kZXggPiAtMSkge1xuICAgICAgICAgICAgY2xhenogPSBjbGFzc0xpc3QuaXRlbShpbmRleClcbiAgICAgICAgICAgIGVtYmVkZGVkLmNsYXNzTGlzdC5hZGQoY2xhenopXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZFBsYXliYWNrSGFuZGxlcnModGhpcy5fcGxheWJhY2tOb3RpZmljYXRpb25DZW50ZXIpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlCQUNLX1NUQVRFX0NIQU5HRSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgY29kZTogUGxheWJhY2tTdGF0ZS5BVkFJTEFCTEUsXG4gICAgICAgICAgc3RhdGU6IFBsYXliYWNrU3RhdGVSZWFkYWJsZVtQbGF5YmFja1N0YXRlLkFWQUlMQUJMRV1cbiAgICAgICAgfSkpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgICAgLnRoZW4oICgpID0+IHtcbiAgICAgICAgc29SZXNwb25kZXIuY29ubmVjdChzd2ZJZClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiBkZWZlcnJlZC5yZWplY3QoZSkpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLmNvbm5lY3QoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIHBsYXkgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnBsYXkoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG5cbiAgcGF1c2UgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnBhdXNlKClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICByZXN1bWUgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdldEVtYmVkZGVkVmlldygpLnJlc3VtZSgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkuc3RvcCgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgbXV0ZSAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2V0RW1iZWRkZWRWaWV3KCkubXV0ZSgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgdW5tdXRlICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS51bm11dGUoKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIHNldFZvbHVtZSAodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS5zZXRWb2x1bWUodmFsdWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgc2Vla1RvICh2YWx1ZSwgZHVyYXRpb24gPSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS5zZWVrVG8odmFsdWUsIGR1cmF0aW9uKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUZ1bGxTY3JlZW4gKCkge1xuICAgIHRyeSB7XG4gICAgICBlbnZpcm9ubWVudC50b2dnbGVGdWxsU2NyZWVuKHRoaXMuaG9sZGVyKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3RdJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5nZXRFbWJlZGRlZFZpZXcoKS5kaXNjb25uZWN0KClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBuYWRhLlxuICAgIH1cbiAgICB0aGlzLmNsZWFuVXAoKVxuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgYWRkU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuYWRkUmVzcG9uc2VIYW5kbGVyKGhhbmRsZXIpXG4gIH1cblxuICByZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5yZW1vdmVSZXNwb25zZUhhbmRsZXIoaGFuZGxlcilcbiAgfVxuXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5zZW5kVG9TaGFyZWRPYmplY3QobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpXG4gIH1cblxuICBzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCAobmFtZSwga2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLnNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0KG5hbWUsIGtleSwgdmFsdWUpXG4gIH1cblxuICBnZXRSZW1vdGVTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5nZXRSZW1vdGVTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIGNvbm5lY3RUb1NoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmNvbm5lY3RUb1NoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICB9XG5cbiAgY2xvc2VTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5jbG9zZVNoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICB9XG5cbiAgZ2V0RW1iZWRkZWRWaWV3ICgpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fc3dmSWQpXG4gIH1cblxuICBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xzXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVE1QU291cmNlSGFuZGxlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1zb3VyY2UtaGFuZGxlci1ydG1wLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwucHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IGdsb2JhbC5wcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFiZWwtcG9seWZpbGwvfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpc0FycmF5ICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwpe1xuICB2YXIgQztcbiAgaWYoaXNBcnJheShvcmlnaW5hbCkpe1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlDID0gdW5kZWZpbmVkO1xuICAgIGlmKGlzT2JqZWN0KEMpKXtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYoQyA9PT0gbnVsbClDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBOVU1CRVIgICAgICA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGhpbnQpe1xuICBpZihoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKXRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhdGggICAgICA9IHJlcXVpcmUoJy4vX3BhdGgnKVxuICAsIGludm9rZSAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigvKiAuLi5wYXJncyAqLyl7XG4gIHZhciBmbiAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIHBhcmdzICA9IEFycmF5KGxlbmd0aClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIF8gICAgICA9IHBhdGguX1xuICAgICwgaG9sZGVyID0gZmFsc2U7XG4gIHdoaWxlKGxlbmd0aCA+IGkpaWYoKHBhcmdzW2ldID0gYXJndW1lbnRzW2krK10pID09PSBfKWhvbGRlciA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaiA9IDAsIGsgPSAwLCBhcmdzO1xuICAgIGlmKCFob2xkZXIgJiYgIWFMZW4pcmV0dXJuIGludm9rZShmbiwgcGFyZ3MsIHRoYXQpO1xuICAgIGFyZ3MgPSBwYXJncy5zbGljZSgpO1xuICAgIGlmKGhvbGRlcilmb3IoO2xlbmd0aCA+IGo7IGorKylpZihhcmdzW2pdID09PSBfKWFyZ3Nbal0gPSBhcmd1bWVudHNbaysrXTtcbiAgICB3aGlsZShhTGVuID4gaylhcmdzLnB1c2goYXJndW1lbnRzW2srK10pO1xuICAgIHJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL19wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2Upe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlICAgICA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywge2VzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KXsgcmV0dXJuICRyZShpdCk7IH19KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge2NvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyl9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXZlcnkgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpXG4gICwgS0VZICAgICA9ICdmaW5kSW5kZXgnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpXG4gICwgS0VZICAgICA9ICdmaW5kJ1xuICAsIGZvcmNlZCAgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgY2FsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5JylcbiAgLCBnZXRJdGVyRm4gICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChhcnJheUxpa2UpXG4gICAgICAsIEMgICAgICAgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5XG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmRleE9mICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5pbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7aXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3Ipe1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0b0lPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9JbnRlZ2VyICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5sYXN0SW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gQFsqLTFdICovKXtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYoTkVHQVRJVkVfWkVSTylyZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gbGVuZ3RoIC0gMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSlpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yKDtpbmRleCA+PSAwOyBpbmRleC0tKWlmKGluZGV4IGluIE8paWYoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRtYXAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlKGFMZW4gPiBpbmRleCljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBodG1sICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY29mICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgdG9JbmRleCAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBpZihodG1sKWFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCAgPSB0b0luZGV4KGJlZ2luLCBsZW4pXG4gICAgICAsIHVwVG8gICA9IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcbiAgICAgICwgY2xvbmVkID0gQXJyYXkoc2l6ZSlcbiAgICAgICwgaSAgICAgID0gMDtcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRzb21lICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5zb21lLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGZhaWxzICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkc29ydCAgICAgPSBbXS5zb3J0XG4gICwgdGVzdCAgICAgID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qc1xuLy8gbW9kdWxlIGlkID0gMTkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywge25vdzogZnVuY3Rpb24oKXsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG5cbnZhciBseiA9IGZ1bmN0aW9uKG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoLTVlMTMgLSAxKS50b0lTT1N0cmluZygpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTtcbn0pKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpe1xuICAgIGlmKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICAgIHZhciBkID0gdGhpc1xuICAgICAgLCB5ID0gZC5nZXRVVENGdWxsWWVhcigpXG4gICAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgICAsIHMgPSB5IDwgMCA/ICctJyA6IHkgPiA5OTk5ID8gJysnIDogJyc7XG4gICAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICAgJ1QnICsgbHooZC5nZXRVVENIb3VycygpKSArICc6JyArIGx6KGQuZ2V0VVRDTWludXRlcygpKSArXG4gICAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHt0b0lTT1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH19KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KXtcbiAgICB2YXIgTyAgPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKVxuICAsIHByb3RvICAgICAgICA9IERhdGUucHJvdG90eXBlO1xuXG5pZighKFRPX1BSSU1JVElWRSBpbiBwcm90bykpcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIERhdGVQcm90byAgICA9IERhdGUucHJvdG90eXBlXG4gICwgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSdcbiAgLCBUT19TVFJJTkcgICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgID0gRGF0ZVByb3RvW1RPX1NUUklOR11cbiAgLCBnZXRUaW1lICAgICAgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHtiaW5kOiByZXF1aXJlKCcuL19iaW5kJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIEhBU19JTlNUQU5DRSAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvICA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHt2YWx1ZTogZnVuY3Rpb24oTyl7XG4gIGlmKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKXJldHVybiBmYWxzZTtcbiAgaWYoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSlyZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSlpZih0aGlzLnByb3RvdHlwZSA9PT0gTylyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBoYXMgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBGUHJvdG8gICAgID0gRnVuY3Rpb24ucHJvdG90eXBlXG4gICwgbmFtZVJFICAgICA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopL1xuICAsIE5BTUUgICAgICAgPSAnbmFtZSc7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAoJycgKyB0aGF0KS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgaGFzKHRoYXQsIE5BTUUpIHx8ICFpc0V4dGVuc2libGUodGhhdCkgfHwgZFAodGhhdCwgTkFNRSwgY3JlYXRlRGVzYyg1LCBuYW1lKSk7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBsb2cxcCAgID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpXG4gICwgc3FydCAgICA9IE1hdGguc3FydFxuICAsICRhY29zaCAgPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTiBcbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qc1xuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXNpbmggID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCl7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywge2FzaW5oOiBhc2luaH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanNcbi8vIG1vZHVsZSBpZCA9IDIwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0YW5oICA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCl7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KXtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanNcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXhwbTEgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge2V4cG0xOiAkZXhwbTF9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKVxuICAsIHBvdyAgICAgICA9IE1hdGgucG93XG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KXtcbiAgICB2YXIgJGFicyAgPSBNYXRoLmFicyh4KVxuICAgICAgLCAkc2lnbiA9IHNpZ24oeClcbiAgICAgICwgYSwgcmVzdWx0O1xuICAgIGlmKCRhYnMgPCBNSU4zMilyZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICAgIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgICBpZihyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KXJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICAgIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDIwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhYnMgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgYUxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanNcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGltdWwgICA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSl7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCB4biA9ICt4XG4gICAgICAsIHluID0gK3lcbiAgICAgICwgeGwgPSBVSU5UMTYgJiB4blxuICAgICAgLCB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge2xvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanNcbi8vIG1vZHVsZSBpZCA9IDIxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpe1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxuICAgICAgLCBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qc1xuLy8gbW9kdWxlIGlkID0gMjE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCl7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gMjE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanNcbi8vIG1vZHVsZSBpZCA9IDIxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7aXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbiAgLCBhYnMgICAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKXtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywge3BhcnNlSW50OiAkcGFyc2VJbnR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbnRlZ2VyICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsIHJlcGVhdCAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsICR0b0ZpeGVkICAgICA9IDEuLnRvRml4ZWRcbiAgLCBmbG9vciAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgZGF0YSAgICAgICAgID0gWzAsIDAsIDAsIDAsIDAsIDBdXG4gICwgRVJST1IgICAgICAgID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnXG4gICwgWkVSTyAgICAgICAgID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbihuLCBjKXtcbiAgdmFyIGkgID0gLTFcbiAgICAsIGMyID0gYztcbiAgd2hpbGUoKytpIDwgNil7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgaSA9IDZcbiAgICAsIGMgPSAwO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgaSA9IDZcbiAgICAsIHMgPSAnJztcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGlmKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCl7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbih4LCBuLCBhY2Mpe1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uKHgpe1xuICB2YXIgbiAgPSAwXG4gICAgLCB4MiA9IHg7XG4gIHdoaWxlKHgyID49IDQwOTYpe1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSh4MiA+PSAyKXtcbiAgICBuICArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cyl7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpXG4gICAgICAsIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpXG4gICAgICAsIHMgPSAnJ1xuICAgICAgLCBtID0gWkVST1xuICAgICAgLCBlLCB6LCBqLCBrO1xuICAgIGlmKGYgPCAwIHx8IGYgPiAyMCl0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICBpZih4ICE9IHgpcmV0dXJuICdOYU4nO1xuICAgIGlmKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKXJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYoeCA8IDApe1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYoeCA+IDFlLTIxKXtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYoZSA+IDApe1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlKGogPj0gNyl7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUoaiA+PSAyMyl7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihmID4gMCl7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZhaWxzICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCAkdG9QcmVjaXNpb24gPSAxLi50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7IFxuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24oJGZyZWV6ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbigkaXNFeHRlbnNpYmxlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbigkaXNGcm96ZW4pe1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qc1xuLy8gbW9kdWxlIGlkID0gMjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24oJGlzU2VhbGVkKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2lzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanNcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbigkcHJldmVudEV4dGVuc2lvbnMpe1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanNcbi8vIG1vZHVsZSBpZCA9IDI0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCB0ZXN0ICAgID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwge3BhcnNlSW50OiAkcGFyc2VJbnR9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDI0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNsYXNzb2YgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbkluc3RhbmNlICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCB0YXNrICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgbWljcm90YXNrICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIFBST01JU0UgICAgICAgICAgICA9ICdQcm9taXNlJ1xuICAsIFR5cGVFcnJvciAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsICRQcm9taXNlICAgICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgICAgICAgICAgID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBlbXB0eSAgICAgICAgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgSW50ZXJuYWwsIEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgICAgID0gJFByb21pc2UucmVzb2x2ZSgxKVxuICAgICAgLCBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24oZXhlYyl7IGV4ZWMoZW1wdHksIGVtcHR5KTsgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGEsIGIpe1xuICAvLyB3aXRoIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSA9PT0gJFByb21pc2UgJiYgYiA9PT0gV3JhcHBlcjtcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgcmV0dXJuIHNhbWVDb25zdHJ1Y3RvcigkUHJvbWlzZSwgQylcbiAgICA/IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgIDogbmV3IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24oJCRyZXNvbHZlLCAkJHJlamVjdCl7XG4gICAgaWYocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xudmFyIHBlcmZvcm0gPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICBleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNSZWplY3Qpe1xuICBpZihwcm9taXNlLl9uKXJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgb2sgICAgPSBwcm9taXNlLl9zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgZG9tYWluICA9IHJlYWN0aW9uLmRvbWFpblxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvayl7XG4gICAgICAgICAgICBpZihwcm9taXNlLl9oID09IDIpb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoaGFuZGxlciA9PT0gdHJ1ZSlyZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSl7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKW9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIGFicnVwdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZihpc1VuaGFuZGxlZChwcm9taXNlKSl7XG4gICAgICBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKXtcbiAgICAgICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlfSk7XG4gICAgICAgIH0gZWxzZSBpZigoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYoYWJydXB0KXRocm93IGFicnVwdC5lcnJvcjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIGlmKHByb21pc2UuX2ggPT0gMSlyZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fY1xuICAgICwgaSAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZihpc05vZGUpe1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKXtcbiAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdn0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYoIXByb21pc2UuX2EpcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHByb21pc2UgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7X3c6IHByb21pc2UsIF9kOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICAkcmVqZWN0LmNhbGwoe193OiBwcm9taXNlLCBfZDogZmFsc2V9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYoIVVTRV9OQVRJVkUpe1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiAgICA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgICAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsICAgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9hKXRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9zKW5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBwcm9taXNlICA9IG5ldyBJbnRlcm5hbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7UHJvbWlzZTogJFByb21pc2V9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlamVjdCAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYoeCBpbnN0YW5jZW9mICRQcm9taXNlICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSlyZXR1cm4geDtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVzb2x2ZSAgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgJCRyZXNvbHZlKHgpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVzb2x2ZSAgICA9IGNhcGFiaWxpdHkucmVzb2x2ZVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIHZhciB2YWx1ZXMgICAgPSBbXVxuICAgICAgICAsIGluZGV4ICAgICA9IDBcbiAgICAgICAgLCByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgdmFyICRpbmRleCAgICAgICAgPSBpbmRleCsrXG4gICAgICAgICAgLCBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCAgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHJBcHBseSAgICA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseVxuICAsIGZBcHBseSAgICA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJBcHBseShmdW5jdGlvbigpe30pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldClcbiAgICAgICwgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGJpbmQgICAgICAgPSByZXF1aXJlKCcuL19iaW5kJylcbiAgLCByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbigpe1xuICByQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKXJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZihUYXJnZXQgPT0gbmV3VGFyZ2V0KXtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0O1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byAgICA9IG5ld1RhcmdldC5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgLCByZXN1bHQgICA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanNcbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbi8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRQLmYoe30sIDEsIHt2YWx1ZTogMX0pLCAxLCB7dmFsdWU6IDJ9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanNcbi8vIG1vZHVsZSBpZCA9IDI1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW10gICAgICAgLy8ga2V5c1xuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBrZXlzID0gdGhhdC5fa1xuICAgICwga2V5O1xuICBkbyB7XG4gICAgaWYodGhhdC5faSA+PSBrZXlzLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICB9IHdoaWxlKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4ge3ZhbHVlOiBrZXksIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCl7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXVxuICAgICwgZGVzYywgcHJvdG87XG4gIGlmKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKXJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZihkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKXJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtnZXQ6IGdldH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge293bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKCRwcmV2ZW50RXh0ZW5zaW9ucykkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMjYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZihzZXRQcm90bykkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKXtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgVi8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM11cbiAgICAsIG93bkRlc2MgID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KVxuICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYoIW93bkRlc2Mpe1xuICAgIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpe1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYoaGFzKG93bkRlc2MsICd2YWx1ZScpKXtcbiAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtzZXQ6IHNldH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgaXNSZWdFeHAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsICRmbGFncyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsICRSZWdFeHAgICAgICAgICAgID0gZ2xvYmFsLlJlZ0V4cFxuICAsIEJhc2UgICAgICAgICAgICAgID0gJFJlZ0V4cFxuICAsIHByb3RvICAgICAgICAgICAgID0gJFJlZ0V4cC5wcm90b3R5cGVcbiAgLCByZTEgICAgICAgICAgICAgICA9IC9hL2dcbiAgLCByZTIgICAgICAgICAgICAgICA9IC9hL2dcbiAgLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG4gICwgQ09SUkVDVF9ORVcgICAgICAgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpe1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpe1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHBcbiAgICAgICwgcGlSRSA9IGlzUmVnRXhwKHApXG4gICAgICAsIGZpVSAgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24oa2V5KXtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOyApcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCl7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDI2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKXtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbihkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpe1xuICAvLyAyMS4xLjMuMTUgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIHNlYXJjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFNQTElULCAkc3BsaXQpe1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgICAsIF9zcGxpdCAgICAgPSAkc3BsaXRcbiAgICAsICRwdXNoICAgICAgPSBbXS5wdXNoXG4gICAgLCAkU1BMSVQgICAgID0gJ3NwbGl0J1xuICAgICwgTEVOR1RIICAgICA9ICdsZW5ndGgnXG4gICAgLCBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApe1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmKCFpc1JlZ0V4cChzZXBhcmF0b3IpKXJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmKCFOUENHKXNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZShtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKXtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpe1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgaWYoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspaWYoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZihsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSl7XG4gICAgICAgIGlmKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSl7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkZmxhZ3MgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBUT19TVFJJTkcgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oZm4pe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoe3NvdXJjZTogJ2EnLCBmbGFnczogJ2InfSkgIT0gJy9hL2InOyB9KSl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORyl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qc1xuLy8gbW9kdWxlIGlkID0gMjcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qc1xuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qc1xuLy8gbW9kdWxlIGlkID0gMjczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgRU5EU19XSVRIID0gJ2VuZHNXaXRoJ1xuICAsICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpXG4gICAgICAsIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpXG4gICAgICAsIGVuZCAgICA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbilcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanNcbi8vIG1vZHVsZSBpZCA9IDI3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0luZGV4ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCBmcm9tQ2hhckNvZGUgICA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgLCAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgID0gW11cbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgY29kZTtcbiAgICB3aGlsZShhTGVuID4gaSl7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYodG9JbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qc1xuLy8gbW9kdWxlIGlkID0gMjc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvbnRleHQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qc1xuLy8gbW9kdWxlIGlkID0gMjgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDI4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsICA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiAgPSB0b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgID0gW11cbiAgICAgICwgaSAgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBhTGVuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanNcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qc1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnXG4gICwgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICB2YXIgdGhhdCAgID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKVxuICAgICAgLCBpbmRleCAgPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qc1xuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDI4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1Yigpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzXG4vLyBtb2R1bGUgaWQgPSAyODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qc1xuLy8gbW9kdWxlIGlkID0gMjkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0eXBlZCAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBidWZmZXIgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAsIGFuT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JbmRleCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBBcnJheUJ1ZmZlciAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlclxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAsICREYXRhVmlldyAgICA9IGJ1ZmZlci5EYXRhVmlld1xuICAsICRpc1ZpZXcgICAgICA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3XG4gICwgJHNsaWNlICAgICAgID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZVxuICAsIFZJRVcgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICwgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHtBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCl7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKXtcbiAgICBpZigkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZClyZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiAgICA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGhcbiAgICAgICwgZmlyc3QgID0gdG9JbmRleChzdGFydCwgbGVuKVxuICAgICAgLCBmaW5hbCAgPSB0b0luZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pXG4gICAgICAsIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbmFsIC0gZmlyc3QpKVxuICAgICAgLCB2aWV3UyAgPSBuZXcgJERhdGFWaWV3KHRoaXMpXG4gICAgICAsIHZpZXdUICA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIHdoaWxlKGZpcnN0IDwgZmluYWwpe1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDI5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDI5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMjk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAzMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDMwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qc1xuLy8gbW9kdWxlIGlkID0gMzA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIHByb2Nlc3MgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMzA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpe1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gMzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaWFkZGg6IGZ1bmN0aW9uIGlhZGRoKHgwLCB4MSwgeTAsIHkxKXtcbiAgICB2YXIgJHgwID0geDAgPj4+IDBcbiAgICAgICwgJHgxID0geDEgPj4+IDBcbiAgICAgICwgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSArICh5MSA+Pj4gMCkgKyAoKCR4MCAmICR5MCB8ICgkeDAgfCAkeTApICYgfigkeDAgKyAkeTAgPj4+IDApKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qc1xuLy8gbW9kdWxlIGlkID0gMzA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4gMTYpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaXN1Ymg6IGZ1bmN0aW9uIGlzdWJoKHgwLCB4MSwgeTAsIHkxKXtcbiAgICB2YXIgJHgwID0geDAgPj4+IDBcbiAgICAgICwgJHgxID0geDEgPj4+IDBcbiAgICAgICwgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSAtICh5MSA+Pj4gMCkgLSAoKH4keDAgJiAkeTAgfCB+KCR4MCBeICR5MCkgJiAkeDAgLSAkeTAgPj4+IDApID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge2dldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpe1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgb3duS2V5cyAgICAgICAgPSByZXF1aXJlKCcuL19vd24ta2V5cycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAgICwgZ2V0RGVzYyA9IGdPUEQuZlxuICAgICAgLCBrZXlzICAgID0gb3duS2V5cyhPKVxuICAgICAgLCByZXN1bHQgID0ge31cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gaSljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSA9IGtleXNbaSsrXSwgZ2V0RGVzYyhPLCBrZXkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMzE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi41IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBTZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwU2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwU2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELnNldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KXtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIG1pY3JvdGFzayAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIE9CU0VSVkFCTEUgID0gcmVxdWlyZSgnLi9fd2tzJykoJ29ic2VydmFibGUnKVxuICAsIGFGdW5jdGlvbiAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBoaWRlICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBSRVRVUk4gICAgICA9IGZvck9mLlJFVFVSTjtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGZuKXtcbiAgcmV0dXJuIGZuID09IG51bGwgPyB1bmRlZmluZWQgOiBhRnVuY3Rpb24oZm4pO1xufTtcblxudmFyIGNsZWFudXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYoY2xlYW51cCl7XG4gICAgc3Vic2NyaXB0aW9uLl9jID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXAoKTtcbiAgfVxufTtcblxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHJldHVybiBzdWJzY3JpcHRpb24uX28gPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBjbG9zZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgfVxufTtcblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKXtcbiAgYW5PYmplY3Qob2JzZXJ2ZXIpO1xuICB0aGlzLl9jID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vID0gb2JzZXJ2ZXI7XG4gIG9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xuICB0cnkge1xuICAgIHZhciBjbGVhbnVwICAgICAgPSBzdWJzY3JpYmVyKG9ic2VydmVyKVxuICAgICAgLCBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmKGNsZWFudXAgIT0gbnVsbCl7XG4gICAgICBpZih0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJyljbGVhbnVwID0gZnVuY3Rpb24oKXsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICByZXR1cm47XG4gIH0gaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKWNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG59O1xuXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCl7IGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpOyB9XG59KTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdGhpcy5fcyA9IHN1YnNjcmlwdGlvbjtcbn07XG5cblN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgaWYobSlyZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZihzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl0aHJvdyB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5lcnJvcik7XG4gICAgICBpZighbSl0aHJvdyB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKXtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcil7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX2YpO1xuICB9LFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuKXtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyAoY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgYUZ1bmN0aW9uKGZuKTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGF0LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQgOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUsIHtcbiAgZnJvbTogZnVuY3Rpb24gZnJvbSh4KXtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoYW5PYmplY3QoeClbT0JTRVJWQUJMRV0pO1xuICAgIGlmKG1ldGhvZCl7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGFuT2JqZWN0KG1ldGhvZC5jYWxsKHgpKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlLmNvbnN0cnVjdG9yID09PSBDID8gb2JzZXJ2YWJsZSA6IG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKGZvck9mKHgsIGZhbHNlLCBmdW5jdGlvbihpdCl7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZihkb25lKXJldHVybiBSRVRVUk47XG4gICAgICAgICAgICB9KSA9PT0gUkVUVVJOKXJldHVybjtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgaWYoZG9uZSl0aHJvdyBlO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCl7XG4gICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gQXJyYXkobCk7IGkgPCBsOylpdGVtc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xuICAgIHJldHVybiBuZXcgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlKShmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tpXSk7XG4gICAgICAgICAgICBpZihkb25lKXJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9XG59KTtcblxuaGlkZSgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9CU0VSVkFCTEUsIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtPYnNlcnZhYmxlOiAkT2JzZXJ2YWJsZX0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdPYnNlcnZhYmxlJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe2RlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpe1xuICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDMyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcFxuICAsIHN0b3JlICAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5zdG9yZTtcblxubWV0YWRhdGEuZXhwKHtkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgdmFyIHRhcmdldEtleSAgID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKVxuICAgICwgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZihtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKXJldHVybiBmYWxzZTtcbiAgaWYobWV0YWRhdGFNYXAuc2l6ZSlyZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFNldCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9lczYuc2V0JylcbiAgLCBmcm9tICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKVxuICAsIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbihPLCBQKXtcbiAgdmFyIG9LZXlzICA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgLCBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYocGFyZW50ID09PSBudWxsKXJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzICA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDMyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7Z2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDMyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHtoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7aGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDMyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7bWV0YWRhdGE6IGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSl7XG4gICAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShcbiAgICAgIG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLFxuICAgICAgKHRhcmdldEtleSAhPT0gdW5kZWZpbmVkID8gYW5PYmplY3QgOiBhRnVuY3Rpb24pKHRhcmdldCksXG4gICAgICB0b01ldGFLZXkodGFyZ2V0S2V5KVxuICAgICk7XG4gIH07XG59fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc1JlZ0V4cCAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZ2V0RmxhZ3MgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24ocmVnZXhwLCBzdHJpbmcpe1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpe1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7dmFsdWU6IG1hdGNoLCBkb25lOiBtYXRjaCA9PT0gbnVsbH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApe1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYoIWlzUmVnRXhwKHJlZ2V4cCkpdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTICAgICA9IFN0cmluZyh0aGlzKVxuICAgICAgLCBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKVxuICAgICAgLCByeCAgICA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qc1xuLy8gbW9kdWxlIGlkID0gMzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qc1xuLy8gbW9kdWxlIGlkID0gMzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gMzM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywge2dsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJyl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICRpdGVyYXRvcnMgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICwgcmVkZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgd2tzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgSVRFUkFUT1IgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAsIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgLCBBcnJheVZhbHVlcyAgID0gSXRlcmF0b3JzLkFycmF5O1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAsIGtleTtcbiAgaWYocHJvdG8pe1xuICAgIGlmKCFwcm90b1tJVEVSQVRPUl0paGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZighcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgZm9yKGtleSBpbiAkaXRlcmF0b3JzKWlmKCFwcm90b1trZXldKXJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHRhc2sgICA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogICAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIHBhcnRpYWwgICAgPSByZXF1aXJlKCcuL19wYXJ0aWFsJylcbiAgLCBuYXZpZ2F0b3IgID0gZ2xvYmFsLm5hdmlnYXRvclxuICAsIE1TSUUgICAgICAgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHNldCl7XG4gIHJldHVybiBNU0lFID8gZnVuY3Rpb24oZm4sIHRpbWUgLyosIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBzZXQoaW52b2tlKFxuICAgICAgcGFydGlhbCxcbiAgICAgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbilcbiAgICApLCB0aW1lKTtcbiAgfSA6IHNldDtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogIHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDM0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaWFkZGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pc3ViaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmltdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgudW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jb3JlLWpzL3NoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDM0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9